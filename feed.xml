<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://changgunyee.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://changgunyee.github.io/" rel="alternate" type="text/html" /><updated>2019-08-27T12:45:37+09:00</updated><id>https://changgunyee.github.io/feed.xml</id><title type="html">changgunyee</title><subtitle>개발,음악 등의 잡동사니를 모아두는 블로그</subtitle><author><name>이창권</name></author><entry><title type="html">부스트 코스(웹) PROJ4-2</title><link href="https://changgunyee.github.io/boost-course/2019/08/27/boostCourse(web)-proj4-2.html" rel="alternate" type="text/html" title="부스트 코스(웹) PROJ4-2" /><published>2019-08-27T00:00:00+09:00</published><updated>2019-08-27T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-course/2019/08/27/boostCourse(web)-proj4-2</id><content type="html" xml:base="https://changgunyee.github.io/boost-course/2019/08/27/boostCourse(web)-proj4-2.html">&lt;p&gt;부스트 코스 proj4-2를 진행하였습니다.&lt;/p&gt;

&lt;p&gt;이번에는 네이버 예약 서비스 상세페이지의 프론트엔드를 개발하였습니다.&lt;br /&gt;
개발해야하는 파트는 총 3부분으로 display item의 정보를 보여주는 메인 상세페이지와 해당 display item의 모든 한줄평을 볼 수 있는 한줄평 상세페이지 그리고 메인 상세페이지 상단의 타이틀영역 배경이미지 슬라이딩입니다.&lt;/p&gt;

&lt;h2 id=&quot;메인-상세페이지detail-view와-한줄평-상세페이지comment-view&quot;&gt;메인 상세페이지(detail view)와 한줄평 상세페이지(comment view)&lt;/h2&gt;

&lt;p&gt;메인 페이지에서 display item을 선택하면 해당 item의 메인 상세페이지로 이동하게 됩니다. 이때 data를 상세페이지에 렌더링합니다.&lt;br /&gt;
원래 렌더링을 순수하고 javascript만 사용해서 하였었습니다. 하지만 리뷰어님께서 Spring MVC를 배우는 과정이니 jsp를 쓰라고 말씀해주셔서 proj3-2까지 다 jsp로 수정하였습니다.&lt;/p&gt;

&lt;p&gt;이번 과정에 EL과 JSTL의 강의도 있었던 만큼, 적극적으로 EL과 JSTL을 사용하였습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;EL(expression language)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;EL을 사용하면 좀 더 편리하게 변수를 JSP에서 사용할 수 있습니다.&lt;br /&gt;
기본 사용법은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-27/el.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;특히 객체안의 멤버 변수에 접근할 때에도 &lt;code class=&quot;highlighter-rouge&quot;&gt;${&amp;lt;표현1&amp;gt;.&amp;lt;표현2&amp;gt;}&lt;/code&gt;와 같이 바로 접근할 수 있을 만큼 편리합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JSTL(JSP standard tag library)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;프론트 개발자가 JSP를 수정하는데, JSP 안에 자바코드와 HTML코드가 섞여 있다면 수정할 때 굉장히 어려움을 느끼게 될 가능성이 큽니다.&lt;br /&gt;
이런 문제를 해결하기 위해서 등장한 것이 JSTL입니다.&lt;br /&gt;
JSTL을 이용하면 태그형식으로 조건문, 반복문 등을 사용할 수 있습니다.&lt;br /&gt;
그리고, 앞에서 배운 EL과 연동하면 더욱 강력하게 사용 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-jsp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;%@ taglib &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;prefix=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt; uri=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://java.sun.com/jsp/jstl/core&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;%&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 jsp파일에 가장 주로 쓰는 core library tag를 추가하고 아래와 같이 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-27/jstl.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;core taglibrary뿐만 아니라 다양한 jstl tag를 사용할 수 있는데 이번에 평균 출력시 소수점 1자리까지만 출력해야하고, 날짜를 &lt;code class=&quot;highlighter-rouge&quot;&gt;2019.01.29&lt;/code&gt;와 같이 출력해야하기 때문에 fmt library를 사용하였습니다.&lt;/p&gt;

&lt;p&gt;밑과 같이 사용하였습니다.&lt;/p&gt;

&lt;div class=&quot;language-jsp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;%@ taglib &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;prefix=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt; uri=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://java.sun.com/jsp/jstl/fmt&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;%&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;fmt:formatNumber &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;averageScore&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt; pattern=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/fmt:formatNumber&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;fmt:formatDate &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reservationDate&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt; pattern=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yyyy.MM.dd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/fmt:formatDate&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 EL과 JSTL을 사용하여 detail.jsp와 comment.jsp를 구성하였습니다.&lt;br /&gt;
또한 펼쳐보기도 JS와 css class를 사용하여 클릭하면 close class를 추가, 삭제하는 방식으로 구현하였고 상세정보와 오시는길 탭 또한 버블링을 이용하여 클릭 시 렌더링해주었습니다.&lt;/p&gt;

&lt;h2 id=&quot;타이틀영역-배경이미지-슬라이딩&quot;&gt;타이틀영역 배경이미지 슬라이딩&lt;/h2&gt;

&lt;p&gt;슬라이딩 구현시 원래는 css의 animation을 사용하여 구현하였으나 평가 기준표에 transform과 translate를 사용하라고 하여 고생하였습니다.ㅠㅠ&lt;br /&gt;
특히 css의 left와 transform 속성을 잘 조절해주어야 하는데, 그럴려면 어쩔수없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout()&lt;/code&gt;을 사용할 수 밖에 없었습니다.(&lt;strong&gt;맞는건지 모르겠습니다&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;시현 결과입니당.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-27/simulation.gif&quot; style=&quot;width:40%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트를 통과한 모습입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-27/complete.png&quot; /&gt;&lt;/p&gt;</content><author><name>이창권</name></author><summary type="html">부스트 코스 proj4-2를 진행하였습니다. 이번에는 네이버 예약 서비스 상세페이지의 프론트엔드를 개발하였습니다. 개발해야하는 파트는 총 3부분으로 display item의 정보를 보여주는 메인 상세페이지와 해당 display item의 모든 한줄평을 볼 수 있는 한줄평 상세페이지 그리고 메인 상세페이지 상단의 타이틀영역 배경이미지 슬라이딩입니다. 메인 상세페이지(detail view)와 한줄평 상세페이지(comment view) 메인 페이지에서 display item을 선택하면 해당 item의 메인 상세페이지로 이동하게 됩니다. 이때 data를 상세페이지에 렌더링합니다. 원래 렌더링을 순수하고 javascript만 사용해서 하였었습니다. 하지만 리뷰어님께서 Spring MVC를 배우는 과정이니 jsp를 쓰라고 말씀해주셔서 proj3-2까지 다 jsp로 수정하였습니다. 이번 과정에 EL과 JSTL의 강의도 있었던 만큼, 적극적으로 EL과 JSTL을 사용하였습니다. EL(expression language) EL을 사용하면 좀 더 편리하게 변수를 JSP에서 사용할 수 있습니다. 기본 사용법은 다음과 같습니다. 특히 객체안의 멤버 변수에 접근할 때에도 ${&amp;lt;표현1&amp;gt;.&amp;lt;표현2&amp;gt;}와 같이 바로 접근할 수 있을 만큼 편리합니다. JSTL(JSP standard tag library) 프론트 개발자가 JSP를 수정하는데, JSP 안에 자바코드와 HTML코드가 섞여 있다면 수정할 때 굉장히 어려움을 느끼게 될 가능성이 큽니다. 이런 문제를 해결하기 위해서 등장한 것이 JSTL입니다. JSTL을 이용하면 태그형식으로 조건문, 반복문 등을 사용할 수 있습니다. 그리고, 앞에서 배운 EL과 연동하면 더욱 강력하게 사용 가능합니다. &amp;lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&amp;gt; 위와 같이 jsp파일에 가장 주로 쓰는 core library tag를 추가하고 아래와 같이 사용할 수 있습니다. core taglibrary뿐만 아니라 다양한 jstl tag를 사용할 수 있는데 이번에 평균 출력시 소수점 1자리까지만 출력해야하고, 날짜를 2019.01.29와 같이 출력해야하기 때문에 fmt library를 사용하였습니다. 밑과 같이 사용하였습니다. &amp;lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&amp;gt; &amp;lt;fmt:formatNumber value=&quot;${averageScore}&quot; pattern=&quot;.0&quot;&amp;gt;&amp;lt;/fmt:formatNumber&amp;gt; &amp;lt;fmt:formatDate value=&quot;${comment.reservationDate}&quot; pattern=&quot;yyyy.MM.dd&quot;&amp;gt;&amp;lt;/fmt:formatDate&amp;gt; 위와 같이 EL과 JSTL을 사용하여 detail.jsp와 comment.jsp를 구성하였습니다. 또한 펼쳐보기도 JS와 css class를 사용하여 클릭하면 close class를 추가, 삭제하는 방식으로 구현하였고 상세정보와 오시는길 탭 또한 버블링을 이용하여 클릭 시 렌더링해주었습니다. 타이틀영역 배경이미지 슬라이딩 슬라이딩 구현시 원래는 css의 animation을 사용하여 구현하였으나 평가 기준표에 transform과 translate를 사용하라고 하여 고생하였습니다.ㅠㅠ 특히 css의 left와 transform 속성을 잘 조절해주어야 하는데, 그럴려면 어쩔수없이 setTimeout()을 사용할 수 밖에 없었습니다.(맞는건지 모르겠습니다) 시현 결과입니당. 프로젝트를 통과한 모습입니다.</summary></entry><entry><title type="html">부스트 코스(웹) PROJ4-1</title><link href="https://changgunyee.github.io/boost-course/2019/08/20/boostCourse(web)-proj4-1.html" rel="alternate" type="text/html" title="부스트 코스(웹) PROJ4-1" /><published>2019-08-20T00:00:00+09:00</published><updated>2019-08-20T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-course/2019/08/20/boostCourse(web)-proj4-1</id><content type="html" xml:base="https://changgunyee.github.io/boost-course/2019/08/20/boostCourse(web)-proj4-1.html">&lt;p&gt;부스트 코스 proj4-1를 진행하였습니다.&lt;/p&gt;

&lt;p&gt;개발해야하는 파트는 네이버 예약 서비스의 상세 페이지의 백엔드 파트였습니다.&lt;br /&gt;
개발해야하는 기능은 상품에 대한 상세 페이지인 main view와 상품에 대한 한줄평을 볼 수 있는 comment view와 상품에 대한 displayInfo를 구할 수 있는 api를 만드는 것으로 총 3가지 였습니다.&lt;/p&gt;

&lt;h3 id=&quot;displayinfo-apiapiproductsdisplayinfoid&quot;&gt;displayInfo api(&lt;code class=&quot;highlighter-rouge&quot;&gt;/api/products/{displayInfoId}&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;displayInfo api에는 많은 정보가 들어 있습니다.&lt;br /&gt;
spring MVC에 따라 개발해야 보겠습니다. dto -&amp;gt; dao -&amp;gt; service -&amp;gt; controller&lt;br /&gt;
model(dto)을 구성해야 하므로 이에 따라 만든 model 목록입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Comment&lt;/li&gt;
  &lt;li&gt;CommentImage&lt;/li&gt;
  &lt;li&gt;DisplayInfo&lt;/li&gt;
  &lt;li&gt;DisplayInfoImage&lt;/li&gt;
  &lt;li&gt;ProductImage&lt;/li&gt;
  &lt;li&gt;ProductPrice&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용한 테이블들 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-20/erd.png&quot; style=&quot;width:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;꽤 많았습니다.(&lt;del&gt;사실 너무 많았….&lt;/del&gt;)&lt;/p&gt;

&lt;p&gt;데이터 베이스의 테이블을 이용해 위의 모델 객체를 만들 수 있게 도와주는 dao가 있어야 됩니다.&lt;br /&gt;
각 모델이 가지고 있는 속성에 따라 필요한 테이블을 join해서 모델 객체를 만들어 주어야 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DisplayInfo : public DisplayInfo selectDisplayInfo(Integer displayInfoId)&lt;/li&gt;
  &lt;li&gt;DisplayInfoImage : public DisplayInfoImage selectDisplayInfoImage(Integer displayInfoId)&lt;/li&gt;
  &lt;li&gt;Comments : public List&lt;Comment&gt; selectComments(Integer displayInfoId)&lt;/Comment&gt;&lt;/li&gt;
  &lt;li&gt;CommentImages : public List&lt;CommentImage&gt; selectCommentImages(Integer reservationUserCommentId)&lt;/CommentImage&gt;&lt;/li&gt;
  &lt;li&gt;ProductImages : public List&lt;ProductImage&gt; selectProductImages(Integer productId)&lt;/ProductImage&gt;&lt;/li&gt;
  &lt;li&gt;ProductPrices : public List&lt;ProductPrice&gt; selectProductPrices(Integer productId)&lt;/ProductPrice&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 함수들로 객체를 생성합니다. 현재 조회하는 기능만 있으면 되므로 수정, 삭제 기능을 담당하는 함수는 만들지 않았습니다.&lt;/p&gt;

&lt;p&gt;자 이제 service차례입니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Transactional&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDetailDisplayInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;displayInfoId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;displayInfo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;가져오기&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//selectDisplayInfo&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;displayInfoImage&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;가져오기&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//selectDisplayInfoImage&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;productImages&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;가져오기&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//selectProductImages&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;productPrices&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;가져오기&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//selectProductPrices&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;comments&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;가져오기&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//selectComments&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;각&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;의&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;맞는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commentImage&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;가져오기&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//selectCommentImages&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;@Transactional annotation을 사용하면 함수가 실행되거나, 중간에 문제가 생기면 아예 함수를 실행하기 전으로 rollback하게끔 도와줍니다.&lt;/p&gt;

&lt;p&gt;이번 과제 명세 중 하나가 사용자 email을 &lt;code class=&quot;highlighter-rouge&quot;&gt;dkwo****&lt;/code&gt;와 같은 형식으로 표현하는 것이였는데, 저는 프론트에서 해결하였었습니다. 하지만 리뷰어님께서 보통 많은 페이지들에서 이메일을 저런 식으로 표현해야하기 때문에 프론트마다 코드를 만들기 보다도 백엔드에서 처리해주어 처리 포인트를 1개롤 모으는 것이 보통이라고 하셨습니다. 따라서 comment마다 commentImages를 가져올 때, comment의 이메일 형식도 바꿔주는 것으로 바꾸고 프론트는 단순 출력만 하게 수정하였습니다.(또 하나 배웠습니다. 크흡…..)&lt;/p&gt;

&lt;p&gt;서버를 실행하고, postman에서 api url에 요청해본 결과입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-20/api.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;상세-페이지main-view&quot;&gt;상세 페이지(main view)&lt;/h3&gt;

&lt;p&gt;위의 displayInfo api에서 controller를 제외한 mvc모델을 다 만들어 놨기 때문에, 상세 페이지와 한줄평 페이지 view는 굉장히 간단해 졌습니다.&lt;br /&gt;
service의 getDetailDisplayInfo함수를 이용해 필요한 정보를 받아와 modelMap객체를 통해 detail.jsp에 넘겨 줍니다.&lt;br /&gt;
대략적인 코드는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/detail&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DetailController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GetMapping&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;renderDetailPage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@RequestParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;displayInfoId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;getDetailDisplayInfo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;호출&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;modelMap&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;displayInfo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;주입&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;detail&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;한줄평-페이지comment-view&quot;&gt;한줄평 페이지(comment view)&lt;/h3&gt;

&lt;p&gt;상세 페이지와 비슷합니다. getDetailDisplayInfo를 이용하면 불필요한 정보까지 받아오므로 비효율적입니다. 따라서 추가적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;getDetailComments()&lt;/code&gt;함수를 만들어 주었습니다.&lt;br /&gt;
이 데이터 또한 modelMap객체를 통해 comment.jsp에 넘겨줍니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/comment&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommentController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GetMapping&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;renderCommentPage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@RequestParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;displayInfoId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;getDetailComments&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;호출&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;modelMap&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comments&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;주입&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;comment&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;새롭게-배운-점&quot;&gt;새롭게 배운 점&lt;/h3&gt;

&lt;p&gt;spring MVC에서 view를 넣으려면 jsp파일을 만들고, controller도 만들어야 되죠.&lt;br /&gt;
원하는 url에 view하나 넣을 때마다 controller를 만들어 넣어야하는 건 굉장히 부담스러운 일입니다.&lt;br /&gt;
원하는 url에 정적인 페이지를 넣고 싶을 때는 WebMvcConfigurerAdapter클래스의 addViewControllers를 override해서 간단하게 view를 등록할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@EnableWebMvc&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ComponentScan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basePackages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;kr.or.connect.mavenweb.controller&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebMvcContextConfiguration&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configureDefaultServletHandling&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DefaultServletHandlerConfigurer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;configurer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;configurer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addViewControllers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewControllerRegistry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;registry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;addViewControllers가 호출됩니다. &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;registry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addViewController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setViewName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;index&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;사실 이 configure부분이 서버에 대한 이해도가 낮으면 굉장히 코드 한줄 한줄을 이해하기가 힘듭니다.&lt;br /&gt;
조금이라도 분석을 해봅시다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;기본적으로 설정은 DispatcherServlet이 읽어 들입니다.&lt;/li&gt;
      &lt;li&gt;url요청이 들어왔을 때, DefaultServletHttpRequestHandler가 원래 처리합니다.&lt;/li&gt;
      &lt;li&gt;위와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;configurer.enable()&lt;/code&gt;로 configurer를 허용해주면, mapping이 없는 URL요청이 들어왔을 때 DefaultServletHttpRequestHandler가 요청을 DefaultServletHandler에 넘기게 되고 DefaultServletHandler는 WAS의 static한 자원을 읽어서 보여줍니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;addViewControllers(final ViewControllerRegistry registry)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;ViewControllerRegistry객체를 이용해 특정 URL에 대한 처리를 controller없이 할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;위와 같이 registry에 &lt;code class=&quot;highlighter-rouge&quot;&gt;addViewController()&lt;/code&gt; 함수를 이용하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; URL에 index라는 view를 보여줄 수 있게됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;프로젝트 완료한 모습입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-20/complete.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;#부스트코스&lt;/p&gt;</content><author><name>이창권</name></author><summary type="html">부스트 코스 proj4-1를 진행하였습니다. 개발해야하는 파트는 네이버 예약 서비스의 상세 페이지의 백엔드 파트였습니다. 개발해야하는 기능은 상품에 대한 상세 페이지인 main view와 상품에 대한 한줄평을 볼 수 있는 comment view와 상품에 대한 displayInfo를 구할 수 있는 api를 만드는 것으로 총 3가지 였습니다. displayInfo api(/api/products/{displayInfoId}) displayInfo api에는 많은 정보가 들어 있습니다. spring MVC에 따라 개발해야 보겠습니다. dto -&amp;gt; dao -&amp;gt; service -&amp;gt; controller model(dto)을 구성해야 하므로 이에 따라 만든 model 목록입니다. Comment CommentImage DisplayInfo DisplayInfoImage ProductImage ProductPrice 사용한 테이블들 입니다. 꽤 많았습니다.(사실 너무 많았….) 데이터 베이스의 테이블을 이용해 위의 모델 객체를 만들 수 있게 도와주는 dao가 있어야 됩니다. 각 모델이 가지고 있는 속성에 따라 필요한 테이블을 join해서 모델 객체를 만들어 주어야 합니다. DisplayInfo : public DisplayInfo selectDisplayInfo(Integer displayInfoId) DisplayInfoImage : public DisplayInfoImage selectDisplayInfoImage(Integer displayInfoId) Comments : public List selectComments(Integer displayInfoId) CommentImages : public List selectCommentImages(Integer reservationUserCommentId) ProductImages : public List selectProductImages(Integer productId) ProductPrices : public List selectProductPrices(Integer productId) 위의 함수들로 객체를 생성합니다. 현재 조회하는 기능만 있으면 되므로 수정, 삭제 기능을 담당하는 함수는 만들지 않았습니다. 자 이제 service차례입니다. @Override @Transactional public Map&amp;lt;String, Object&amp;gt; getDetailDisplayInfo(Integer displayInfoId) { displayInfo가져오기//selectDisplayInfo displayInfoImage가져오기//selectDisplayInfoImage productImages가져오기//selectProductImages productPrices가져오기//selectProductPrices comments가져오기//selectComments 각 comment의 id에 맞는 commentImage가져오기//selectCommentImages } @Transactional annotation을 사용하면 함수가 실행되거나, 중간에 문제가 생기면 아예 함수를 실행하기 전으로 rollback하게끔 도와줍니다. 이번 과제 명세 중 하나가 사용자 email을 dkwo****와 같은 형식으로 표현하는 것이였는데, 저는 프론트에서 해결하였었습니다. 하지만 리뷰어님께서 보통 많은 페이지들에서 이메일을 저런 식으로 표현해야하기 때문에 프론트마다 코드를 만들기 보다도 백엔드에서 처리해주어 처리 포인트를 1개롤 모으는 것이 보통이라고 하셨습니다. 따라서 comment마다 commentImages를 가져올 때, comment의 이메일 형식도 바꿔주는 것으로 바꾸고 프론트는 단순 출력만 하게 수정하였습니다.(또 하나 배웠습니다. 크흡…..) 서버를 실행하고, postman에서 api url에 요청해본 결과입니다. 상세 페이지(main view) 위의 displayInfo api에서 controller를 제외한 mvc모델을 다 만들어 놨기 때문에, 상세 페이지와 한줄평 페이지 view는 굉장히 간단해 졌습니다. service의 getDetailDisplayInfo함수를 이용해 필요한 정보를 받아와 modelMap객체를 통해 detail.jsp에 넘겨 줍니다. 대략적인 코드는 다음과 같습니다. @Controller @RequestMapping(path = &quot;/detail&quot;) public class DetailController { @GetMapping public String renderDetailPage(@RequestParam(name = &quot;id&quot;) int displayInfoId, ModelMap modelMap) { getDetailDisplayInfo호출 modelMap에 displayInfo주입 return &quot;detail&quot;; } } 한줄평 페이지(comment view) 상세 페이지와 비슷합니다. getDetailDisplayInfo를 이용하면 불필요한 정보까지 받아오므로 비효율적입니다. 따라서 추가적으로 getDetailComments()함수를 만들어 주었습니다. 이 데이터 또한 modelMap객체를 통해 comment.jsp에 넘겨줍니다. @Controller @RequestMapping(path = &quot;/comment&quot;) public class CommentController { @GetMapping public String renderCommentPage(@RequestParam(name = &quot;id&quot;) int displayInfoId, ModelMap modelMap) { getDetailComments호출 modelMap에 comments주입 return &quot;comment&quot;; } } 새롭게 배운 점 spring MVC에서 view를 넣으려면 jsp파일을 만들고, controller도 만들어야 되죠. 원하는 url에 view하나 넣을 때마다 controller를 만들어 넣어야하는 건 굉장히 부담스러운 일입니다. 원하는 url에 정적인 페이지를 넣고 싶을 때는 WebMvcConfigurerAdapter클래스의 addViewControllers를 override해서 간단하게 view를 등록할 수 있습니다. @Configuration @EnableWebMvc @ComponentScan(basePackages = {&quot;kr.or.connect.mavenweb.controller&quot;}) public class WebMvcContextConfiguration extends WebMvcConfigurerAdapter { @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } @Override public void addViewControllers(final ViewControllerRegistry registry) { System.out.println(&quot;addViewControllers가 호출됩니다. &quot;); registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); } } 사실 이 configure부분이 서버에 대한 이해도가 낮으면 굉장히 코드 한줄 한줄을 이해하기가 힘듭니다. 조금이라도 분석을 해봅시다. configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) 기본적으로 설정은 DispatcherServlet이 읽어 들입니다. url요청이 들어왔을 때, DefaultServletHttpRequestHandler가 원래 처리합니다. 위와 같이 configurer.enable()로 configurer를 허용해주면, mapping이 없는 URL요청이 들어왔을 때 DefaultServletHttpRequestHandler가 요청을 DefaultServletHandler에 넘기게 되고 DefaultServletHandler는 WAS의 static한 자원을 읽어서 보여줍니다. addViewControllers(final ViewControllerRegistry registry) ViewControllerRegistry객체를 이용해 특정 URL에 대한 처리를 controller없이 할 수 있습니다. 위와 같이 registry에 addViewController() 함수를 이용하면 / URL에 index라는 view를 보여줄 수 있게됩니다. 프로젝트 완료한 모습입니다. #부스트코스</summary></entry><entry><title type="html">부스트 코스(웹) PROJ3-2</title><link href="https://changgunyee.github.io/boost-course/2019/08/12/boostCourse(web)-proj3-2.html" rel="alternate" type="text/html" title="부스트 코스(웹) PROJ3-2" /><published>2019-08-12T00:00:00+09:00</published><updated>2019-08-12T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-course/2019/08/12/boostCourse(web)-proj3-2</id><content type="html" xml:base="https://changgunyee.github.io/boost-course/2019/08/12/boostCourse(web)-proj3-2.html">&lt;p&gt;부스트 코스 proj3-2를 진행하였습니다.&lt;/p&gt;

&lt;p&gt;proj3-1이 예약 서비스의 백엔드 파트였다면, 이번 프로젝트는 네이버 예약 서비스 메인 페이지의 프론트 엔드 부분을 개발하였습니다.&lt;/p&gt;

&lt;p&gt;개발해야하는 기능은 크게 3가지였습니다.&lt;/p&gt;

&lt;h3 id=&quot;프로모션-영역슬라이딩-이미지&quot;&gt;프로모션 영역(슬라이딩 이미지)&lt;/h3&gt;

&lt;p&gt;세부 주요 기준으로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로모션영역의 이미지는 1개보다 많으며, 자동으로 슬라이딩되어 넘어간다.&lt;/li&gt;
  &lt;li&gt;슬라이딩 이미지는 애니메이션이 되면서 좌측으로 이동하는 것이 보여야한다.&lt;/li&gt;
  &lt;li&gt;마지막 이미지에 다다르면 처음것이 그 다음으로 노출되야 한다. 마지막것에서 처음내용이 다시 보이는 부분은 끊겨서 노출되도 상관 없으며, 중요한 건 다시 처음부터 슬라이딩이 계속 되야 한다는 것이다. (엄격하진 않지만 최대한 자연스럽게 동작하려고 해야 한다)&lt;/li&gt;
  &lt;li&gt;상단영역의 애니메이션은 CSS3의 transition과 transform 속성을 JavaScript로 제어하면서 구현해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사실 jQuery에 슬라이더 플러그인이 굉장히 많이 있죠&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Draggable Dual-View Slideshow&lt;/li&gt;
  &lt;li&gt;Swiper&lt;/li&gt;
  &lt;li&gt;slick&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;플러그인이나 라이브러리를 가져다 쓰는 것도 좋지만, javascript와 css에 익숙해지는데 라이브러리를 실제 구현해 보는 것만큼 좋은 것도 없다고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;카테고리노출영역탭ui&quot;&gt;카테고리노출영역(탭UI)&lt;/h3&gt;

&lt;p&gt;세부 주요 기준으로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전체리스트가 Ajax를 통해서 화면에 4개의 아이템이 노출된다.&lt;/li&gt;
  &lt;li&gt;탭별로 전체갯수가 상단에 노출되야 한다.&lt;/li&gt;
  &lt;li&gt;각 아이템(전시상품)은 이미지/제목/장소/설명이 노출되야 한다.&lt;/li&gt;
  &lt;li&gt;탭을 누르면 다른 카테고리 콘텐츠 4개가 다시 노출된다.&lt;/li&gt;
  &lt;li&gt;더보기를 누르면 4개씩 노출되야 한다. 4개보다 적으면 적은 만큼 노출되야 한다.&lt;/li&gt;
  &lt;li&gt;더보여줄 데이터가 없다면 더보기는 사라진다.&lt;/li&gt;
  &lt;li&gt;카테고리 탭을 선택할 때마다, Ajax요청을 해서 데이터를 가져와야 한다.&lt;/li&gt;
  &lt;li&gt;탭메뉴 (전시/뮤지컬/콘서트 등)는 Event delegation으로 구현한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세부 기준 중, 첫번째 중요한 부분은 &lt;code class=&quot;highlighter-rouge&quot;&gt;카테고리 탭을 선택할 때마다, Ajax요청을 해서 테이터를 가져와야 한다.&lt;/code&gt;는 부분입니다.&lt;/p&gt;

&lt;p&gt;브라우저의 새로고침 없이 데이터를 얻어오는 더 좋은 UX를 제공하는 방법으로 비동기(ajax)를 통해 필요한 부분만(페이지의 일부분)을 새로 렌더링하는 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;Ajax사용법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Vanillar JS&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oReq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            
      &lt;span class=&quot;nx&quot;&gt;oReq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;responseText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
            
      &lt;span class=&quot;nx&quot;&gt;oReq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://www.example.org/example.txt&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;oReq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jQuery&lt;/p&gt;

    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;loldog&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Axios(최근 가장 많이 쓰는 형태)&lt;/p&gt;

    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;axios&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;http://www.example.org/example.txt&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사실 이 중, axios와  async, await 결합해서 가장 많이 씁니다.&lt;/p&gt;

&lt;p&gt;비동기적인 코드를 동기적인 코드로 쓸 수 있어 개발 속도도 굉장히 빠르고 가독성도 좋기 때문입니다.&lt;/p&gt;

&lt;p&gt;그래도 배우는 시간인 만큼 XMLHttpRequest객체를 이용해서 개발을 진행하였습니다.&lt;/p&gt;

&lt;p&gt;세부 기준중, 두번재로 중요한 부분은 &lt;code class=&quot;highlighter-rouge&quot;&gt;탭메뉴 (전시/뮤지컬/콘서트 등)는 Event delegation으로 구현한다.&lt;/code&gt;입니다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;https://images-na.,,,,,/513hgbYgL._AC_SY400_.jpg&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;product-image&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/li&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;https://images-n,,,,,/41HoczB2L._AC_SY400_.jpg&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;product-image&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/li&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;https://images-na.,,,,51AEisFiL._AC_SY400_.jpg&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;product-image&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/li&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;https://images-na,,,,/51JVpV3ZL._AC_SY400_.jpg&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;product-image&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/li&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/ul&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 위와 같은 &amp;lt;li&amp;gt;태그 하나하나에 이벤트를 걸여야 한다면 어떨까요? 심지어 &amp;lt;li&amp;gt;가 100개로 늘어난다면? 동적으로 &amp;lt;li&amp;gt;를 만들어 줘야하는 상황이라면?&lt;/p&gt;

&lt;p&gt;매번 이벤트를 걸어줘야 한다면 브라우저도 감당하기 힘들뿐더러, 코드도 굉장히 비효율적일 것입니다.&lt;/p&gt;

&lt;p&gt;하지만 &amp;lt;ul&amp;gt;태그 하나에만 이벤트를 걸어주고 &lt;code class=&quot;highlighter-rouge&quot;&gt;event bubbling&lt;/code&gt;을 사용하면 단번에 해결 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;ul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드를 실행시킨 다음 &amp;lt;img&amp;gt;,&amp;lt;li&amp;gt;를 클릭해도 이벤트가 실행됩니다.&lt;/p&gt;

&lt;p&gt;&amp;lt;img&amp;gt;,&amp;lt;li&amp;gt;태그 모두 &amp;lt;ul&amp;gt;에 속하는 태그이기도 하기 때문입니다.&lt;/p&gt;

&lt;p&gt;이것을 이벤트 버블링이라고 합니다.&lt;/p&gt;

&lt;p&gt;클릭한 지점이 하위엘리먼트라고 하여도, 그것을 감싸고 있는 상위 엘리먼트까지 올라가면서 이벤트리스너가 있는지 찾는 과정입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-12/event_bubbling.jpg&quot; style=&quot;width:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 이용한다면 예약 서비스의 탭메뉴 하나하나에 이벤트를 걸어주지 않아도 상위 태그 하나에만 이벤트를 걸어주는 형식으로 처리가 가능합니다.&lt;/p&gt;

&lt;h3 id=&quot;html-templating&quot;&gt;HTML templating&lt;/h3&gt;

&lt;p&gt;사실 이부분 개발을 어떻게 해야하나? jsp를 배운김에 jsp를 써야하나? 그냥 javascript로 구현을 해야하나? 고민 끝에 그냥 javascript로 구현하기로 하였습니다.&lt;/p&gt;

&lt;p&gt;물론 아직까지 jsp로 개발된 사이트들이 많지만, 최근에 javascript를 이용한 프레임워크(React, Vue)등이 인기가 많아지기도 하였고 template언어의 인기가 떡락하고 있기 때문에 그냥 javascript로 하였습니다.&lt;/p&gt;

&lt;p&gt;저의 경우에는 node.js의 template언어인 ejs를 써봤었는데, 너무 옛날 언어 같다는 느낌을 많이 받은 것도 영향이 있었던 것 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;rv-template&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;itemList&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;href&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/htmls/detail.html?id=${id}&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;item_book&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//response data에서 id를 받아 replace함수를 통해 ${id}를 교체&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/li&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;html파일 내에 위와같이 script형태로 template을 보관한 후, ajax를 통해 받은 response data를 해당 template에 렌더링하는 형식으로 구현하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-08-12/review_result.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;끝입니다.~~~~~~~&lt;/p&gt;</content><author><name>이창권</name></author><summary type="html">부스트 코스 proj3-2를 진행하였습니다. proj3-1이 예약 서비스의 백엔드 파트였다면, 이번 프로젝트는 네이버 예약 서비스 메인 페이지의 프론트 엔드 부분을 개발하였습니다. 개발해야하는 기능은 크게 3가지였습니다. 프로모션 영역(슬라이딩 이미지) 세부 주요 기준으로 프로모션영역의 이미지는 1개보다 많으며, 자동으로 슬라이딩되어 넘어간다. 슬라이딩 이미지는 애니메이션이 되면서 좌측으로 이동하는 것이 보여야한다. 마지막 이미지에 다다르면 처음것이 그 다음으로 노출되야 한다. 마지막것에서 처음내용이 다시 보이는 부분은 끊겨서 노출되도 상관 없으며, 중요한 건 다시 처음부터 슬라이딩이 계속 되야 한다는 것이다. (엄격하진 않지만 최대한 자연스럽게 동작하려고 해야 한다) 상단영역의 애니메이션은 CSS3의 transition과 transform 속성을 JavaScript로 제어하면서 구현해야 한다. 사실 jQuery에 슬라이더 플러그인이 굉장히 많이 있죠 Draggable Dual-View Slideshow Swiper slick 플러그인이나 라이브러리를 가져다 쓰는 것도 좋지만, javascript와 css에 익숙해지는데 라이브러리를 실제 구현해 보는 것만큼 좋은 것도 없다고 생각합니다. 카테고리노출영역(탭UI) 세부 주요 기준으로 전체리스트가 Ajax를 통해서 화면에 4개의 아이템이 노출된다. 탭별로 전체갯수가 상단에 노출되야 한다. 각 아이템(전시상품)은 이미지/제목/장소/설명이 노출되야 한다. 탭을 누르면 다른 카테고리 콘텐츠 4개가 다시 노출된다. 더보기를 누르면 4개씩 노출되야 한다. 4개보다 적으면 적은 만큼 노출되야 한다. 더보여줄 데이터가 없다면 더보기는 사라진다. 카테고리 탭을 선택할 때마다, Ajax요청을 해서 데이터를 가져와야 한다. 탭메뉴 (전시/뮤지컬/콘서트 등)는 Event delegation으로 구현한다. 세부 기준 중, 첫번째 중요한 부분은 카테고리 탭을 선택할 때마다, Ajax요청을 해서 테이터를 가져와야 한다.는 부분입니다. 브라우저의 새로고침 없이 데이터를 얻어오는 더 좋은 UX를 제공하는 방법으로 비동기(ajax)를 통해 필요한 부분만(페이지의 일부분)을 새로 렌더링하는 방법이 있습니다. Ajax사용법 Vanillar JS function ajax() { var oReq = new XMLHttpRequest(); oReq.addEventListener(&quot;load&quot;, function() { console.log(this.responseText); }); oReq.open(&quot;GET&quot;, &quot;http://www.example.org/example.txt&quot;); oReq.send(); } jQuery function ajax(){ $.post('loldog',(response)=&amp;gt;{ console.log(response); } } Axios(최근 가장 많이 쓰는 형태) async function ajax(){ var response=await axios.get('http://www.example.org/example.txt') console.log(response); } 사실 이 중, axios와 async, await 결합해서 가장 많이 씁니다. 비동기적인 코드를 동기적인 코드로 쓸 수 있어 개발 속도도 굉장히 빠르고 가독성도 좋기 때문입니다. 그래도 배우는 시간인 만큼 XMLHttpRequest객체를 이용해서 개발을 진행하였습니다. 세부 기준중, 두번재로 중요한 부분은 탭메뉴 (전시/뮤지컬/콘서트 등)는 Event delegation으로 구현한다.입니다. &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;img src=&quot;https://images-na.,,,,,/513hgbYgL._AC_SY400_.jpg&quot; class=&quot;product-image&quot; &amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;img src=&quot;https://images-n,,,,,/41HoczB2L._AC_SY400_.jpg&quot; class=&quot;product-image&quot; &amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;img src=&quot;https://images-na.,,,,51AEisFiL._AC_SY400_.jpg&quot; class=&quot;product-image&quot; &amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;img src=&quot;https://images-na,,,,/51JVpV3ZL._AC_SY400_.jpg&quot; class=&quot;product-image&quot; &amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 만약 위와 같은 &amp;lt;li&amp;gt;태그 하나하나에 이벤트를 걸여야 한다면 어떨까요? 심지어 &amp;lt;li&amp;gt;가 100개로 늘어난다면? 동적으로 &amp;lt;li&amp;gt;를 만들어 줘야하는 상황이라면? 매번 이벤트를 걸어줘야 한다면 브라우저도 감당하기 힘들뿐더러, 코드도 굉장히 비효율적일 것입니다. 하지만 &amp;lt;ul&amp;gt;태그 하나에만 이벤트를 걸어주고 event bubbling을 사용하면 단번에 해결 가능합니다. ul.addEventListener(&quot;click&quot;,function(evt) { console.log(evt.currentTarget, evt.target); }); 위의 코드를 실행시킨 다음 &amp;lt;img&amp;gt;,&amp;lt;li&amp;gt;를 클릭해도 이벤트가 실행됩니다. &amp;lt;img&amp;gt;,&amp;lt;li&amp;gt;태그 모두 &amp;lt;ul&amp;gt;에 속하는 태그이기도 하기 때문입니다. 이것을 이벤트 버블링이라고 합니다. 클릭한 지점이 하위엘리먼트라고 하여도, 그것을 감싸고 있는 상위 엘리먼트까지 올라가면서 이벤트리스너가 있는지 찾는 과정입니다. 이를 이용한다면 예약 서비스의 탭메뉴 하나하나에 이벤트를 걸어주지 않아도 상위 태그 하나에만 이벤트를 걸어주는 형식으로 처리가 가능합니다. HTML templating 사실 이부분 개발을 어떻게 해야하나? jsp를 배운김에 jsp를 써야하나? 그냥 javascript로 구현을 해야하나? 고민 끝에 그냥 javascript로 구현하기로 하였습니다. 물론 아직까지 jsp로 개발된 사이트들이 많지만, 최근에 javascript를 이용한 프레임워크(React, Vue)등이 인기가 많아지기도 하였고 template언어의 인기가 떡락하고 있기 때문에 그냥 javascript로 하였습니다. 저의 경우에는 node.js의 template언어인 ejs를 써봤었는데, 너무 옛날 언어 같다는 느낌을 많이 받은 것도 영향이 있었던 것 같습니다. &amp;lt;script type=&quot;rv-template&quot; id=&quot;itemList&quot;&amp;gt; &amp;lt;li class=&quot;item&quot;&amp;gt; &amp;lt;a href=&quot;/htmls/detail.html?id=${id}&quot; class=&quot;item_book&quot;&amp;gt;//response data에서 id를 받아 replace함수를 통해 ${id}를 교체 &amp;lt;/li&amp;gt; &amp;lt;/script&amp;gt; html파일 내에 위와같이 script형태로 template을 보관한 후, ajax를 통해 받은 response data를 해당 template에 렌더링하는 형식으로 구현하였습니다. 끝입니다.~~~~~~~</summary></entry><entry><title type="html">부스트 캠프 Day16</title><link href="https://changgunyee.github.io/boost-camp/2019/08/08/boostCamp-Day16.html" rel="alternate" type="text/html" title="부스트 캠프 Day16" /><published>2019-08-08T00:00:00+09:00</published><updated>2019-08-08T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/08/08/boostCamp-Day16</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/08/08/boostCamp-Day16.html">&lt;h1 id=&quot;text-browser&quot;&gt;Text Browser&lt;/h1&gt;

&lt;p&gt;URI/URL 표준 규격을 학습하고, URL 문자열을 분석해서 처리하는 라이브러리를 직접 구현하여 보자&lt;/p&gt;

&lt;h2 id=&quot;1-코드-동작-이해&quot;&gt;1. 코드 동작 이해&lt;/h2&gt;
&lt;p&gt;url string이 주어졌을 때, 이를 요소별로 나누어 주는 Parsing URL class를 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정규표현식을 이용하여 검사와 URL 분석을 수행한다.&lt;/li&gt;
  &lt;li&gt;mocha 라이브러리를 사용하여 테스트 케이스를 작성하고 TDD를 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;describe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://user_name:pass-word@boostcamp.connect-foundation.or.kr:2019/first/second/last?query=ab&amp;amp;param=12&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;equal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;boostcamp.connect-foundation.or.kr&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;lastPathComponent&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;equal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lastPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;pathComponents&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deepEqual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pathComponents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;equal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2019&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;equal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;query=ab&amp;amp;param=12&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;XMLHttpRequest 객체의 역할을 하는 HttpRequest class를 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;입력받은 URL에서 필요한 부분들을 this 객체에 저장한다.&lt;/li&gt;
  &lt;li&gt;사용자에게 입력받을 option과 default 옵션을 구현한다.&lt;/li&gt;
  &lt;li&gt;net과 dns 모듈을 사용하여 생성자에서 결과를 저장할 수 있도록 설정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;connected to server!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`GET / HTTP/1.1`&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`\r\nAccept: text/html`&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`\r\nHost: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`\r\nUser-Agent: Mozilla/5.0\r\n\r\n`&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;XMLHttpResponse 객체의 역할을 하는 HttpResponse class를 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HttpRequest객체를 사용해서 서버로부터 받은 데이터를 HttpResponse에서 처리해준다.&lt;/li&gt;
  &lt;li&gt;Buffer형태로 데이터를 받기 때문에 Buffer객체를 사용해서 처리한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HTTPResponse&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;statusCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;responseLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;contentLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HTTPResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;socket 통신 방법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;url string이 주어졌을 때, URL class를 이용하여 분석을 해 요소로 나눈다.&lt;/li&gt;
  &lt;li&gt;URL객체의 host를 받아 dns module을 이용해서 ip를 받는다.&lt;/li&gt;
  &lt;li&gt;node의 net module을 이용해서, client를 만들고 socket을 만들어 HttpRequest 객체를 생성해 서버로 전달해준다.&lt;/li&gt;
  &lt;li&gt;서버에서 받은 데이터를 parsing해 HttpResponse객체를 만들어 콘솔에 출력해 준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTPResponse {
header:
'HTTP/1.1 200 \r\nServer: nginx/1.6.0\r\nDate: Fri, 09 Aug 2019 01:53:51 GMT\r\nContent-Type: text/html;charset=UTF-8\r\nContent-Length: 128302\r\nConnection: keep-alive\r\nKeep-Alive: timeout=5\r\nVary: Accept-Encoding\r\nX-Application-Context: application:set1:8081\r\nCache-Control: no-store\r\nSet-Cookie: _TUID=247D3ABD-F06E-4F68-B615-132B81F5126F; Expires=Mon, 06-Aug-2029 01:53:51 GMT; Path=/\r\nSet-Cookie: _ZUT=nc%3D82c11590530; Domain=.zum.com; Path=/\r\nSet-Cookie: czi=&quot;&quot;; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Path=/\r\nSet-Cookie: bakeryStamp=1; Expires=Mon, 06-Aug-2029 01:53:51 GMT; Path=/\r\nSet-Cookie: p=0; Path=/\r\n\r\n',
body:
&amp;lt;Buffer 3c 21 44 4f 43 54 59 50 45 20 42 4f 44 59 3e 0a 3c 68 74 6d 6c 20 6c 61 6e 67 3d 22 6b 6f 22 20 63 6c 61 73 73 3d 22 22 3e 0a 3c 68 65 61 64 3e 0a 3c ... &amp;gt;,
statusCode: 200,
responseLine: 'HTTP/1.1 200',
contentLength: 128302 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-코드-동작-개선&quot;&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;p&gt;response를 받을 때의 data를 stream을 사용해서 받아야 한다. content-length를 비교할 때, string으로 바꾸면 데이터의 손실이 일어나기 때문에 stream을 사용해서 받아야 한다.&lt;br /&gt;&lt;br /&gt;
url class 객체 예외 처리시 test 코드를 구성해서 test하면 효율적이다.&lt;/p&gt;

&lt;h2 id=&quot;3-consideration&quot;&gt;3. Consideration&lt;/h2&gt;
&lt;h3 id=&quot;스스로-확인할-사항&quot;&gt;스스로 확인할 사항&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;URL 구성 요소에 대해 학습한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;스킴&amp;gt;://&amp;lt;사용자이름&amp;gt;:&amp;lt;비밀번호&amp;gt;@&amp;lt;호스트&amp;gt;:&amp;lt;포트&amp;gt;/&amp;lt;경로&amp;gt;?&amp;lt;질의&amp;gt;#&amp;lt;프레그먼트&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;스킴&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용할 프로토콜을 말하며, 리소스에 어떻게 요청, 접근할 것인지를 명시한다. 웹에서는 주로 HTTP 프로토콜을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용자 이름과 비밀번호&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 서버들은 자신이 가지고 있는 데이터에 접근하기 위해서 사용자의 이름과 비밀번호를 요구한다.&lt;/li&gt;
  &lt;li&gt;만약 웹 서버에서 사용자이름과 비밀번호를 요구하는 URL 스킴을 사용함에도 클라이언트가 이를 명시하지 않고 URL에 접근한다면, 기본값으로 “사용자 이름 : anonumous , 비밀번호는 브라우저에서 제공하는 기본 값”을 따르게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;호스트와 포트&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하나의 Host( 컴퓨터 )에는 여러 개의 Process( 프로그램 )이 각각의 Socket( 소켓 )을 사용하여 데이터 통신을 하고 있기 때문에, 각각의 소켓을 구분할 필요가 있습니다. 이 때 소켓을 구분하는 역할을 하는 것이 Port( 포트 )이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;경로&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호스트에서 제공하는 자원의 경로를 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;질의&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Query String( 쿼리 스트링 )이라고도 한다.&lt;/li&gt;
  &lt;li&gt;클라이언트가 자원을 GET 방식으로 요청할 때, 필요한 데이터를 함께 넘겨 줄 목적으로 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프래그먼트&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTML에는 각각의 요소에 id 속성을 부여할 수 있는데, URL에 프래그먼트를 전달하면 페이지가 해당 id가 있는 곳으로 스크롤이 이동하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;다양한 URL 케이스를 어떻게 처리하는지 확인한 방법을 정리한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP(URI)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스키마, 도메인, 포트, 경로, 쿼리, 프래그먼트로 구성되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FILE&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;URL과는 달리 보통 절대 경로명을 써주는데 ‘://’ 다음에 ‘/’로 시작한다. ‘/dir1/dir2/file’은 자신의 컴퓨터에 있는 ‘dir1\dir2'에 있는 file이라는 파일을 나타낸다. 호스트 주소를 적어주게 되면 FTP 서비스로 동작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FTP&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Anonymouse FTP 서버에서 파일을 지정할 때 사용한다.&lt;/li&gt;
  &lt;li&gt;ftp://로 시작한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Telnet&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;텔넷도 ftp와 비슷하며 통신을할 때 주로 쓰인다.&lt;/li&gt;
  &lt;li&gt;telnet://로 시작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;TTP Request 종류와 HTTP Response 종류에 대해 학습하고 정리한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP Request정보&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;요청 URL 정보(method, URL HTTP버전)&lt;/li&gt;
  &lt;li&gt;사용자 웹 브라우져 종류&lt;/li&gt;
  &lt;li&gt;요청 데이터 타입 (응답의 Content-type과 유사)&lt;/li&gt;
  &lt;li&gt;쿠키(인증 정보)&lt;/li&gt;
  &lt;li&gt;경유지 URL&lt;/li&gt;
  &lt;li&gt;요청 도메인&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;/index.html&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;User-Agent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;MSIE 6.0; Window NT 5.0&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test/html&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Cookie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;name=value&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Refere&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http://abc.com&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;www.abc.com&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HTTP Request 종류&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GET : 요청받은 URI의 정보를 검색하여 응답한다.&lt;/li&gt;
  &lt;li&gt;HEAD : GET방식과 동일하지만, 응답에 BODY가 없고 응답코드와 HEAD만 응답한다.
웹서버 정보확인, 헬스체크, 버젼확인, 최종 수정일자 확인등의 용도로 사용된다.&lt;/li&gt;
  &lt;li&gt;POST : 요청된 자원을 생성(CREATE)한다. 새로 작성된 리소스인 경우 HTTP헤더 항목 Location : URI주소를 포함하여 응답.&lt;/li&gt;
  &lt;li&gt;PUT : 요청된 자원을 수정(UPDATE)한다. 내용 갱신을 위주로 Location : URI를 보내지 않아도 된다. 클라이언트측은 요청된 URI를 그대로 사용하는 것으로 간주함.&lt;/li&gt;
  &lt;li&gt;PATCH : PUT과 유사하게 요청된 자원을 수정(UPDATE)할 때 사용한다. PUT의 경우 자원 전체를 갱신하는 의미지만, PATCH는 해당자원의 일부를 교체하는 의미로 사용.&lt;/li&gt;
  &lt;li&gt;DELETE : 요청된 자원을 삭제할 것을 요청함.  (안전성 문제로 대부분의 서버에서 비활성)&lt;/li&gt;
  &lt;li&gt;CONNECT : 동적으로 터널 모드를 교환, 프락시 기능을 요청시 사용&lt;/li&gt;
  &lt;li&gt;TRACE : 원격지 서버에 루프백 메시지 호출하기 위해 테스트용으로 사용&lt;/li&gt;
  &lt;li&gt;OPTIONS : 웹서버에서 지원되는 메소드의 종류를 확인할 경우 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTP Response 정보&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로토콜 버젼 및 응답코드&lt;/li&gt;
  &lt;li&gt;웹 서버 정보&lt;/li&gt;
  &lt;li&gt;MIME 타입&lt;/li&gt;
  &lt;li&gt;HTTP BODY 사이즈&lt;/li&gt;
  &lt;li&gt;HTTP BODY 컨텐츠&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;OK&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Apache&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Content-type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;text/html&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Content-length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;1593&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;.....&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HTTP Response 종류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/8tk1YRv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;다같이-확인할-사항&quot;&gt;다같이 확인할 사항&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;웹 브라우저가 동작하는 과정을 개발자 화면에서 확인하고 학습한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;웹 브라우저는 GET 요청을 받았을 때 해당 사이트 한 군대에만 요청을 보내는 것이 아니라, 해당 페이지에서 필요한 모든 리소스들에게 요청들을 보내게 된다.&lt;br /&gt;
요청마다 아래와 같은 각기 다른 request와 response를 받는다.&lt;br /&gt;
또한 브라우저에서 페이지 변동 없이, 간단한 조작에도 다양한 request를 보내는 것을 확인할 수 있다.&lt;br /&gt;
개발자 도구의 Network 탭에서 아래와 같은 화면을 확인할 수 있다.&lt;br /&gt;
각 요청마다 클릭 시 Header, Response, Cookies 등을 확인할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tmMSMHO.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;리눅스/유닉스 환경에서 wget 이나 curl 명령 사용방식에 대해 학습한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;wget : 웹 서버로부터 콘텐츠를 가져오는 프로그램.&lt;br /&gt;
curl : 다양한 프로토콜을 이용하여 데이터를 전송하기 위한 명령 줄 도구를 제공하는 프로젝트.&lt;br /&gt;
공통점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;FTP, HTT, HTTPS 로 자료를 전송할 수 있다.&lt;/li&gt;
  &lt;li&gt;HTTP POST 요청을 보낼 수 있다.&lt;/li&gt;
  &lt;li&gt;HTTP 쿠키를 지원한다.&lt;/li&gt;
  &lt;li&gt;스크립트처럼 사용자와 상호작용없이 작동한다.&lt;/li&gt;
  &lt;li&gt;오픈소스이며 무료다.&lt;/li&gt;
  &lt;li&gt;메타링크를 지원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;차이점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;curl
    &lt;ul&gt;
      &lt;li&gt;라이브러리가 존재한다.&lt;/li&gt;
      &lt;li&gt;사용자가 지정한 url만 전송한다.&lt;/li&gt;
      &lt;li&gt;더 다양한 프로토콜을 지원한다.&lt;/li&gt;
      &lt;li&gt;자동압축해제를 지원한다.&lt;/li&gt;
      &lt;li&gt;HTTP/2를 지원한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wget
    &lt;ul&gt;
      &lt;li&gt;라이브러리가 없다.&lt;/li&gt;
      &lt;li&gt;디렉토리 구조와 파일을 그대로 복사해온다.&lt;/li&gt;
      &lt;li&gt;GNU 프로젝트의 일부이다.&lt;/li&gt;
      &lt;li&gt;큰 옵션없이 URL을 받을 수 있다.&lt;/li&gt;
      &lt;li&gt;Public Suffix List를 활용한다.&lt;/li&gt;
      &lt;li&gt;proxy에 기본 인증을 지원한다.
사용법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Wget https://ko.wikipedia.org/wiki/Wget
# example.com의 &quot;index.html&quot; 제목 페이지를
# 파일로 내려받기
wget http://www.example.com/
# GNU FTP 사이트로부터 Wget의 소스 코드 내려받기.
wget ftp://ftp.gnu.org/pub/gnu/wget/wget-latest.tar.gz
더 복잡한 예로는 여러 URL을 하나의 디렉터리 계층으로 자동 다운로드하는 방법이 있다.

# Download *.gif from a website
# (globbing, like &quot;wget http://www.server.com/dir/*.gif&quot;, only works with ftp)
wget -e robots=off -r -l1 --no-parent -A.gif ftp://www.example.com/dir/
# Download the title page of example.com, along with
# the images and style sheets needed to display the page, and convert the
# URLs inside it to refer to locally available content.
wget -p -k http://www.example.com/
# Download the entire contents of example.com
wget -r -l 0 http://www.example.com/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cURL https://www.lesstif.com/pages/viewpage.action?pageId=14745703
# 다운로드 받은 파일을 콘솔로 출력
curl http://www.gnu.org/software/bash/manual/html_node/index.html
# 지정한 이름으로 저장
curl -o index.html http://www.gnu.org/software/bash/manual/html_node/index.html
# 서버의 filename 으로 저장
curl -O  http://www.gnu.org/software/bash/manual/html_node/index.html
# 여러 url 에서 동시에 다운로드
curl -O  http://www.gnu.org/software/bash/manual/html_node/index.html -O http://www.gnu.org/savannah-checkouts/gnu/libiconv/documentation/libiconv-1.13/iconv.1.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;https://m.blog.naver.com/PostView.nhn?blogId=alkydes&amp;amp;logNo=220593597738&amp;amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;브라우저가 처리하는 과정을 WireShark 같은 네트워크 패킷 분석 도구를 통해서 확인한다.&lt;/strong&gt;
미션 중에 수행한 zum.com에 reqeust한 패킷을 확인해본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wdEpyMp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WireShark 도구가 동작하는 원리에 대해 학습한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;wireshark의 패킷 캡쳐 원리는 패킷 스니핑이다. &lt;br /&gt;&lt;br /&gt;
상대방들의 패킷 교환을 엿듣는것을 의미한다. 쉽게말해 네트워크 트래픽을 도청하는 과정을 스니핑이라고 할 수 있다. 흔히 인디게임들이 사용하는 방식으로써 게임에서는 PlayerPrefs 의 정보나 Json 및 Xml 파싱정보를 서버에 POST로 날리는 방식으로 구현하는데 이때 각종 스니퍼로 해당 패킷을 캡쳐후 분석 - 가짜 수정 데이터를 서버에 다시한번 전송하는것으로 가짜기록을 서버에 덮어쓰기 하는 방식이다.&lt;/p&gt;

&lt;!--

# Day16 Text Browser


## 왜 필요한가?
URI/URL 규격과 HTTP 프로토콜 규격을 이해하면 웹 브라우저가 동작하는 방식을 이해하는 데 도움이 된다. 실제로 웹 브라우저 주소창에 주소를 입력한 순간부터 웹 서버를 찾아서 요청을 보내고 응답을 받아서 화면에 표시하기까지 흐름을 이해하는 게 중요하다.

## 학습 목표
- URI/URL 표준 규격을 학습하고, URL 문자열을 분석해서 처리하는 라이브러리를 직접 구현하는 것이 목표다.
- 웹 브라우저 동작을 이해하기 위해서, 텍스트 기반으로 동작하는 웹 브라우저를 만드는 것이 목표다. 

## 미션

### 1) URL 처리 요구사항

- URI/URL 규격을 처리하는 라이브러리 모듈 또는 클래스를 구현한다.

	- nodejs URL 모듈과 상관없이 다음 조건을 만족하는 직접 URL 객체를 구현해야 한다.

- URL 문자열을 초기 매개변수로 전달해서 URL 객체를 생성할 수 있어야 한다.

	- URL에 포함될 수 없는 특수문자가 포함된 경우나 필수적인 항목이 없으면 `throw` 처리한다.

	- URL 구성 문자에서 escape 문자는 무시하고 alpha 또는 digit, safe, extra 수준만 지원한다고 가정한다. [BNF 문법 참조](https://tools.ietf.org/html/rfc1738) 

	- 따라서 escape 문자는 구현하지 않아도 된다.

- 다음과 같은 URL 부속 요소에 접근해서 읽고, 변경할 수 있어야 한다.

  - host : String
  - lastPathComponent : String
  - pathComponents : [String] //readonly
  - port : Int
  - query : String
  - scheme : String
  - isFileURL : Boolean
  - user : String
  - password : String
  - absoluteString : String (computed property)
  
- Path Components 관련 기능

  - `pathComponents`는 읽기만 가능하도록 만들고 변경하는 것은 메소드를 만든다

  - append 경로 추가하는 메소드

  - 마지막 경로 제거하기

- URL 객체끼리 같은지 비교하는 함수. 결과는 다음과 같에 5개 상태중에 하나

	1) scheme부터 username, password, host:port까지 같은 상태

	2) scheme과 host:port만 같은 상태 (username, password 제외)

	3) scheme부터 path까지만 모두 같은 상태

	4) 완벽하게 같은 상태

	5) 그 외 서로 다른 상태

- 기본 동작을 확인하기 위한 테스트 코드를 작성해서 동작 결과를 확인한다.

#### 동작 예시 (테스트 코드는 생략)

```javascript
var url = new URL(&quot;http://user_name:pass-word@boostcamp.connect-foundation.or.kr:2019/first/second/last?query=ab&amp;param=12&quot;);

//url.host = &quot;boostcamp.connect-foundation.or.kr&quot;
//url.lastPathComponent = &quot;last&quot;
//url.pathComponents = [&quot;/&quot;, &quot;first&quot;, &quot;second&quot;, &quot;last&quot;]
//url.port = 2019
//url.query = &quot;query=ab&amp;param=12&quot;
//url.scheme = &quot;http&quot;
//url.isFileURL = false
//url.user = &quot;user_name&quot;
//url.password = &quot;pass-word&quot;
//url.absoluteString = &quot;http://user_name:pass-word@boostcamp.connect-foundation.or.kr:2019/first/second/last?query=ab&amp;param=12&quot;

url.appendPathComponent(&quot;basecamp&quot;);
url.appendPathComponent(&quot;camp&quot;);
//url.absoluteString = &quot;http://user_name:pass-word@boostcamp.connect-foundation.or.kr:2019/first/second/last/basecamp/camp?query=ab&amp;param=12&quot;
url.deleteLastPathComponent();
//url.absoluteString = &quot;http://user_name: pass-word@boostcamp.connect-foundation.or.kr:2019/first/second/last/basecamp?query=ab&amp;param=12&quot;

var url2 = new URL(&quot;http://user_name:pass-word@boostcamp.connect-foundation.or.kr:2019/first/second/last?query=cd&amp;param=12&quot;);


var zumurl = new URL(&quot;http://admin@zum.com/#!/home?query=zum&quot;);

var naverurl = new URL(&quot;http://m.naver.com&quot;);
console.log(zumurl.isEqual(naverurl));

var url1 = new URL(&quot;http://admin@zum.com/#!/home?query=zum&quot;);
console.log(zumurl.isEqual(url1));

var url2 = new URL(&quot;http://admin@zum.com/#!/home&quot;);
console.log(zumurl.isEqual(url2));

var url3 = new URL(&quot;http://admin@zum.com/?param=zum&quot;);
console.log(zumurl.isEqual(url3));

var url4 = new URL(&quot;http://zum.com/#!/home&quot;);
console.log(zumurl.isEqual(url4));
```


### 2) HTTP Request 요구사항

- 웹 브라우저가 동작하는 것을 단순화해서 그대로 구현한다.

- 프로그램을 실행할 때 또는 실행하고 나서 URL을 입력한다. 
	
	- `http://zum.com` 주소를 넣어서 꼭 동작해야 한다.

- 입력한 URL 구성 요소를 분석하고, host 정보를 DNS Server에서 검색한다. 

	- Node API 중에서 DNS 모듈을 활용한다.

- host 정보로 찾은 IP 주소 중에 첫번째 값과 port 정보로 TCP Socket을 연결한다. 

	- Node API 중에 Net 모듈을 활용한다.

- HTTP Request 규격을 처리하는 라이브러리 모듈 또는 클래스를 구현한다.

	- 매개변수로 URL을 넘겨서 Request 객체를 생성한다.

	- 요청 방식을 변경하기 위해서 method를 바꿀 수 있다. 기본값은 `GET` 메소드로 생성한다.

	- 요청에 필요한 Header를 추가할 수 있다. 

	- 전송하기 위해 Request Message를 문자열로 return하는 stringfy() 메소드를 구현한다.

- URL 정보를 바탕으로 HTTP Request 객체를 생성하고, Request 메시지를 TCP 세션에 전송(send)한다. 소켓을 생성해서 요청을 보내고 응답을 받아서 처리하는 동작을 구현한다.

	- 서버가 HTTP Reqeust를 인식하기 위한 필수 헤더로 구성한다. (어떤 헤더가 필요한가 학습해서 추가한다.)

- 동작 예시1처럼 네이버로 요청하는 경우 어떤 응답이 오는지 확인한다.

- 동작 예시2에 있는 주소로 GET 요청을 전송한다.

	- 정상적으로 전송되었는지 WireShark 같은 네트워크 분석 도구에서 확인한다. 

	- 결과를 화면 캡처해서 첨부한다.

#### 동작 예시1

&gt; URL `http://m.naver.com`
&gt; 
&gt; (DNS Lookup...)
&gt; 
&gt; TCP Connection : 125.209.218.87 80
&gt;
&gt; `HTTP Request`


#### 동작 예시2

&gt; URL `http://zum.com`
&gt; 
&gt; (DNS Lookup...)
&gt; 
&gt; TCP Connection : 121.189.40.10 80
&gt;
&gt; `HTTP Request`


### 3) HTTP Response 요구사항

- 웹 브라우저가 기본 동작을 구현하기 위해서 응답 처리를 구현한다.

- Request 전송 이후에 수신되는 HTTP Response을 받아서 아래 과정을 거쳐서 출력한다.

- 만약 body에 오는 data가 커서 분리되는 경우는 나머지를 합쳐서 전체를 저장해야 한다. 

	- 정확하게 Content-Length 헤더에 있는 값과 특수문자를 포함한 Body 크기가 같아야 한다.

- 전체 응답을 다 받고나면 응답 데이터를 분석한다.

	- HTTPRequest 처럼 HTTPResponse 객체를 구현한다.

	- HTTP Response Header 부분과 Body를 구분한다. 

	- HTTP Reponse Status 코드를 분리한다. 

	- HTTP Header 중에서 Content-Length 값을 분리한다.

- HTTPResponse 객체는 다음과 같은 속성을 가진다.

	- statusCode : Int

	- responseLine : String

	- contentLength : Int

	- headers : [String]

	- body : Buffer

- Reponse Header를 문자열로 출력하고, Body를 문자열로 바꿔서 출력한다. 

- 모든 데이터를 받고 3초 후에 socket을 소멸하고 프로그램을 종료한다.

#### 동작 예시

&gt; URL `http://zum.com`
&gt;
&gt; TCP Connection : 121.189.40.10 80

`HTTP Request`

```
GET / HTTP/1.1
Accept: text/html
Host: zum.com
User-Agent: Mozilla/5.0
```

`HTTP Response header`

```
HTTP/1.1 200
Server: nginx/1.8.0
Date: Fri, 29 Mar 2019 10:17:38 GMT
Content-Type: text/html;charset=UTF-8
Content-Length: 99605
Connection: keep-alive
Keep-Alive: timeout=5
Vary: Accept-Encoding
X-Application-Context: application:set1:8081
Cache-Control: no-store
Set-Cookie: _TUID=2053B3E7-129F-40E0-A1D0-A6BF7A541B57; Expires=Mon, 26-Mar-2029 10:17:38 GMT; Path=/
Set-Cookie: _ZUT=nc%3D72843112530; Domain=.zum.com; Path=/
Set-Cookie: czi=&quot;&quot;; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Path=/
Set-Cookie: bakeryStamp=1; Expires=Mon, 26-Mar-2029 10:17:38 GMT; Path=/
Set-Cookie: p=0; Path=/
```

`HTTP Response Body - HTML`

```
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ko&quot; class=&quot;&quot;&gt;
&lt;head&gt;
&lt;title&gt;ZUM - 생각을 읽다, ZUM&lt;/title&gt;


&lt;meta charset=&quot;utf-8&quot;/&gt;
&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;/&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt;
&lt;meta property=&quot;og:title&quot; content=&quot;검색포털 줌닷컴&quot;/&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;생각을 읽는 검색포털 줌닷컴에서 빠르고 편리한 서비스를 만나보세요!&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;http://lego.zumst.com/resources/current/images/img_zum.jpg&quot;/&gt;
&lt;link rel=&quot;image_src&quot; href=&quot;http://lego.zumst.com/resources/current/images/thumb_zum.jpg&quot;/&gt;
&lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico?v=2&quot;/&gt;
&lt;style&gt;
html {
background: url(http://lego.zumst.com/resources/current/images/img_main_loading.gif) no-repeat 50% 310px
}
body {
display: none
}
&lt;/style&gt;
... &lt;중간생략&gt;

&lt;/head&gt;
&lt;body&gt;

...&lt;중간생략&gt;

&lt;li&gt;
&lt;div class=&quot;item&quot; data-olap-url=&quot;//olaplog.smartmediarep.com/api/v1/olap/olap.sb?version=1.0&amp;media=SMR_MEMBERS&amp;site=ZUM&amp;recomedia=SMR&amp;page=CP_HOME&amp;layout=L1&amp;cpid=C0&amp;channelid=&amp;section=&amp;brand=&amp;programid=&amp;clipid=&amp;targetclipid=CS1_192310&amp;requesttime=20190329191600&amp;device=PC&quot;&gt;
&lt;a class=&quot;clip_content&quot; href=&quot;//tv.zum.com/play/1059872&quot; data-cm=&quot;img&quot; data-order=&quot;5&quot;&gt;
&lt;div class=&quot;thumb&quot;&gt;
&lt;img src=&quot;//thumb.tv.zumst.com/s/zum.tv-zum-cf/tvchosun/2019/03/29/4d63ff958c335f38c8cfe8bb14b70af5.jpg?w=352&amp;h=200&quot;&gt;
&lt;/div&gt;
&lt;span class=&quot;bd&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;icon_mov&quot;&gt;&lt;/span&gt;
&lt;/a&gt;
&lt;a class=&quot;clip_content&quot; href=&quot;//tv.zum.com/play/1059872&quot; data-cm=&quot;tit&quot; data-order=&quot;5&quot;&gt;
&lt;strong class=&quot;title&quot;&gt;입 벌어지는 ‘커피 한 잔‘ 장하온 ◉_◉ 박력 웨이브까지?&lt;/strong&gt;
&lt;/a&gt;
&lt;span class=&quot;source&quot;&gt;
&lt;a class=&quot;clip_content channel&quot; href=&quot;//tv.zum.com/channel/3489&quot; data-cm=&quot;reference&quot; data-order=&quot;5&quot;&gt;
미스트롯
&lt;/a&gt;
&lt;/span&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;a href=&quot;//tv.zum.com&quot; class=&quot;view_more&quot;&gt;
&lt;span&gt;TV줌&lt;/span&gt; 홈&lt;b class=&quot;icon_arrow&quot;&gt;&lt;/b&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;body {-ms-touch-action: pan-y pinch-zoom;}&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;

```

## 배경 지식

### URI/URL 규격

- URI 주소를 구성하는 요소들에 대해 어떤 용어로 구분하고 처리하는지 학습한다.

- `RFC1738` 표준안에 명시되어 있는 문법 구성을 학습한다.

### HTTP 프로토콜

- HTTP 1.1 프로토콜 규격에서 Request와 Response 종류에 대해 학습한다.

- HTTP과 함께 사용하는 관련 프로토콜 규격을 찾아보고 어떤 역할을 담당하는지 학습한다.

- 웹 브라우저가 동작하는 방식에 대해 학습한다.

	- URL을 입력하면 URL 구성 요소를 분석하고, host 정보를 DNS Server에서 검색한다.

	- host 정보에서 찾은 서버로 보내는 HTTP Reqeuset 내용을 브라우저 개발자 환경에서 확인한다.

	- 여러 사이트에서 받는 HTTP Response 내용을 확인하고, 필수적인 정보가 무엇인가 확인한다.

	- 웹 브라우저는 응답으로 받은 HTML을 표시하기 위해서 어떤 동작을 하는지 확인한다.

### SOCKET API

- TCP/IP 수준에서 저수준 네트워크 프로그래밍을 위한 SOCKET API에 대해 학습한다.

- SOCKET API에 대한 Client, Server 동작 원리를 학습한다.

## 학습정리

### 피어 컴파일링 체크포인트

```
  1. [ ] URL 문자열로 URL 분석 후 객체 생성 - 예외처리 확인
  2. [ ] URL 부속 요소 접근 - 5개 이상 구현 확인
  3. [ ] Path 콤포넌트 - 경로 변경 확인
  4. [ ] URL 객체 비교 - 모든 상태 조건 확인
  5. [ ] 텍스트 브라우저에 URL 주소 입력 - zum.com 동작 확인
  6. [ ] DNS 검색 - Host 주소 확인
  7. [ ] HTTP Request 객체 생성 + 필수 헤더 포함
  8. [ ] HTTP Request 메시지 전송 - Socket Client 동작 확인
  9. [ ] HTTP Response 수신 + 데이터 병합 - Content-Length와 크기 비교
  10. [ ] HTTP Response 분석 객체 - Response Header 확인
  11. [ ] HTTP Response Body 출력 - HTML
```

### 스스로 확인할 사항

- URL 구성 요소에 대해 학습한다. 
- 다양한 URL 케이스를 어떻게 처리하는지 확인한 방법을 정리한다.
- HTTP Request 종류와 HTTP Response 종류에 대해 학습하고 정리한다.

### 다같이 확인할 사항

- 웹 브라우저가 동작하는 과정을 개발자 화면에서 확인하고 학습한다.
- 리눅스/유닉스 환경에서 wget 이나 curl 명령 사용방식에 대해 학습한다.
- 브라우저가 처리하는 과정을 WireShark 같은 네트워크 패킷 분석 도구를 통해서 확인한다.
- WireShark 도구가 동작하는 원리에 대해 학습한다.
--&gt;</content><author><name>이창권</name></author><summary type="html">Text Browser URI/URL 표준 규격을 학습하고, URL 문자열을 분석해서 처리하는 라이브러리를 직접 구현하여 보자 1. 코드 동작 이해 url string이 주어졌을 때, 이를 요소별로 나누어 주는 Parsing URL class를 생성 정규표현식을 이용하여 검사와 URL 분석을 수행한다. mocha 라이브러리를 사용하여 테스트 케이스를 작성하고 TDD를 수행한다. describe(&quot;URL&quot;, () =&amp;gt; { const url = new URL( &quot;http://user_name:pass-word@boostcamp.connect-foundation.or.kr:2019/first/second/last?query=ab&amp;amp;param=12&quot; ); it(&quot;host&quot;, () =&amp;gt; assert.equal(url.host, &quot;boostcamp.connect-foundation.or.kr&quot;)); it(&quot;lastPathComponent&quot;, () =&amp;gt; assert.equal(url.lastPathComponent, &quot;last&quot;)); it(&quot;pathComponents&quot;, () =&amp;gt; assert.deepEqual(url.pathComponents, [&quot;/&quot;, &quot;first&quot;, &quot;second&quot;, &quot;last&quot;])); it(&quot;port&quot;, () =&amp;gt; assert.equal(url.port, 2019)); it(&quot;query&quot;, () =&amp;gt; assert.equal(url.query, &quot;query=ab&amp;amp;param=12&quot;)); }); XMLHttpRequest 객체의 역할을 하는 HttpRequest class를 생성 입력받은 URL에서 필요한 부분들을 this 객체에 저장한다. 사용자에게 입력받을 option과 default 옵션을 구현한다. net과 dns 모듈을 사용하여 생성자에서 결과를 저장할 수 있도록 설정한다. const client = net.connect({port:80, host:ip}, function() { console.log('connected to server!'); const msg = `GET / HTTP/1.1` + `\r\nAccept: text/html` + `\r\nHost: ${addr}` + `\r\nUser-Agent: Mozilla/5.0\r\n\r\n` console.log(msg); client.write(msg); }); XMLHttpResponse 객체의 역할을 하는 HttpResponse class를 생성 HttpRequest객체를 사용해서 서버로부터 받은 데이터를 HttpResponse에서 처리해준다. Buffer형태로 데이터를 받기 때문에 Buffer객체를 사용해서 처리한다. class HTTPResponse { constructor() { this.statusCode; this.responseLine; this.contentLength; this.header; this.body; } }; module.exports = HTTPResponse; socket 통신 방법 url string이 주어졌을 때, URL class를 이용하여 분석을 해 요소로 나눈다. URL객체의 host를 받아 dns module을 이용해서 ip를 받는다. node의 net module을 이용해서, client를 만들고 socket을 만들어 HttpRequest 객체를 생성해 서버로 전달해준다. 서버에서 받은 데이터를 parsing해 HttpResponse객체를 만들어 콘솔에 출력해 준다. HTTPResponse { header: 'HTTP/1.1 200 \r\nServer: nginx/1.6.0\r\nDate: Fri, 09 Aug 2019 01:53:51 GMT\r\nContent-Type: text/html;charset=UTF-8\r\nContent-Length: 128302\r\nConnection: keep-alive\r\nKeep-Alive: timeout=5\r\nVary: Accept-Encoding\r\nX-Application-Context: application:set1:8081\r\nCache-Control: no-store\r\nSet-Cookie: _TUID=247D3ABD-F06E-4F68-B615-132B81F5126F; Expires=Mon, 06-Aug-2029 01:53:51 GMT; Path=/\r\nSet-Cookie: _ZUT=nc%3D82c11590530; Domain=.zum.com; Path=/\r\nSet-Cookie: czi=&quot;&quot;; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Path=/\r\nSet-Cookie: bakeryStamp=1; Expires=Mon, 06-Aug-2029 01:53:51 GMT; Path=/\r\nSet-Cookie: p=0; Path=/\r\n\r\n', body: &amp;lt;Buffer 3c 21 44 4f 43 54 59 50 45 20 42 4f 44 59 3e 0a 3c 68 74 6d 6c 20 6c 61 6e 67 3d 22 6b 6f 22 20 63 6c 61 73 73 3d 22 22 3e 0a 3c 68 65 61 64 3e 0a 3c ... &amp;gt;, statusCode: 200, responseLine: 'HTTP/1.1 200', contentLength: 128302 } 2. 코드 동작 개선 response를 받을 때의 data를 stream을 사용해서 받아야 한다. content-length를 비교할 때, string으로 바꾸면 데이터의 손실이 일어나기 때문에 stream을 사용해서 받아야 한다. url class 객체 예외 처리시 test 코드를 구성해서 test하면 효율적이다. 3. Consideration 스스로 확인할 사항 URL 구성 요소에 대해 학습한다. &amp;lt;스킴&amp;gt;://&amp;lt;사용자이름&amp;gt;:&amp;lt;비밀번호&amp;gt;@&amp;lt;호스트&amp;gt;:&amp;lt;포트&amp;gt;/&amp;lt;경로&amp;gt;?&amp;lt;질의&amp;gt;#&amp;lt;프레그먼트&amp;gt; 스킴 사용할 프로토콜을 말하며, 리소스에 어떻게 요청, 접근할 것인지를 명시한다. 웹에서는 주로 HTTP 프로토콜을 사용한다. 사용자 이름과 비밀번호 어떤 서버들은 자신이 가지고 있는 데이터에 접근하기 위해서 사용자의 이름과 비밀번호를 요구한다. 만약 웹 서버에서 사용자이름과 비밀번호를 요구하는 URL 스킴을 사용함에도 클라이언트가 이를 명시하지 않고 URL에 접근한다면, 기본값으로 “사용자 이름 : anonumous , 비밀번호는 브라우저에서 제공하는 기본 값”을 따르게 된다. 호스트와 포트 하나의 Host( 컴퓨터 )에는 여러 개의 Process( 프로그램 )이 각각의 Socket( 소켓 )을 사용하여 데이터 통신을 하고 있기 때문에, 각각의 소켓을 구분할 필요가 있습니다. 이 때 소켓을 구분하는 역할을 하는 것이 Port( 포트 )이다. 경로 호스트에서 제공하는 자원의 경로를 의미한다. 질의 Query String( 쿼리 스트링 )이라고도 한다. 클라이언트가 자원을 GET 방식으로 요청할 때, 필요한 데이터를 함께 넘겨 줄 목적으로 사용한다. 프래그먼트 HTML에는 각각의 요소에 id 속성을 부여할 수 있는데, URL에 프래그먼트를 전달하면 페이지가 해당 id가 있는 곳으로 스크롤이 이동하게 된다. 다양한 URL 케이스를 어떻게 처리하는지 확인한 방법을 정리한다. HTTP(URI) 스키마, 도메인, 포트, 경로, 쿼리, 프래그먼트로 구성되어 있다. FILE URL과는 달리 보통 절대 경로명을 써주는데 ‘://’ 다음에 ‘/’로 시작한다. ‘/dir1/dir2/file’은 자신의 컴퓨터에 있는 ‘dir1\dir2'에 있는 file이라는 파일을 나타낸다. 호스트 주소를 적어주게 되면 FTP 서비스로 동작한다. FTP Anonymouse FTP 서버에서 파일을 지정할 때 사용한다. ftp://로 시작한다 Telnet 텔넷도 ftp와 비슷하며 통신을할 때 주로 쓰인다. telnet://로 시작한다. TTP Request 종류와 HTTP Response 종류에 대해 학습하고 정리한다. HTTP Request정보 요청 URL 정보(method, URL HTTP버전) 사용자 웹 브라우져 종류 요청 데이터 타입 (응답의 Content-type과 유사) 쿠키(인증 정보) 경유지 URL 요청 도메인 GET /index.html HTTP/1.1 User-Agent: MSIE 6.0; Window NT 5.0 Accept: test/html Cookie: name=value Refere: http://abc.com Host: www.abc.com HTTP Request 종류 GET : 요청받은 URI의 정보를 검색하여 응답한다. HEAD : GET방식과 동일하지만, 응답에 BODY가 없고 응답코드와 HEAD만 응답한다. 웹서버 정보확인, 헬스체크, 버젼확인, 최종 수정일자 확인등의 용도로 사용된다. POST : 요청된 자원을 생성(CREATE)한다. 새로 작성된 리소스인 경우 HTTP헤더 항목 Location : URI주소를 포함하여 응답. PUT : 요청된 자원을 수정(UPDATE)한다. 내용 갱신을 위주로 Location : URI를 보내지 않아도 된다. 클라이언트측은 요청된 URI를 그대로 사용하는 것으로 간주함. PATCH : PUT과 유사하게 요청된 자원을 수정(UPDATE)할 때 사용한다. PUT의 경우 자원 전체를 갱신하는 의미지만, PATCH는 해당자원의 일부를 교체하는 의미로 사용. DELETE : 요청된 자원을 삭제할 것을 요청함. (안전성 문제로 대부분의 서버에서 비활성) CONNECT : 동적으로 터널 모드를 교환, 프락시 기능을 요청시 사용 TRACE : 원격지 서버에 루프백 메시지 호출하기 위해 테스트용으로 사용 OPTIONS : 웹서버에서 지원되는 메소드의 종류를 확인할 경우 사용 HTTP Response 정보 프로토콜 버젼 및 응답코드 웹 서버 정보 MIME 타입 HTTP BODY 사이즈 HTTP BODY 컨텐츠 HTTP/1.1 200 OK Server: Apache Content-type: text/html Content-length : 1593 &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;..... HTTP Response 종류 다같이 확인할 사항 웹 브라우저가 동작하는 과정을 개발자 화면에서 확인하고 학습한다. 웹 브라우저는 GET 요청을 받았을 때 해당 사이트 한 군대에만 요청을 보내는 것이 아니라, 해당 페이지에서 필요한 모든 리소스들에게 요청들을 보내게 된다. 요청마다 아래와 같은 각기 다른 request와 response를 받는다. 또한 브라우저에서 페이지 변동 없이, 간단한 조작에도 다양한 request를 보내는 것을 확인할 수 있다. 개발자 도구의 Network 탭에서 아래와 같은 화면을 확인할 수 있다. 각 요청마다 클릭 시 Header, Response, Cookies 등을 확인할 수 있다. 리눅스/유닉스 환경에서 wget 이나 curl 명령 사용방식에 대해 학습한다. wget : 웹 서버로부터 콘텐츠를 가져오는 프로그램. curl : 다양한 프로토콜을 이용하여 데이터를 전송하기 위한 명령 줄 도구를 제공하는 프로젝트. 공통점 FTP, HTT, HTTPS 로 자료를 전송할 수 있다. HTTP POST 요청을 보낼 수 있다. HTTP 쿠키를 지원한다. 스크립트처럼 사용자와 상호작용없이 작동한다. 오픈소스이며 무료다. 메타링크를 지원한다. 차이점 curl 라이브러리가 존재한다. 사용자가 지정한 url만 전송한다. 더 다양한 프로토콜을 지원한다. 자동압축해제를 지원한다. HTTP/2를 지원한다. wget 라이브러리가 없다. 디렉토리 구조와 파일을 그대로 복사해온다. GNU 프로젝트의 일부이다. 큰 옵션없이 URL을 받을 수 있다. Public Suffix List를 활용한다. proxy에 기본 인증을 지원한다. 사용법 # Wget https://ko.wikipedia.org/wiki/Wget # example.com의 &quot;index.html&quot; 제목 페이지를 # 파일로 내려받기 wget http://www.example.com/ # GNU FTP 사이트로부터 Wget의 소스 코드 내려받기. wget ftp://ftp.gnu.org/pub/gnu/wget/wget-latest.tar.gz 더 복잡한 예로는 여러 URL을 하나의 디렉터리 계층으로 자동 다운로드하는 방법이 있다. # Download *.gif from a website # (globbing, like &quot;wget http://www.server.com/dir/*.gif&quot;, only works with ftp) wget -e robots=off -r -l1 --no-parent -A.gif ftp://www.example.com/dir/ # Download the title page of example.com, along with # the images and style sheets needed to display the page, and convert the # URLs inside it to refer to locally available content. wget -p -k http://www.example.com/ # Download the entire contents of example.com wget -r -l 0 http://www.example.com/ # cURL https://www.lesstif.com/pages/viewpage.action?pageId=14745703 # 다운로드 받은 파일을 콘솔로 출력 curl http://www.gnu.org/software/bash/manual/html_node/index.html # 지정한 이름으로 저장 curl -o index.html http://www.gnu.org/software/bash/manual/html_node/index.html # 서버의 filename 으로 저장 curl -O http://www.gnu.org/software/bash/manual/html_node/index.html # 여러 url 에서 동시에 다운로드 curl -O http://www.gnu.org/software/bash/manual/html_node/index.html -O http://www.gnu.org/savannah-checkouts/gnu/libiconv/documentation/libiconv-1.13/iconv.1.html https://m.blog.naver.com/PostView.nhn?blogId=alkydes&amp;amp;logNo=220593597738&amp;amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F 브라우저가 처리하는 과정을 WireShark 같은 네트워크 패킷 분석 도구를 통해서 확인한다. 미션 중에 수행한 zum.com에 reqeust한 패킷을 확인해본다. WireShark 도구가 동작하는 원리에 대해 학습한다. wireshark의 패킷 캡쳐 원리는 패킷 스니핑이다. 상대방들의 패킷 교환을 엿듣는것을 의미한다. 쉽게말해 네트워크 트래픽을 도청하는 과정을 스니핑이라고 할 수 있다. 흔히 인디게임들이 사용하는 방식으로써 게임에서는 PlayerPrefs 의 정보나 Json 및 Xml 파싱정보를 서버에 POST로 날리는 방식으로 구현하는데 이때 각종 스니퍼로 해당 패킷을 캡쳐후 분석 - 가짜 수정 데이터를 서버에 다시한번 전송하는것으로 가짜기록을 서버에 덮어쓰기 하는 방식이다.</summary></entry><entry><title type="html">부스트 캠프 Day15</title><link href="https://changgunyee.github.io/boost-camp/2019/08/07/boostCamp-Day15.html" rel="alternate" type="text/html" title="부스트 캠프 Day15" /><published>2019-08-07T00:00:00+09:00</published><updated>2019-08-07T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/08/07/boostCamp-Day15</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/08/07/boostCamp-Day15.html">&lt;h1 id=&quot;async-cafe&quot;&gt;Async Cafe&lt;/h1&gt;

&lt;p&gt;카페에서 동시에 여러 고객이 다양한 음료를 주문했을 때 주문해서 나올 때까지 여러 명의 바리스타 비동기 작업을 시뮬레이션하는 프로그램을 만들어보자&lt;/p&gt;

&lt;h2 id=&quot;1-코드-동작-이해&quot;&gt;1. 코드 동작 이해&lt;/h2&gt;

&lt;p&gt;class간의 통신을 주로 event를 통해서 관리한다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;EventEmitter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Manager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;EventEmitter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//events모듈의 EventEmitter를 상속&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//이벤트를 받는 역할&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Baristar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//manager의 이벤트를 발생시킨다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;cashier는 command창에서 주문과 바리스타 수를 입력받아 manager객체를 생성하고 dashBoard와 orderQueue에 주문이 &lt;code class=&quot;highlighter-rouge&quot;&gt;추가되었다&lt;/code&gt;라는 event를 발생시킨다.&lt;br /&gt;&lt;br /&gt;
manager class 프로그램의 중심이 되는 역할을 한다. 1초간격으로 orderQueue를 관찰하여, baristar에게 일을 전달한다. baristar에게서 완료 이벤트를 받으면 orderQueue와 dashBoard에 event를 발생시킨다.&lt;br /&gt;&lt;br /&gt;
Baristar class는 manager로부터 event를 통해 주문을 받으면 음료를 만드는 함수를 실행시키고 결과를 event로 다시 매니저에게 전달한다.&lt;br /&gt;&lt;br /&gt;
OrderQueue class는 order를 queue형식으로 가지며, 현재 주문 상태를 관리한다. listner를 통해 Manager로부터 event를 받아 order를 추가, 삭제한다.&lt;br /&gt;&lt;br /&gt;
DashBoard class는 listener를 통해 update, complete, start event 등을 받아 현재 상태를 출력하고, 현황판을 위해 현재 주문 상태를 json파일 형식으로 내보낸다.&lt;br /&gt;&lt;br /&gt;
/server/index.js 는 9000번 포트를 열어 dashBoard가 만든 json파일을 불러와 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;로 라우팅되면 모든 손님 상태를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/:customer&lt;/code&gt;로 라우팅 되면 해당 손님 상태를 보여준다&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-코드-동작-개선&quot;&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;p&gt;구현 시간 상, DashBoard class와 OrderQueue class에서 따로 주문을 관리하지만 사실 OrderQueue에서 관리를 하고 DashBoard에서는 property로 orderQueue를 가지는 것도 괜찮은 설계이다.&lt;br /&gt;&lt;br /&gt;
구현을 하다보니 global하게 쓰는 constant들이 많아졌는데, 따라 파일로 만들어서 가져오는 것이 효율적이다.&lt;br /&gt;&lt;br /&gt;
baristar가 3명 이상일 때, major drink를 1개로 두었지만 2개로 두면 놀고 있는 바리스타들이 훨씬 줄어든다. 사실 baristar마다 priorityQueue를 가지게 해서 음료에 맞는 바리스타들을 선정하는 것이 제일 효율적이다.&lt;br /&gt;&lt;br /&gt;
설계 시, 후에 어떤 부분을 더 구현하게 될지 모르기 때문에 최대한 확장성이 좋고 재사용성이 좋게 짜는 것이 좋다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-consideration&quot;&gt;3. Consideration&lt;/h2&gt;

&lt;h3 id=&quot;스스로-확인할-사항&quot;&gt;스스로 확인할 사항&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Node.js 이벤트 루프와 이벤트 처리(Event Emitter) 방식에 대해 학습하고 정리한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이벤트 루프&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;노드에서 일어나는 모든 일은 어떤 이벤트에 대한 반응이다&lt;/li&gt;
  &lt;li&gt;이벤트루프는 Node.js를 실행시켜주는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/laxyuo0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이벤트루프는 몇가지 단계들을 차례대로 반복하면서 순서대로 각 단계들의 작업들을 처리해나갑니다.(초록색 박스)&lt;/li&gt;
  &lt;li&gt;Timer
    &lt;ul&gt;
      &lt;li&gt;setTimeout/Interval에서 스케줄링된 모든 것이 처리된다&lt;/li&gt;
      &lt;li&gt;하지만 그 타이머 안에 등록한 콜백함수의 실행은 Polling 단계의 가장 앞부분에서 이루어진다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IO Callbacks
    &lt;ul&gt;
      &lt;li&gt;TCP오류 같은 시스템 작업의 콜백을 반환한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IO Polling
    &lt;ul&gt;
      &lt;li&gt;Timers 단계에 스케줄링 되었던 콜백들 중에, 시간이 지난 타이머의 콜백을 실행합니다&lt;/li&gt;
      &lt;li&gt;그 다음, Poll 단계의 큐에 있는 이벤트들을 처리합니다. 대부분의 콜백들은 이 Poll 단계에서 처리됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Set Immediate
    &lt;ul&gt;
      &lt;li&gt;setImmediate()를 통해 등록된 모든 콜백을 실행됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Close Events
    &lt;ul&gt;
      &lt;li&gt;close 이벤트에 대한 모든 콜백 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이벤트 처리 방식(Event Emitter)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Node.JS에 내장되어 있는 일종의 옵저버 패턴 구현&lt;/li&gt;
  &lt;li&gt;이벤트를 내보내는 모든 객체는 EventEmitter 클래스의 인스턴스다.&lt;/li&gt;
  &lt;li&gt;EventEmitter 객체로 이벤트를 호출(emit)할 때, 해당 이벤트에 붙어 있는 모든 함수(listener)는 동기적으로 호출된다. 호출을 받은 리스너가 반환하는 결과는 어떤 값이든 무시되고 폐기된다.&lt;/li&gt;
  &lt;li&gt;메소드 종류로는 emit, on, once 등이 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Day14에서 워커를 사용한 멀티 스레드 방식과 단일 스레드에서 비동기 병렬 처리 방식에 대해 비교해서 학습하고 정리한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;멀티 스레드 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;바리스타의 작업을 웹 워커(스레드)를 생성해서 진행시킨다&lt;/li&gt;
  &lt;li&gt;웹 워커는 오래 걸리는 작업들(랜더링 작업)에 주로 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단일 스레드 &amp;amp; 비동기 병렬 처리 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;바리스타의 작업을 이벤트 호출을 통해 진행시킨다.&lt;/li&gt;
  &lt;li&gt;두 방식 모두 비동기로 진행되어서 오래 걸리는 작업에 Block 되는 일을 방지해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;다같이-확인할-사항&quot;&gt;다같이 확인할 사항&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Event-Bus 패턴에 대해 학습하고 주문 담당자, 매니저, 주문 대기표, 바리스타 관계를 비교한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;특정 채널을 통해 메시지가 메시지 버스를 통해 전달 되면, 리스너(listener)는 등록(subscribe)한 특정 채널에 해당하는 메시지를 이벤트로 받는 구조이다. 이벤트를 받는 것을 영어로 Event Notification이라고도 한다.&lt;br /&gt;
이벤트-버스 아키텍쳐 패턴(Event-bus Architectural pattern)은 고도로 분산화된 애플리케이션에 효과적이라고 할 수 있다. 반면, 모든 메시지가 동일한 이벤트 버스를 통해 전달되기 때문에 확장성 문제가 발생할 수 있다는 단점이 있다.&lt;br /&gt;
주문 담당자는 event source가 되고, 매니저는 event channel이 된다. 또한 바리스타는 event listener이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://kurapa.com/wp-content/uploads/2018/08/image-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Publish-subscribe 패턴에 대해 학습하고, 이벤트 처리 대신 구조에 적용할 수 있는지 확인한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pub-Sub 패턴은 여러가지 메시지 패턴 중 하나이다.&lt;br /&gt;
Observe 패턴과 달리 구독자와 출판자의 등록 과정을 분리하여 의존성을 더욱 낮추고 있다.&lt;br /&gt;
이 때 Publisher와 Subscriber 사이의 역할을 Event Bus가 채워주게 된다.&lt;br /&gt;
발생한 이벤트에 따라 각각의 이벤트가 발생할 수 있으므로, Pub-Sub 패턴을 기존 구조에 적용할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/h13Jtmy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;만드는 데 4초가 걸리는 허브티와 15초가 걸리는 팥빙수를 추가하기 위한 구조와 코드를 토론한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기존의 코드 동작 과정에서 크게 달라지는 것이 없다.&lt;br /&gt;
Queue에 저장되는 데이터의 type과 delay가 종류에 따라 추가되는 것 뿐이다.&lt;br /&gt;
Manager에서는 Barista에게 Queue에 저장된 데이터를 보내게 되고, Barista는 해당 데이터에 따라 delay*1000ms 후에 동작을 하게 되므로 기존 동작과정에서 발생하는 문제는 없다.&lt;br /&gt;
단, 팥빙수는 다른 제조 과정보다 오랜 시간이 걸리기 때문에 팥빙수를 담당해서 만드는 바리스타가 있도록 설계하면 더 좋은 알고리즘으로 동작할 수 있을 것 같다.&lt;/p&gt;

&lt;!--
# Day15 Async Cafe

## 왜 필요한가?
웹 브라우저는 멀티 스레드로 동작하기 어렵기 때문에 단일 스레드에서 이벤트 단위로 병렬 처리하는 구조로 동작한다. 스레드를 무한정 늘리지 않고 비동기 방식으로 동작하는 병렬 처리 방식에 대해 이해하고 구현할 수 있어야 한다.

## 학습 목표
- 카페에서 동시에 여러 고객이 다양한 음료를 주문했을 때 주문해서 나올 때까지 여러 명의 바리스타 비동기 작업을 시뮬레이션하는 프로그램을 만드는 것이 목표다. 
- 동기 방식 카페 시뮬레이터보다 효율적인 방식을 구현한다.

## 미션

- 지금까지 미션들에서 학습했던 다양한 패턴, 응용 방식을 활용해서 node 기반으로 작업한다.

- 다음 요구사항에 나오는 구성 요소들을 객체나 모듈로 구분해서 구현한다.

- 동기 함수들 보다 비동기 함수를 중심으로 구현한다.

### 1) 주문 이벤트 요구사항

- 스레드를 만드는 Worker 대신에, Node 기반 Event Emitter로 동작하는 비동기 이벤트 처리하도록 구현한다.

- 주문 담당자(Chashier)는 음료 주문을 연속해서 받을 수 있다.

- 음료 주문을 받으면 주문 대기표(Queue)에 추가한다.

  - 주문 대기표도 이벤트를 받아서 처리하는 별도 모듈/객체로 분리해서 구현한다.
  
- 매니저(Manager)는 음료를 확인하기 위해서 주문 대기표를 1초마다 확인한다. 

  - 주문이 있을 경우 작업이 비어있는 (제작할 수 있는) 바리스타에게 작업 이벤트를 전달한다.

- 바리스타(Barista)는 동시에 2개까지 음료를 만들 수 있다고 가정한다. 

  - Worker Thread가 아니라 이벤트 방식으로 동작해야 한다. 

  - 바리스타는 음료를 만들기 시작할 때와 끝날 때 마다 이벤트를 발생한다.

  - 이벤트가 발생할 때마다 음료 작업에 대한 로그를 출력한다.

- 매니저(Manager)는 바리스타가 보낸 특정 고객의 음료 제작 완료 이벤트를 받으면 현황판을 업데이트한다.

- 현황판(DashBoard)는 음료 주문 완성표를 주기적으로 화면에 출력한다.

  - 고객별로 음료수에 대해 대기중/제작중/완료 상태를 표시한다.

  - 현황판도 이벤트를 받아서 처리하는 별도 모듈/객체로 분리해서 구현한다.

- 아래 동작 예시는 이해를 돕기위한 예시일 뿐 동일하게 출력할 필요 없다. 각 요구사항을 확인하기 위해서 대기표, 현황판 등을 어떤 구조로 어떻게 구분해서 표시하는 게 적당한지 출력 형식을 고민한다.

#### 동작 예시

```
&gt; 메뉴  =  1. 아메리카노(3s)    2. 카페라떼(5s)    3. 프라프치노(10s)
&gt; 주문할 음료를 입력하세요. 예) 아메리카노 2개 =&gt; 1:2
&gt; 1:2
/1,1/
아메리카노 시작
&gt; 3:2
/1,3,3/
아메리카노 시작
&gt; 2:3
/3,3,2,2/
아메리카노 완성
/3,2,2/
프라프치노 시작
아메리카노 완성
/2,2/
프라프치노 시작
..........
프라프치노 완성
프라프치노 완성
/2/
카페라떼 시작
//
카페라떼 시작
...
카페라떼 완성
카페라떼 완성
모든 메뉴가 완성되었습니다.

```

### 2) 주문 완료 요구사항

- 프로그램을 시작할 때 바리스타 인원수를 지정할 수 있도록 구현한다. 

  - 프로그램이 시작하면 바리스타가 몇 명인지 출력한다. 

  - 주문 담당자와 매니저는 각각 1명이라고 가정한다.

- 주문 담당자는 음료 주문을 받을 때마다 한꺼번에 주문한 고객을 구분해야 한다. 

- 매니저는 바리스타가 보낸 음료 작업 완료 이벤트를 받아서 고객별로 주문 완성표를 업데이트한다.

- 바리스타가 3명 이상일 경우 담당하는 음료수를 분배하는 방식을 구현한다. 모든 바리스타가 모든 음료수를 만들지 않아야 한다.

  - 바리스타 4명, 주문 고객 9명 + 음료 30개를 주문했다고 가정하고 동작을 확인한다.

- 현황판에는 주문한 고객별로 주문한 음료를 모두 구분해서 표시해야 한다.

  - 고객이 주문한 모든 음료가 완성되면 각자 자기만의 방식으로 특별하게(?) 표시해서 출력한다.
ㅈ
- 모든 음료수를 만들고 나서 3초 동안 주문이 없으면 프로그램을 종료한다.

- 주문부터 제작 완료까지 이벤트 흐름을 그림으로 그려서, PR 보낼 때와 피어 컴파일링 요청할 때 함께 첨부한다.

#### 동작 예시

```
&gt; 바리스타는 총 2명입니다.
&gt; 메뉴  =  1. 아메리카노(3s)    2. 카페라떼(5s)    3. 프라프치노(10s)
&gt; 고객별로 주문할 음료 개수를 입력하세요. 예) A고객, 아메리카노 2개, 프라프치노 1개 =&gt; A, 1:2, 3:1
&gt; A, 1:1, 2:1
/A1,A2/
바리스타1-A아메리카노 시작
/A2/
&gt; B, 3:1, 2:1, 1:1
/A2,B3,B2,B1/
바리스타2-A카페라테 시작
/B3,B2,B1/
&gt; C, 3:1, 1:1
/B3,B2,B1,C3,C1/
바리스타1-B프라프치노 시작
/B2,B1,C3,C1/
바리스타2-B카페라떼 시작
/B1,C3,C1/
바리스타1-A아메리카노 완성
.
바리스타1-B아메리카노 시작
/C3,C1/
바리스타2-A카페라떼 완성
===== A, 아메리카노, 카페라떼 주문 완성
.
바리스타2-C프라프치노 시작
/C1/
바리스타1-B아메리카노 완성
바리스타2-B카페라떼 완성
.
바리스타2-C아메리카노 시작
//
..
바리스타2-C아메리카노 완성
.......
바리스타1-B프라프치노 완성
===== B, 아메리카노, 카페라떼, 프라프치노 주문 완성
.
바리스타2-C프라프치노 완성
===== C, 아메리카노, 프라프치노 주문 완성
&gt; 

모든 메뉴가 완성되었습니다.
```

### 3) Express 현황판

- 현황판(Dashboard)를 Node Express 기반으로 HTTP로 접근해서 확인할 수 있도록 한다.

- Express 패키지를 설치하고 9000 포트로 접속하면, `/` GET 요청을 받은 순간 현황판 상태를 JSON로 응답하도록 구현한다.

- `/${주문고객}` GET 요청을 받은 순간, 해당 주문 고객의 음료 주문 상태를 JSON로 응답하도록 구현한다.

## 배경 지식

### 비동기 병렬처리 

- 멀티 스레드 방식과 스레드에서 비동기 병렬 처리 방식에 대해 학습하고 정리한다.

- 동기 작업, 비동기 작업 처리 방식에 대해 비교하고 학습한다.

- 특정 스레드에서 이벤트 루프를 만들어서 각 이벤트를 전달하는 방식에 대해 학습한다.

- 비동기 작업을 동기화해서 기다리는 방식에 대해 학습한다.

- 비동기 작업을 그룹으로 묶어서 동기화하는 방식에 대해 학습한다.

## 학습정리

### 피어 컴파일링 체크포인트

```
  1. [ ] 바리스타 - 비동기 음료 제작 
  2. [ ] 음료 제작 - 비동기 이벤트 발생
  3. [ ] 매니저 - 주기적인 주문 확인
  4. [ ] 음료 주문 대기 큐 - 이벤트 처리
  5. [ ] 바리스타 인원 지정
  6. [ ] 고객별 여러 음료 주문 기능
  7. [ ] 고객별 주문 음료 현황판 출력
  8. [ ] 주문한 고객별로 전체 음료 완성 표시
  9. [ ] 바리스타 음료 제작 알고리즘 구현
  10. [ ] 이벤트 흐름에 대한 그림 설명
  11. [ ] Express 기반 현황판 전체 JSON 전송 구현
  12. [ ] Express 기반 고객별 JSON 전송 구현
```
  
### 스스로 확인할 사항

- Node.js 이벤트 루프와 이벤트 처리(Event Emitter) 방식에 대해 학습하고 정리한다.

- Day14에서 워커를 사용한 멀티 스레드 방식과 단일 스레드에서 비동기 병렬 처리 방식에 대해 비교해서 학습하고 정리한다.

### 다같이 확인할 사항

- Event-Bus 패턴에 대해 학습하고 주문 담당자, 매니저, 주문 대기표, 바리스타 관계를 비교한다. 

- Publish-subscribe 패턴에 대해 학습하고, 이벤트 처리 대신 구조에 적용할 수 있는지 확인한다.

- 만드는 데 4초가 걸리는 허브티와 15초가 걸리는 팥빙수를 추가하기 위한 구조와 코드를 토론한다.



--&gt;</content><author><name>이창권</name></author><summary type="html">Async Cafe 카페에서 동시에 여러 고객이 다양한 음료를 주문했을 때 주문해서 나올 때까지 여러 명의 바리스타 비동기 작업을 시뮬레이션하는 프로그램을 만들어보자 1. 코드 동작 이해 class간의 통신을 주로 event를 통해서 관리한다. &amp;gt; Manager.js const EventEmitter = require('events'); const Manager = class extends EventEmitter {//events모듈의 EventEmitter를 상속 constructor(){ super(); this.on('event', (parameters) =&amp;gt; { //이벤트를 받는 역할 ... }) } } &amp;gt; Baristar.js manager.emit('event', ...parameters);//manager의 이벤트를 발생시킨다. cashier는 command창에서 주문과 바리스타 수를 입력받아 manager객체를 생성하고 dashBoard와 orderQueue에 주문이 추가되었다라는 event를 발생시킨다. manager class 프로그램의 중심이 되는 역할을 한다. 1초간격으로 orderQueue를 관찰하여, baristar에게 일을 전달한다. baristar에게서 완료 이벤트를 받으면 orderQueue와 dashBoard에 event를 발생시킨다. Baristar class는 manager로부터 event를 통해 주문을 받으면 음료를 만드는 함수를 실행시키고 결과를 event로 다시 매니저에게 전달한다. OrderQueue class는 order를 queue형식으로 가지며, 현재 주문 상태를 관리한다. listner를 통해 Manager로부터 event를 받아 order를 추가, 삭제한다. DashBoard class는 listener를 통해 update, complete, start event 등을 받아 현재 상태를 출력하고, 현황판을 위해 현재 주문 상태를 json파일 형식으로 내보낸다. /server/index.js 는 9000번 포트를 열어 dashBoard가 만든 json파일을 불러와 /로 라우팅되면 모든 손님 상태를 /:customer로 라우팅 되면 해당 손님 상태를 보여준다 2. 코드 동작 개선 구현 시간 상, DashBoard class와 OrderQueue class에서 따로 주문을 관리하지만 사실 OrderQueue에서 관리를 하고 DashBoard에서는 property로 orderQueue를 가지는 것도 괜찮은 설계이다. 구현을 하다보니 global하게 쓰는 constant들이 많아졌는데, 따라 파일로 만들어서 가져오는 것이 효율적이다. baristar가 3명 이상일 때, major drink를 1개로 두었지만 2개로 두면 놀고 있는 바리스타들이 훨씬 줄어든다. 사실 baristar마다 priorityQueue를 가지게 해서 음료에 맞는 바리스타들을 선정하는 것이 제일 효율적이다. 설계 시, 후에 어떤 부분을 더 구현하게 될지 모르기 때문에 최대한 확장성이 좋고 재사용성이 좋게 짜는 것이 좋다. 3. Consideration 스스로 확인할 사항 Node.js 이벤트 루프와 이벤트 처리(Event Emitter) 방식에 대해 학습하고 정리한다. 이벤트 루프 노드에서 일어나는 모든 일은 어떤 이벤트에 대한 반응이다 이벤트루프는 Node.js를 실행시켜주는 것이다. 이벤트루프는 몇가지 단계들을 차례대로 반복하면서 순서대로 각 단계들의 작업들을 처리해나갑니다.(초록색 박스) Timer setTimeout/Interval에서 스케줄링된 모든 것이 처리된다 하지만 그 타이머 안에 등록한 콜백함수의 실행은 Polling 단계의 가장 앞부분에서 이루어진다 IO Callbacks TCP오류 같은 시스템 작업의 콜백을 반환한다 IO Polling Timers 단계에 스케줄링 되었던 콜백들 중에, 시간이 지난 타이머의 콜백을 실행합니다 그 다음, Poll 단계의 큐에 있는 이벤트들을 처리합니다. 대부분의 콜백들은 이 Poll 단계에서 처리됩니다 Set Immediate setImmediate()를 통해 등록된 모든 콜백을 실행됩니다. Close Events close 이벤트에 대한 모든 콜백 실행 이벤트 처리 방식(Event Emitter) Node.JS에 내장되어 있는 일종의 옵저버 패턴 구현 이벤트를 내보내는 모든 객체는 EventEmitter 클래스의 인스턴스다. EventEmitter 객체로 이벤트를 호출(emit)할 때, 해당 이벤트에 붙어 있는 모든 함수(listener)는 동기적으로 호출된다. 호출을 받은 리스너가 반환하는 결과는 어떤 값이든 무시되고 폐기된다. 메소드 종류로는 emit, on, once 등이 있다 Day14에서 워커를 사용한 멀티 스레드 방식과 단일 스레드에서 비동기 병렬 처리 방식에 대해 비교해서 학습하고 정리한다. 멀티 스레드 방식 바리스타의 작업을 웹 워커(스레드)를 생성해서 진행시킨다 웹 워커는 오래 걸리는 작업들(랜더링 작업)에 주로 사용된다. 단일 스레드 &amp;amp; 비동기 병렬 처리 방식 바리스타의 작업을 이벤트 호출을 통해 진행시킨다. 두 방식 모두 비동기로 진행되어서 오래 걸리는 작업에 Block 되는 일을 방지해준다. 다같이 확인할 사항 Event-Bus 패턴에 대해 학습하고 주문 담당자, 매니저, 주문 대기표, 바리스타 관계를 비교한다. 특정 채널을 통해 메시지가 메시지 버스를 통해 전달 되면, 리스너(listener)는 등록(subscribe)한 특정 채널에 해당하는 메시지를 이벤트로 받는 구조이다. 이벤트를 받는 것을 영어로 Event Notification이라고도 한다. 이벤트-버스 아키텍쳐 패턴(Event-bus Architectural pattern)은 고도로 분산화된 애플리케이션에 효과적이라고 할 수 있다. 반면, 모든 메시지가 동일한 이벤트 버스를 통해 전달되기 때문에 확장성 문제가 발생할 수 있다는 단점이 있다. 주문 담당자는 event source가 되고, 매니저는 event channel이 된다. 또한 바리스타는 event listener이다. Publish-subscribe 패턴에 대해 학습하고, 이벤트 처리 대신 구조에 적용할 수 있는지 확인한다. Pub-Sub 패턴은 여러가지 메시지 패턴 중 하나이다. Observe 패턴과 달리 구독자와 출판자의 등록 과정을 분리하여 의존성을 더욱 낮추고 있다. 이 때 Publisher와 Subscriber 사이의 역할을 Event Bus가 채워주게 된다. 발생한 이벤트에 따라 각각의 이벤트가 발생할 수 있으므로, Pub-Sub 패턴을 기존 구조에 적용할 수 있다. 만드는 데 4초가 걸리는 허브티와 15초가 걸리는 팥빙수를 추가하기 위한 구조와 코드를 토론한다. 기존의 코드 동작 과정에서 크게 달라지는 것이 없다. Queue에 저장되는 데이터의 type과 delay가 종류에 따라 추가되는 것 뿐이다. Manager에서는 Barista에게 Queue에 저장된 데이터를 보내게 되고, Barista는 해당 데이터에 따라 delay*1000ms 후에 동작을 하게 되므로 기존 동작과정에서 발생하는 문제는 없다. 단, 팥빙수는 다른 제조 과정보다 오랜 시간이 걸리기 때문에 팥빙수를 담당해서 만드는 바리스타가 있도록 설계하면 더 좋은 알고리즘으로 동작할 수 있을 것 같다.</summary></entry><entry><title type="html">부스트 캠프 Day14</title><link href="https://changgunyee.github.io/boost-camp/2019/08/06/boostCamp-Day14.html" rel="alternate" type="text/html" title="부스트 캠프 Day14" /><published>2019-08-06T00:00:00+09:00</published><updated>2019-08-06T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/08/06/boostCamp-Day14</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/08/06/boostCamp-Day14.html">&lt;h1 id=&quot;sync-cafe&quot;&gt;Sync Cafe&lt;/h1&gt;

&lt;p&gt;카페에서 음료를 주문했을 때 주문해서 나올때까지 바리스타가 하는 작업을 시뮬레이션하는 프로그램을 만들어보자&lt;/p&gt;

&lt;h2 id=&quot;1-코드-동작-이해&quot;&gt;1. 코드 동작 이해&lt;/h2&gt;
&lt;p&gt;cafe.js와 같이 html에서 load하는 script에서 manager thread를 생성하고,  입력을 받아, dom을 조작해 결과를 출력한다.&lt;br /&gt;
baristar는 thread로 여러개 생성된다. 음료 제작 함수와 sleep함수를 가지며 manager로부터 message가 오면 음료를 제작한다.&lt;br /&gt;
manager thread는 baristar pool을 관리한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;입력받은 주문을 queue에 넣어 관리한다.&lt;/li&gt;
  &lt;li&gt;입력받은 수 만큼 baristar thread를 구성하고 주문을 분배한다.&lt;/li&gt;
  &lt;li&gt;baristar로 부터 음료제작 완료 메세지를 받으면 주문 queue에서 주문을 하나 꺼내 다시 나누어 주는 형식으로 관리한다.&lt;/li&gt;
  &lt;li&gt;주문이 끝나면 baristar thread를 terminate한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-코드-동작-개선&quot;&gt;2. 코드 동작 개선&lt;/h2&gt;
&lt;p&gt;dom에 element를 추가하는 코드를 자주 사용한다면, 함수화해서 재사용성을 높이는 것이 좋다.&lt;br /&gt;
array를 queue로 사용할 때, splice보다는 shift함수를 쓰는 것이 더 효율적이며, 직관적이다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//아래 코드로 대체 가능하다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;함수의 목적에 맞게 코드가 들어가야 한다. Manager class의 init함수는 객체를 초기화 하는 함수이므로, executeBaristars는 init함수보다는 다른 곳에서 처리하는 것이 효율적이다.&lt;/p&gt;

&lt;h3 id=&quot;스스로-확인할-사항&quot;&gt;스스로 확인할 사항&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;멀티 스레드 스케줄링 방식에 대해 학습한다.&lt;/strong&gt;
선점 스케줄링&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;선점의 뜻은 다른 스레드가 현재 스레드가 실행 중일 때 자리를 뺏을 수 있다는 의미이다.&lt;/li&gt;
  &lt;li&gt;빠른 처리를 필요로하는 시스템에서 유용하다.&lt;/li&gt;
  &lt;li&gt;Round-Robin, Shortest Remaining Time, Multi Level Queue등이 해당한다.
비선점 스케줄링&lt;/li&gt;
  &lt;li&gt;모든 작업을 공정히 처리한다.&lt;/li&gt;
  &lt;li&gt;비선점형이므로 다른 스레드가 현재 스레드를 뺏을 수 없다.&lt;/li&gt;
  &lt;li&gt;First-In-First-Out(이번 미션에서 사용한 스케줄링 방식), Shortest-Job-First등이 이에 해당한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;스레드 동작 방식과 바리스타 작업 방식에 대해 비교한다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스레드는 개별적인 흐름을 가지고 실행된다. 즉, 다른 여러 스레드들과 동시에 실행된다는 의미이다.&lt;/li&gt;
  &lt;li&gt;이번에 구현한 바리스타 워커는 매니저 워커에 의해 실행되는 개별적인 동작 흐름이라는 점에서 스레드와 비슷한 역할을 한다.&lt;/li&gt;
  &lt;li&gt;하지만 실제 스레드는 프로세스내의 자원을 공유하지만 바리스타는 공유하지는 않는다.&lt;/li&gt;
  &lt;li&gt;실제 스레드와 비슷하게 동작하는 워커를 구현하려면 매니저 워커를 SharedWorker로 생성한 뒤 바리스타 워커를 생성하도록 하면 가능할 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Web Worker(또는 Worker Thread)에서 사용하지 않은 기능에 대해 학습한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;importScripts()를 이용하면 스레드에서도 다른 script를 사용할 수 있다.&lt;br /&gt;
기존의 Worker()대신 SharedWorker() 생성자를 사용하면 만들어진 스레드를 매니저들에서 공유해서 사용도 가능하다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SharedWorker로 만든 스레드는 port를 통해 통신해야 한다.&lt;/li&gt;
  &lt;li&gt;start, postMessage, onconnect와 같은 함수를 통해 스레드가 여러 매니저 역할을 하는 스레드들과 통신을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;setTimeout 내부 동작 방식에 대해 학습한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;setTimeout 은 일정 시간 뒤에 함수가 실행된다.&lt;br /&gt;
js 는 힙과 콜스택만 갖고 있어 하나의 한가지만 처리할 수 있다. 하지만 브라우저에서 WebAPI 를 제공해 setTimeout 기능을 처리한다. &lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;setTimeout은 call stack에 쌓이고 비동기적으로 동작하기 때문에 setTimeout의 Timer를 브라우저가 제공하는 webapi에 등록한다.&lt;/li&gt;
  &lt;li&gt;그리고 call stack에서 setTimeout은 사라지게 되고 webapi에 등록된 타이머는 동작하다가 입력한 시간이 끝났을 때 동작을 중지하고 콜백함수를 task queue로 전달한다.&lt;/li&gt;
  &lt;li&gt;queue는 FIFO의 구조로 동작하므로 먼저 들어온 함수가 우선권을 가진다.&lt;/li&gt;
  &lt;li&gt;task queue에서 대기중이던 콜백함수는 stack에 아무런 함수가 쌓이지 않았을 때 queue에서 빠져나와 call stack으로 넘어가 실행되게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-consideration&quot;&gt;3. Consideration&lt;/h2&gt;
&lt;h3 id=&quot;다같이-확인할-사항&quot;&gt;다같이 확인할 사항&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;setTimeout 이 외에 timer를 구현하기 위한 여러 방식에 대해 학습한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;setTimeout 으로 비동기적으로 timer 를 구현해 delay 를 설정할 수 있다.&lt;/li&gt;
  &lt;li&gt;하지만 비동기 방법 외적으로 동기적으로 timer 기능을 구현할 수 있다.
    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;멀티 스레드가 공용 리소스에 접근할 때 임계구역을 다루는 방식에 대해 학습한다. (Semaphore, Mutex 등)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;여러 스레드가 임계구역에 접근하여 데이터를 처리하는 것은 같은 예상치 못한 결과가 일어나 원자성을 만족하지 못하게 될 수 있으므로 중요하게 처리해야 되는 부분이다.&lt;/li&gt;
  &lt;li&gt;그렇기 때문에 이를 처리하는 방법들이 있는데 공통적으로 사용하는 방법이 해당 임계구역에 lock을 걸어서 다른 스레드에서 접근 하지 못하게 하는 방법이다.&lt;/li&gt;
  &lt;li&gt;그 방법으로 유명한 것이 Semaphore, Mutex이다.&lt;/li&gt;
  &lt;li&gt;Semaphore는 임계구역에 접근할 수 있는 스레드의 개수를 지정하여 해당 카운트 만큼의 스레드만 접근 할 수 있도록 하는 것이다. 세마포어는 뮤텍스가 될 수 있다.&lt;/li&gt;
  &lt;li&gt;Mutex는 해당 자원에 하나의 쓰레드만 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;멀티 스레드 작업을 그룹으로 묶어서 동기화하는 방식에 대해 학습한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;멀티 스레드 방식은 하나의 프로세스에서 여러 작업을 처리하는 방식이기 때문에 동일한 자원에 동시에 접근하는 일이 발생해 서로 다른 쓰레드가 데이터와 힙 영역을 공유해 여 엉뚱한 값을 읽어오거나 수정할 수 있다. &lt;br /&gt;
이런 문제점을 해결하기 위해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 동기화 작업이 필요하다.&lt;br /&gt;
방법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;임계영역&lt;/strong&gt;: 공유 리소스에 대해오직 하나의 스레드 접근만 허용(한 프로세스에 속한 스레드에만 사용 가능)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;뮤텍스(mutex)&lt;/strong&gt;: 공유 리소스에 대해 오직 하나의 스레드 접근만 허용(서로 다른 프로세스에 속한 스레드에도 사용 가능)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이벤트(event)&lt;/strong&gt; : 특정 사건 발생을 다른 스레드에게 알림&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;세마포(semaphore)&lt;/strong&gt; 한정된 개수의 자원을 여러 스레드가 사용하려고 할 때, 접근을 제한&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;대기 가능 타이머(waitable timer)&lt;/strong&gt; : 특정 시간이 되면 대기 중인 스레드를 깨움&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day14 Sync Cafe

## 왜 필요한가?
모든 현대 운영체제가 동작하는 기본 방식 중에서 프로세스와 스레드 스케줄링에 대한 이해는 프로그램 동작과 함께 코드가 어떤식으로 동작하는 지 이해하는 데 도움이 된다. 
특히 멀티 스레드 프로그래밍을 작성하기 위해서는 멀티 스레드를 어떻게 스케줄링하고, 컨텍스트를 이동하고, 어느 부분에서 병목 현상이 생기는 지 알고 있어야 한다. 

## 학습 목표
- 카페에서 음료를 주문했을 때 주문해서 나올때까지 바리스타가 하는 작업을 시뮬레이션하는 프로그램을 만드는 것이 목표다. 
- 이번 단계에서는 카페에서 여러 바리스타가 각각 동기 방식으로 음료를 만드는 것을 시뮬레이션하도록 구현한다.
- 매니저가 음료 주문을 큐에 담아 FIFO 방식으로 처리하도록 구현한다.
- HTML / DOM 이벤트 구조와 연결해서 웹 브라우저에서 자바스크립트 코드를 실행한다.

## 미션

### 1) 바리스타 요구사항

- 운영체제가 다루는 `프로세스`를 `카페 프로그램`으로 가정하고, `카페`내에 `바리스타`를 `스레드`라고 가정한다.

- 바리스타가 만들 수 있는 음료 종류를 3개 정하고, 음료마다 만드는 데 걸리는 시간을 초단위로 정한다.

	- 예) 아메리카노 : 3초, 카페라떼 : 5초, 프라프치노 : 10초

- 바리스타가 동시에 여러 음료를 만들 수 없고 한 번에 하나씩만 만들 수 있다고 가정한다.

- 바리스타는 음료를 만들기 시작하면 실수없이 해당 시간내에 반드시 완성한다고 가정한다. 

- 바리스타는 음료를 만들고 나서 곧 바로 다음 음료를 만들 수 있다고 가정한다.

- 프로그램을 시작하면 주문 가능한 메뉴를 표시하고, 주문할 전체 음료 개수를 입력받는다. 

- 바리스타는 음료 개수에 따라 작업 시간동안 잠들어있다가 깨어나면 작업을 완료하고, 해당 음료수를 출력한다. 

	- 바리스타 동작을 위해서 적절한 Timeout 기능을 구현해야 한다.

- 프로그램은 모든 음료수를 만들고 나면 종료한다.

- 동작 예시에 해당하는 결과를 HTML 상에서 볼 수 있도록 출력한다.

- 동작 예시에서 &quot;.&quot; 점은 초단위로 시간이 지나가는 것을 표현한 예시일 뿐, 출력 형식이 완벽하게 동일할 필요는 없다.

#### 입력 화면

&gt; 메뉴는 1. 아메리카노(3초) 2. 카페라떼(5초) 3. 프라프치노(10초) 3가지를 가진다.
&gt; 
&gt; 3가지 메뉴에 대해 HTML 화면에서 입력을 받는다.
&gt; 
&gt; [주문] 버튼을 추가하고, 버튼을 누르면 입력한 음료수 개수를 실행한다. 

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/step12-barista-view1.png&quot; width=&quot;300&quot;&gt;

#### 동작 예시
`아메리카노 2개, 카페라떼 3개, 프라프치노 2개`를 주문한 경우 출력 예시

```
...아메리카노 완료
...아메리카노 완료
.....카페라떼 완료
.....카페라떼 완료
.....카페라떼 완료
..........프라프치노 완료
..........프라프치노 완료

모든 메뉴가 완성되었습니다.
```

### 2) 카페 요구사항

- 운영체제가 다루는 `프로세스`를 `카페 프로그램`으로 가정하고, `카페`내에 `바리스타`를 `스레드`라고 가정한다.

- 프로그램을 시작할 때 바리스타 인원수를 지정할 수 있도록 개선한다. 입력 후에 바리스타 인원 몇 명인지 출력한다.

- 여러 바리스타를 관리하는 `카페 매니저`가 있다고 가정한다. 매니저도 웹 워커로 동작하도록 구현한다.

- 메뉴를 입력받으면 주문한 메뉴를 음료 주문 Queue에 저장한다. 

- 매니저는 음료 주문 Queue에서 밀린 음료를 대기중인 바리스타에게 요청해서 음료를 할당한다. 

- 바리스타는 정해진 작업 시간이 끝나서 음료를 만들고 나면, 완료 상태를 전달해서 다시 대기 상태로 등록한다. 
	- 일반적인 Pool 개념으로 동작한다.

- 프로그램은 모든 주문한 음료를 완성하고 나면 종료한다.

- 동작 예시에 해당하는 결과를 HTML 상에서 볼 수 있도록 출력한다. 

- 화면 구성과 출력 양식은 자신만의 스타일로 표현해도 된다.

#### 바리스타 입력 화면

&gt; 바리스타 인원수를 입력할 수 있도록 HTML을 변경한다.
&gt; 
&gt; [설정] 버튼을 추가하고, 버튼을 누르면 입력한 바리스타 인원수를 지정한다. 

```
&gt; 바리스타는 총 3명입니다.
&gt; 메뉴  =  1. 아메리카노(3s)    2. 카페라떼(5s)    3. 프라프치노(10s)
```
&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/step12-barista-view2.png&quot; width=&quot;400&quot;&gt;

#### 동작 예시

`아메리카노 2개, 카페라떼 3개, 프라프치노 2개`를 주문한 경우 출력 예시

```
바리스타1 - 아메리카노 완료
바리스타2 - 아메리카노 완료
바리스타3 - 카페라떼 완료
바리스타1 - 카페라떼 완료
바리스타2 - 카페라떼 완료
바리스타3 - 프라프치노 완료
바리스타1 - 프라프치노 완료

모든 메뉴가 완성되었습니다.
```

## 배경 지식

### 운영체제

- 주요 운영체제와 다음과 관련된 내용들을 학습하고 정리한다.

	- 프로세스를 관리하는 자료구조에 대해 학습한다.

	- 프로세스와 스레드의 관계에 대해 학습한다.

	- 운영체제에서 사용하는 작업 스케줄링 알고리즘에 대해 학습한다.

- 프로세스나 스레드가 만들어지고 종료될 때까지 스케줄러에 따라서 어떤 상태로 변화하는지 학습한다.

- 웹 워커(Web Worker)나 워커 스레드(Worker Thread) 대해 학습하고, 멀티 스레드 동작 구현에 대해 학습한다.

- Worker 나 Thread를 미리 만들어서 Pool 형태로 관리하는 방식에 대해 학습한다. 

- 웹 워커를 Pool로 관리하는 패키지를 찾아서 사용해도 된다. 단, 가져온 소스에 대해서는 꼭 출처와 라이센스를 명시한다.

## 학습정리

### 피어 컴파일링 체크포인트

```
  1. [ ] 바리스타 음료 제작 - 아메리카노
  2. [ ] 바리스타 음료 제작 - 카페라테
  3. [ ] 바리스타 음료 제작 - 프라프치노
  4. [ ] 음료 메뉴 주문 입력과 버튼
  5. [ ] 바리스타 Timer 구현
  6. [ ] 바리스타 인원수 입력과 버튼
  7. [ ] 음료 주문 대기 큐 
  8. [ ] 매니저 - 바리스타 Pool 작업 관리
  9. [ ] 음료 제작 - 서비스 워커 구현
  10. [ ] 음료 완료 HTML 표시
```

### 스스로 확인할 사항

- 멀티 스레드 스케줄링 방식에 대해 학습한다. 

- 스레드 동작 방식과 바리스타 작업 방식에 대해 비교한다.

- Web Worker(또는 Worker Thread)에서 사용하지 않은 기능에 대해 학습한다.

- setTimeout 내부 동작 방식에 대해 학습한다.

### 다같이 확인할 사항

- setTimeout 이 외에 timer를 구현하기 위한 여러 방식에 대해 학습한다.

- 멀티 스레드가 공용 리소스에 접근할 때 임계구역을 다루는 방식에 대해 학습한다. (Semaphore, Mutex 등)

- 멀티 스레드 작업을 그룹으로 묶어서 동기화하는 방식에 대해 학습한다.
--&gt;</content><author><name>이창권</name></author><summary type="html">Sync Cafe 카페에서 음료를 주문했을 때 주문해서 나올때까지 바리스타가 하는 작업을 시뮬레이션하는 프로그램을 만들어보자 1. 코드 동작 이해 cafe.js와 같이 html에서 load하는 script에서 manager thread를 생성하고, 입력을 받아, dom을 조작해 결과를 출력한다. baristar는 thread로 여러개 생성된다. 음료 제작 함수와 sleep함수를 가지며 manager로부터 message가 오면 음료를 제작한다. manager thread는 baristar pool을 관리한다. 입력받은 주문을 queue에 넣어 관리한다. 입력받은 수 만큼 baristar thread를 구성하고 주문을 분배한다. baristar로 부터 음료제작 완료 메세지를 받으면 주문 queue에서 주문을 하나 꺼내 다시 나누어 주는 형식으로 관리한다. 주문이 끝나면 baristar thread를 terminate한다. 2. 코드 동작 개선 dom에 element를 추가하는 코드를 자주 사용한다면, 함수화해서 재사용성을 높이는 것이 좋다. array를 queue로 사용할 때, splice보다는 shift함수를 쓰는 것이 더 효율적이며, 직관적이다. array.splice(0,1)//아래 코드로 대체 가능하다. array.shift() 함수의 목적에 맞게 코드가 들어가야 한다. Manager class의 init함수는 객체를 초기화 하는 함수이므로, executeBaristars는 init함수보다는 다른 곳에서 처리하는 것이 효율적이다. 스스로 확인할 사항 멀티 스레드 스케줄링 방식에 대해 학습한다. 선점 스케줄링 선점의 뜻은 다른 스레드가 현재 스레드가 실행 중일 때 자리를 뺏을 수 있다는 의미이다. 빠른 처리를 필요로하는 시스템에서 유용하다. Round-Robin, Shortest Remaining Time, Multi Level Queue등이 해당한다. 비선점 스케줄링 모든 작업을 공정히 처리한다. 비선점형이므로 다른 스레드가 현재 스레드를 뺏을 수 없다. First-In-First-Out(이번 미션에서 사용한 스케줄링 방식), Shortest-Job-First등이 이에 해당한다. 스레드 동작 방식과 바리스타 작업 방식에 대해 비교한다. 스레드는 개별적인 흐름을 가지고 실행된다. 즉, 다른 여러 스레드들과 동시에 실행된다는 의미이다. 이번에 구현한 바리스타 워커는 매니저 워커에 의해 실행되는 개별적인 동작 흐름이라는 점에서 스레드와 비슷한 역할을 한다. 하지만 실제 스레드는 프로세스내의 자원을 공유하지만 바리스타는 공유하지는 않는다. 실제 스레드와 비슷하게 동작하는 워커를 구현하려면 매니저 워커를 SharedWorker로 생성한 뒤 바리스타 워커를 생성하도록 하면 가능할 것이다. Web Worker(또는 Worker Thread)에서 사용하지 않은 기능에 대해 학습한다. importScripts()를 이용하면 스레드에서도 다른 script를 사용할 수 있다. 기존의 Worker()대신 SharedWorker() 생성자를 사용하면 만들어진 스레드를 매니저들에서 공유해서 사용도 가능하다. SharedWorker로 만든 스레드는 port를 통해 통신해야 한다. start, postMessage, onconnect와 같은 함수를 통해 스레드가 여러 매니저 역할을 하는 스레드들과 통신을 할 수 있다. setTimeout 내부 동작 방식에 대해 학습한다. setTimeout 은 일정 시간 뒤에 함수가 실행된다. js 는 힙과 콜스택만 갖고 있어 하나의 한가지만 처리할 수 있다. 하지만 브라우저에서 WebAPI 를 제공해 setTimeout 기능을 처리한다. setTimeout은 call stack에 쌓이고 비동기적으로 동작하기 때문에 setTimeout의 Timer를 브라우저가 제공하는 webapi에 등록한다. 그리고 call stack에서 setTimeout은 사라지게 되고 webapi에 등록된 타이머는 동작하다가 입력한 시간이 끝났을 때 동작을 중지하고 콜백함수를 task queue로 전달한다. queue는 FIFO의 구조로 동작하므로 먼저 들어온 함수가 우선권을 가진다. task queue에서 대기중이던 콜백함수는 stack에 아무런 함수가 쌓이지 않았을 때 queue에서 빠져나와 call stack으로 넘어가 실행되게 된다. 3. Consideration 다같이 확인할 사항 setTimeout 이 외에 timer를 구현하기 위한 여러 방식에 대해 학습한다. setTimeout 으로 비동기적으로 timer 를 구현해 delay 를 설정할 수 있다. 하지만 비동기 방법 외적으로 동기적으로 timer 기능을 구현할 수 있다. function sleep(delay) { const start = Date.now(); while (Date.now() &amp;lt; start + delay); } 멀티 스레드가 공용 리소스에 접근할 때 임계구역을 다루는 방식에 대해 학습한다. (Semaphore, Mutex 등) 여러 스레드가 임계구역에 접근하여 데이터를 처리하는 것은 같은 예상치 못한 결과가 일어나 원자성을 만족하지 못하게 될 수 있으므로 중요하게 처리해야 되는 부분이다. 그렇기 때문에 이를 처리하는 방법들이 있는데 공통적으로 사용하는 방법이 해당 임계구역에 lock을 걸어서 다른 스레드에서 접근 하지 못하게 하는 방법이다. 그 방법으로 유명한 것이 Semaphore, Mutex이다. Semaphore는 임계구역에 접근할 수 있는 스레드의 개수를 지정하여 해당 카운트 만큼의 스레드만 접근 할 수 있도록 하는 것이다. 세마포어는 뮤텍스가 될 수 있다. Mutex는 해당 자원에 하나의 쓰레드만 접근할 수 있다. 멀티 스레드 작업을 그룹으로 묶어서 동기화하는 방식에 대해 학습한다. 멀티 스레드 방식은 하나의 프로세스에서 여러 작업을 처리하는 방식이기 때문에 동일한 자원에 동시에 접근하는 일이 발생해 서로 다른 쓰레드가 데이터와 힙 영역을 공유해 여 엉뚱한 값을 읽어오거나 수정할 수 있다. 이런 문제점을 해결하기 위해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 동기화 작업이 필요하다. 방법 임계영역: 공유 리소스에 대해오직 하나의 스레드 접근만 허용(한 프로세스에 속한 스레드에만 사용 가능) 뮤텍스(mutex): 공유 리소스에 대해 오직 하나의 스레드 접근만 허용(서로 다른 프로세스에 속한 스레드에도 사용 가능) 이벤트(event) : 특정 사건 발생을 다른 스레드에게 알림 세마포(semaphore) 한정된 개수의 자원을 여러 스레드가 사용하려고 할 때, 접근을 제한 대기 가능 타이머(waitable timer) : 특정 시간이 되면 대기 중인 스레드를 깨움</summary></entry><entry><title type="html">부스트 캠프 Day13</title><link href="https://changgunyee.github.io/boost-camp/2019/08/05/boostCamp-Day13.html" rel="alternate" type="text/html" title="부스트 캠프 Day13" /><published>2019-08-05T00:00:00+09:00</published><updated>2019-08-05T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/08/05/boostCamp-Day13</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/08/05/boostCamp-Day13.html">&lt;h1 id=&quot;문법-분석기&quot;&gt;문법 분석기&lt;/h1&gt;

&lt;p&gt;자바스크립트에서 함수형프로그래밍과 객체지향 프로그래밍을 이용해보자&lt;/p&gt;

&lt;h2 id=&quot;1-코드-동작-이해&quot;&gt;1. 코드 동작 이해&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;tokenizer, lexer, parser는 각 함수의 결과 값을 인자로 받아서 동작한다.&lt;/li&gt;
  &lt;li&gt;tokenizer는 문자열을 &lt;code class=&quot;highlighter-rouge&quot;&gt;[ , ]&lt;/code&gt; 단위로 나누어 token으로 만들어 배열에 넣은 다음 반환한다.&lt;/li&gt;
  &lt;li&gt;lexer는 token의 내용을 확인하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;{type:?,value:?,child:[?]}&lt;/code&gt;의 object로 만들어 새로운 배열을 반환한다.&lt;/li&gt;
  &lt;li&gt;parser는 재귀나 dfs, stack을 이용하여 트리 구조로 재구성한다. 자신의 하위에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;[ ]&lt;/code&gt;의 내용을 child로 넣어 구조를 생성한 다음 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-코드-동작-개선&quot;&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기존의 compiler는 ast라는 추상트리구조를 사용하기 때문에, 기존의 compiler처럼 동작을 하기위해서는 tree class를 만들어 구현하는 것이 더 낫다.&lt;/li&gt;
  &lt;li&gt;tokenizer, lexer, parser의 역할에 맞게 error handling을 해주는 것이 더 낫다. 예를 들어 배열이 닫혔는지를 확인하는 error handling의 경우에는 parser가 구조를 파악하는 역할이기 때문에 parser에 넣어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스스로-확인할-사항&quot;&gt;스스로 확인할 사항&lt;/h3&gt;

&lt;p&gt;무한 중첩된 구조를 프로그래밍 하는데 효과적인 방법은 무엇인가? 재귀인가, 반복인가?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;두 방법 모두 장단점이 존재하지만 무한 중첩된 구조의 경우에서는 반복이 좋다고 생각한다.&lt;/li&gt;
  &lt;li&gt;재귀를 통해 콜스택에 축적되는 함수가 많아지면 stack overflow가 발생할 가능성이 올라가기 때문이다.&lt;/li&gt;
  &lt;li&gt;성능 면에서도 반복이 좋고 디버깅할때도 더 편하다는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;token, lexer, parser 역할을 나눠서 단계적으로 처리하고 있는가?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;tokenizer를 이용해 문자열을 의미 있는 부분으로 나눈다.&lt;/li&gt;
  &lt;li&gt;나눠진 token에 lexer로 의미를 부여한다.&lt;/li&gt;
  &lt;li&gt;parser로 token들을 구조화 시킨다.(tree형태)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;에러처리에 대한 흐름제어를 할 수 있는가?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;try-catch문을 이용해서 lexer, parser에서 발생하는 error를 처리할 수 있다.&lt;/li&gt;
  &lt;li&gt;특정 조건에서 throw를 이용해 error를 발생시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-consideration&quot;&gt;3. Consideration&lt;/h2&gt;
&lt;h3 id=&quot;다같이-확인할-사항&quot;&gt;다같이 확인할 사항&lt;/h3&gt;

&lt;p&gt;소프트웨어 개발에서, token, lexer, parser의 역할은 각각 무엇인지 조사해보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 프로그래밍 언어는 기계가 읽을 수 있는 언어로 번역하는 컴파일과정이 필요하다.&lt;/li&gt;
  &lt;li&gt;이 컴파일과정에서 token, lexer, parser가 소스코드의 구문분석 과정을 담당한다.&lt;/li&gt;
  &lt;li&gt;token은 소스코드를 의미있는 부분으로 나누는 역할을 한다. 이 과정에서 나눠진 token들은 테이블에 구조체 형식으로 저장되어 관리된다.&lt;/li&gt;
  &lt;li&gt;lexer는 token들에 의미를 부여한다. 이 과정을 통해 token들을 구조화할 수 있는 단위로 가공한다.&lt;/li&gt;
  &lt;li&gt;parser는 token들을 이용해 소스코드의 문법적인 구조를 정의하는 구문트리를 생성한다.&lt;/li&gt;
  &lt;li&gt;위와 같은 과정을 거치고 Semantic analysis(구조화 된 구문트리가 언어의 정의와 부합하는지 검사)과정을 거치고 기계가 읽을 수 있는 기계어나 어셈블리어로 변환되는 과정을 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 미션에서 구현한, token, lexer, parser의 각각 역할과 동작방식을 요약해서 설명해보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;token: 의미있는 단위로 쪼개는 역할을 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주어진 문자열을 최소한의 문자로 나누어서 배열에 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;lexer: 각각의 쪼개진 데이터에 의미를 부여한다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;token을 분석해서 {type:?,value:?,child:[]}와 같은 object형식으로 의미있게 재구성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;parser: 의미를 부여한 데이터를 구조화 시킨다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;lexer로 재구성된 데이터를 트리 형태로 구조화 시킨다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;오류 처리는 팀원 모두 생각에 따라 tokenizer, lexer, parser 에서 처리 했지만, 데이터의 의미를 부여할때(lexer) 문자열이 올바른지 판단하고, 데이터를 구조화할때 데이터가 올바른 구조인지 파악하여 에러처리를 하는 것이 좋다고 판단 되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--
# Day13 문법 분석기

## 왜 필요한가?
내가 구현한 프로그래밍 코드가 어떻게 해석되서 처리될까? 

컴파일러와 인터프리터, 파서등의 프로그램은 우리의 프로그램 코드를 해석하고 분석한다. 

이런 파싱과정을 약간이라도 이해하고나서 프로그래밍을 하면 더 효율적인 방법을 생각하게 된다. 



파서는 복잡한 프로그램분석 능력이 필요로한다.  

실무에서는 파서와 같은 복잡한 프로그램 분석과 같은 수준의 작업을 요구하는 경우가 많다. 

이런 프로그램 경험을 통해서 이를 완성해보도록 한다. 




## 학습 목표
- 문자열을 분석하고, 이를 구조화할 수 있다.
- 파싱과정을 이해한다.
- 복잡한 문제를 여러개의 객체와 함수로 나누고, 이를 연결지어 프로그래밍 할 수 있다.



----


## 미션

### 1. arrayParser 구현

- 배열형태의 문자열을 입력받아 이를 분석하는 프로그램을 만든다.
- JSON.parse 메서드를 사용할 수 없으며, 이와 유사한 파싱을 처리해주는 외부 라이브러리를 모두 사용할 수 없다.
- 배열안에는 **배열, 숫자, 문자열, NULL 타입**이 올 수 있다.
  - 배열안에 배열이 무한 중첩된 형태도 해석돼야 한다.   **ex) [[[[[….]]]]]**
- 정규표현식은 token을 **추출**하고 **분석**하기 위한 용도로 사용할 수 있다. (물론, 사용하지 않아도 된다)
- 단계별로 문제를 나눠서 처리한다. 
  - **tokenizer, lexer, parser 를 처리하는 메서드를 각각 만든다.**
- 함수의 역할이 커지지 않도록 하위함수로 나눈다.



**[실행결과]**

```javascript
const str = &quot;[1, [2,[3]],'hello world', null]&quot;;
const result = ArrayParser(str);
console.log(result); //최종결과인 result를 보기좋게 출력하기 위해 JSON.stringfiy(result)를 사용할 수 있음

{ type: 'array',
  child: 
   [ 
     { type: 'number', value: '1', child: [] },
     { type: 'array', child: [
		    { type: 'number', value: '2', child: [] },
        	{ type: 'array', child: [
		    	{ type: 'number', value: '3', child: [] },          
     		]},
     ]},
     { type: 'string', value: 'hello world', child: [] },
     { type: 'NULL', value: 'null', child: [] } 
   ] 
}

```



### 2. 에러처리

두 가지 에러처리를 한다. 

- 문자열이 제대로 닫히지 않았을때

- 배열이 제대로 안 닫혔을때



```javascript
const str = &quot;[[1,[2,[3],'hello world]]]&quot;;
const result = ArrayParser(str);
console.log(result); 

//ERROR : &quot;올바른 문자열형태가 아니네요&quot;
```



### 3. 테스트코드

**tokenizer, lexer, parser** 함수에 대한 테스트코드를 각각 구현한다. (총 3개의 테스트코드를 구현해야 함)

테스트를 위해서 원한다면 모든 테스트 라이브러리를 사용할 수 있다. 



------

## 배경 지식



#### 자바스크립트의 기본 문법위주에 대한 복습을 한다.

- 자바스크립트 배열과 객체의 이해
- es classes 문법
- 배열의 고차함수들 사용



#### Stack /  queue 그리고 재귀함수

- stack &amp; queue 에 대한 개념을 익힌다. 
- 재귀와 DFS와 같은 탐색방법



#### Tokenizer 를 활용한 문자열 분석

프로그래밍을 하다보면 AST라는 구조와 유사한 형태의 자료구조를 만들어야 할 때가 종종생긴다.

데이터를 분석하고 이를 tree구조로 만들기도 한다.

- **tokenizer, lexer, parser** 

  - 이 세가지는 순서대로 토큰화를 거치고 , 각 토큰의 어휘를 분석해서 의미를 부여하며,  문법을 체크한다.

  

#### throw, try~catch를 활용한 에러발생.

에러처리 방법을 익힌다. throw 를 던지면 상위함수에서 try-catch를 통해서 에러를 전달 받을 수 있다.



####정규표현식

JavaScript에서 정규표현식을 다루는  **test함수**, **match함수에** 대한 학습을 이해한다.

정규표현식 문법이 낯설다면, **이메일패턴이나 문자열패턴, 숫자패턴** 등을 정규표현식으로 어떻게 처리할 수 있는지 간단하게 학습한다.





-----


## 학습정리



### 피어 컴파일링 체크포인트

```
1. [  ] 다음 문자열을 실행해서 정상처리 확인 :  [1, [2,[3,[4,[5]]]],'hello world', null]
2. [  ] 다음 문자열을 실행해서 에러출력 확인(문자열관련오류).  : [[1,[2,[3],'hello world]]]  
3. [  ] tokenizer, lexer, parser 함수를 각각 구현
4. [  ] tokenizer, lexer, parser 함수에 대한 각각 테스트 코드 구현
```



### 스스로 확인할 사항

- 무한 중첩된 구조를 프로그래밍 하는데 효과적인 방법은 무엇인가? 재귀인가, 반복인가? 

- token, lexer, parser 역할을 나눠서 단계적으로 처리하고 있는가? 

- 에러처리에 대한 흐름제어를 할 수 있는가?

  


### 다같이 확인할 사항

- 소프트웨어 개발에서,  token, lexer, parser의 역할은 각각 무엇인지 조사해보자.
- 이번 미션에서 구현한,  token, lexer, parser의 각각 역할과 동작방식을 요약해서 설명해보자.

--&gt;</content><author><name>이창권</name></author><summary type="html">문법 분석기 자바스크립트에서 함수형프로그래밍과 객체지향 프로그래밍을 이용해보자 1. 코드 동작 이해 tokenizer, lexer, parser는 각 함수의 결과 값을 인자로 받아서 동작한다. tokenizer는 문자열을 [ , ] 단위로 나누어 token으로 만들어 배열에 넣은 다음 반환한다. lexer는 token의 내용을 확인하여 {type:?,value:?,child:[?]}의 object로 만들어 새로운 배열을 반환한다. parser는 재귀나 dfs, stack을 이용하여 트리 구조로 재구성한다. 자신의 하위에 있는 [ ]의 내용을 child로 넣어 구조를 생성한 다음 반환한다. 2. 코드 동작 개선 기존의 compiler는 ast라는 추상트리구조를 사용하기 때문에, 기존의 compiler처럼 동작을 하기위해서는 tree class를 만들어 구현하는 것이 더 낫다. tokenizer, lexer, parser의 역할에 맞게 error handling을 해주는 것이 더 낫다. 예를 들어 배열이 닫혔는지를 확인하는 error handling의 경우에는 parser가 구조를 파악하는 역할이기 때문에 parser에 넣어야 한다. 스스로 확인할 사항 무한 중첩된 구조를 프로그래밍 하는데 효과적인 방법은 무엇인가? 재귀인가, 반복인가? 두 방법 모두 장단점이 존재하지만 무한 중첩된 구조의 경우에서는 반복이 좋다고 생각한다. 재귀를 통해 콜스택에 축적되는 함수가 많아지면 stack overflow가 발생할 가능성이 올라가기 때문이다. 성능 면에서도 반복이 좋고 디버깅할때도 더 편하다는 장점이 있다. token, lexer, parser 역할을 나눠서 단계적으로 처리하고 있는가? tokenizer를 이용해 문자열을 의미 있는 부분으로 나눈다. 나눠진 token에 lexer로 의미를 부여한다. parser로 token들을 구조화 시킨다.(tree형태) 에러처리에 대한 흐름제어를 할 수 있는가? try-catch문을 이용해서 lexer, parser에서 발생하는 error를 처리할 수 있다. 특정 조건에서 throw를 이용해 error를 발생시킬 수 있다. 3. Consideration 다같이 확인할 사항 소프트웨어 개발에서, token, lexer, parser의 역할은 각각 무엇인지 조사해보자. 모든 프로그래밍 언어는 기계가 읽을 수 있는 언어로 번역하는 컴파일과정이 필요하다. 이 컴파일과정에서 token, lexer, parser가 소스코드의 구문분석 과정을 담당한다. token은 소스코드를 의미있는 부분으로 나누는 역할을 한다. 이 과정에서 나눠진 token들은 테이블에 구조체 형식으로 저장되어 관리된다. lexer는 token들에 의미를 부여한다. 이 과정을 통해 token들을 구조화할 수 있는 단위로 가공한다. parser는 token들을 이용해 소스코드의 문법적인 구조를 정의하는 구문트리를 생성한다. 위와 같은 과정을 거치고 Semantic analysis(구조화 된 구문트리가 언어의 정의와 부합하는지 검사)과정을 거치고 기계가 읽을 수 있는 기계어나 어셈블리어로 변환되는 과정을 수행한다. 이번 미션에서 구현한, token, lexer, parser의 각각 역할과 동작방식을 요약해서 설명해보자. token: 의미있는 단위로 쪼개는 역할을 한다. 주어진 문자열을 최소한의 문자로 나누어서 배열에 저장한다. lexer: 각각의 쪼개진 데이터에 의미를 부여한다. token을 분석해서 {type:?,value:?,child:[]}와 같은 object형식으로 의미있게 재구성한다. parser: 의미를 부여한 데이터를 구조화 시킨다. lexer로 재구성된 데이터를 트리 형태로 구조화 시킨다. 오류 처리는 팀원 모두 생각에 따라 tokenizer, lexer, parser 에서 처리 했지만, 데이터의 의미를 부여할때(lexer) 문자열이 올바른지 판단하고, 데이터를 구조화할때 데이터가 올바른 구조인지 파악하여 에러처리를 하는 것이 좋다고 판단 되었다.</summary></entry><entry><title type="html">부스트 캠프 Day12</title><link href="https://changgunyee.github.io/boost-camp/2019/08/01/boostCamp-Day12.html" rel="alternate" type="text/html" title="부스트 캠프 Day12" /><published>2019-08-01T00:00:00+09:00</published><updated>2019-08-01T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/08/01/boostCamp-Day12</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/08/01/boostCamp-Day12.html">&lt;h1 id=&quot;canvas&quot;&gt;Canvas&lt;/h1&gt;

&lt;p&gt;웹 브라우저를 비롯한 클라이언트 화면은 2차원 좌표시스템을 따르고 있다. 
2차원 좌표 시스템 상에 점, 선, 면, 텍스트, 이미지 등을 그리고 회전하고 이동하는 시스템에 대해 학습해 보자.&lt;/p&gt;

&lt;h2 id=&quot;코드-동작-이해&quot;&gt;코드 동작 이해&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;너비 600, 높이 400으로 캔버스를 생성하고 녹색으로 색칠한다.&lt;/li&gt;
  &lt;li&gt;좌측 상단에 흰색 배경색으로 circle을 그려 얼굴을 만든다.&lt;/li&gt;
  &lt;li&gt;동일한 반지름 크기로 원호를 그려 입을 만든다.&lt;/li&gt;
  &lt;li&gt;작은 반지름으로 눈 모양을 만든다.&lt;/li&gt;
  &lt;li&gt;지름과 같은 크기로 정사각형을 그려 몸통을 만들고 Gradient로 표현한다.&lt;/li&gt;
  &lt;li&gt;아랫 부분은 검정색 굵은 직선으로 다리 부분을 만들고 오른쪽 다리는 점선으로 변경한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;beginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
 &lt;span class=&quot;c1&quot;&gt;// -&amp;gt; 경로 그리기... &lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stroke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
 &lt;span class=&quot;c1&quot;&gt;//또는 ctx.fill()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;간단한 문자열을 얼굴 옆에 그리고 -330도 회전한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;translate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;450&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//중점으로 이동&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;330&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 회전&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;translate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;450&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 복귀 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;7개의 직선을 연결하여 화살표 모양을 만들고 화살표 좌측 아래를 기준으로 30도 회전한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;drawArrow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;beginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;moveTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillStyle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;gray&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;화살표 아래에는 유명한 미술작품 이미지를 몸통 정사각형 높이 혹은 너비와 같도록 이미지 비율을 맞춰서 그린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scaleImageSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;캔버스로 그린 것을 jpg 또는 png 이미지 파일로 저장한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;saveToImageFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createWriteStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__dirname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/9.png&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;stream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;canvas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createPNGStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;2-코드-동작-개선&quot;&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;canvas API의 다양한 사용법을 익힐 수 있었다.&lt;/li&gt;
  &lt;li&gt;파일을 저장하고 불러올 때, stream을 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;엄청 큰 데이터를 다룰 때나, 외부 소스로부터 데이터를 한번에 한 청크(chunk)씩 가져올때 stream을 사용해야 하며, 사용할 줄 알아야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-consideration&quot;&gt;3. Consideration&lt;/h2&gt;
&lt;h3 id=&quot;3-1-스스로-확인할-사항&quot;&gt;3-1. 스스로 확인할 사항&lt;/h3&gt;
&lt;h4 id=&quot;canvas-api-종류들에-대해-학습하고-정리한다&quot;&gt;CANVAS API 종류들에 대해 학습하고 정리한다.&lt;/h4&gt;

&lt;p&gt;Drawing Shapes&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기본적으로 beginPath()함수와 closePath(), arc(), moveTo(), lineTo(), fill()함수로 모든 것을 그릴 수가 있다.&lt;/li&gt;
  &lt;li&gt;편하게 사각형을 그릴 때 쓸 수 있는 함수가 존재한다.(fillRect()함수)
Drawing text&lt;/li&gt;
  &lt;li&gt;fillText(), strokeText()함수로 텍스트를 생성할 수 있다.
Using Images&lt;/li&gt;
  &lt;li&gt;new Image()로 Image객체를 생성해 받아온 이미지를 조작할 수 있다.&lt;/li&gt;
  &lt;li&gt;drawImage()함수의 인자 개수를 조절해 scaling, slicing을 할 수 있다.
Transformaitons&lt;/li&gt;
  &lt;li&gt;save(), restore()함수로 canvas의 현재상태를 저장하고 복원할 수 있다.&lt;/li&gt;
  &lt;li&gt;translate()함수로 canvas의 시작이 되는 origin좌표를 조절할 수 있다.&lt;/li&gt;
  &lt;li&gt;rotate(), transform(), scale()함수로 변형이 가능하다.
Animations&lt;/li&gt;
  &lt;li&gt;기존의 setInterval(),setTimeout()을 사용해도 되지만, requestAnimationFrame을 사용해서 만들 수도 있다.
Pixel manipulation&lt;/li&gt;
  &lt;li&gt;ImageData객체를 이용해 픽셀의 정보를 받아올 수 있고, 해당 픽셀에 대해 다양한 조작이 가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-다같이-확인할-사항&quot;&gt;3-2. 다같이 확인할 사항&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;SVG 개념에 대해 학습하고 CANVAS 2D API와 비교해서 정리한다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;canvas의 성능은 픽셀 수가 많을 경우(&amp;gt;10k)에 좋고, svg의 성능은 픽셀 수가 적을 경우(&amp;lt;10k)에 좋다.&lt;/li&gt;
  &lt;li&gt;canvas는 고성능의 애니메이션 작업이나 동영상 조작 등의 작업에 유리하고, svg는 고품질의 문서작업이나 정적 이미지의 조작에 유리하다.&lt;/li&gt;
  &lt;li&gt;canvas는 스크립트를 통해서만 작업이 가능하고, svg는 css를 통해서도 작업이 가능하다.&lt;/li&gt;
  &lt;li&gt;canvas는 픽셀(pixel) 기반이지만 svg는 모양(shape) 기반이다.&lt;/li&gt;
  &lt;li&gt;같은 픽셀의 화면에 같은 수의 점을 그리는 실험 시, canvas가 HTML이나 SVG보다 훨씬 빠르고 성능이 좋다. 특히 픽셀이 많아질 수록 그 차이는 훨씬 커지며 canvas가 월등히 좋은 성능을 보인다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.다양한 이미지 파일 포맷에 대해 학습하고 정리한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;BMP&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이미지 파일을 무손실 이미지로 저장이 가능하다.&lt;/li&gt;
  &lt;li&gt;‘반복 문자열 제거’ 압축 기법 때문에 호율이 좋지는 않다&lt;/li&gt;
  &lt;li&gt;따라서 용량은 크지만 호환성이 매우 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GIF&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 상에서 가장 널리 사용되는 이미지 포맷&lt;/li&gt;
  &lt;li&gt;Animation GIF로 움직이는 이미지로 주로 사용된다.&lt;/li&gt;
  &lt;li&gt;비손실 압축, 인덱스 컬러기반의 비트맵 이미지 파일 포멧&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JPEG&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;무손실 압축이 아니지만 하지만 효율적인 압축률을 보여준다.&lt;/li&gt;
  &lt;li&gt;손실은 있지만 원본 이미지와 차이가 크지 않기 때문에 가장 대중적인 포맷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PNG&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GIF를 대체하기 위해 만들어진 오픈소스 파일 포맷이다.(특허 관련 문제)&lt;/li&gt;
  &lt;li&gt;JPEG와 비교해서 무손실 압축이기 때문에 비슷한 색이 넓게 사용될 때 유리하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
  # Day12 Canvas

## 왜 필요한가?
웹 브라우저를 비롯한 클라이언트 화면은 2차원 좌표시스템을 따르고 있다. 
2차원 좌표 시스템 상에 점, 선, 면, 텍스트, 이미지 등을 그리고 회전하고 이동하는 시스템에 대해 학습해야 자유롭게 표시할 수 있다.

## 학습 목표
- 2D 그래픽스와 캔버스에 대한 기초 지식에 대해 학습한다.
- 캔버스에 직접 점, 선, 면, 텍스트를 그리고, 회전하고 이동하는 변환 동작을 구현하는 것이 목표다.
- 색상 개념을 이해하고 Gradient로 색칠하도록 구현하는 것이 목표다.

## 미션

#### 1) Background 요구사항

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/step19-1.canvas.png&quot; width=&quot;500&quot;&gt;

- 가로 600 x 세로 400 캔버스를 생성한다.

- 캔버스 배경 색상을 녹색으로 가득 색칠한다.

- 좌측 상단에 흰색 배경색으로 Circle을 그린다.

- 동일한 반지름 크기로 Pie를 그리고 내부만 검정색으로 색칠한다.

- 작은 반지름으로 눈 모양을 그린다.

- 지름과 같은 크기로 정사각형을 그리고 흰색으로 색칠한다.

- 아랫 부분은 검정색 굵은 직선으로 다리 부분을 그린다.

- 캔버스로 그린 것은 jpg 또는 png 이미지 파일로 저장한다.

#### 2) Text 요구사항

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/step19-2.canvas.png&quot; width=&quot;500&quot;&gt;


- 앞 단계에서 입 부분 Pie 부분을 남색으로 변경한다.

- 몸통 부분은 Gradient로 두 가지 색을 사용해서 점진적으로 색칠한다.

- 아랫 부분 오른쪽 다리는 실선에서 점선으로 변경한다.

- 간단한 문자열을 원 앞에 그린다. 문자열 색상을 지정한다.

### 3) Transform 요구사항

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/step19-3.canvas.png&quot; width=&quot;500&quot;&gt;

- 문자열을 문자열 중점을 기준으로 -330도 회전한다.

- 우측에 직선 7개를 연결해서 ⇨ 화살표 모양을 그린다. 내부는 회색으로 색칠한다.

- 화살표는 화살표 좌측 아래를 기준으로 30도 회전한다.

- 화살표 아래에는 유명한 미술작품 이미지를 좌측 정사각형 높이 혹은 너비와 같도록 이미지 비율을 맞춰서 그린다. 만약 세로 그림이면 좌우가 여백이 생기고, 가로 그림이면 위아래가 여백이 생긴다.

## 배경 지식

- 수학 2차원 직교 좌표시스템과 해당 그래픽 시스템 좌표시스템 차이에 대해 학습한다.

- 2차원 좌표시스템에서 점, 선, 도형, 텍스트, 이미지 등을 표시하는 방법을 학습한다.

- 2차원 좌표시스템에서 좌표를 translate, scale, rotate 하는 방법과 Affine Transform 으로 변환시키는 방법을 학습한다.

- 2D 그래픽스 그리기 동작을 위한 캔버스 관련 API에 대해 학습한다.

- Javascript + Web Canvas API 표준과 node 기반 구현 자료를 학습한다.
  

## 학습정리

### 피어 컴파일링 체크포인트

```
  1. [ ] 캔버스 배경색 색칠
  2. [ ] 얼굴 모양 - 원 그리기
  3. [ ] 입모양 - 원호 그리기
  4. [ ] 눈모양 - 원 그리기
  5. [ ] 몸통 - 사각형 + 그라데이션 색칠
  6. [ ] 다리 - 실선과 점선 그리기
  7. [ ] 말풍선 - 텍스트 및 rotate 회전
  8. [ ] 화살표 - closed path 그리기 및 회전
  9. [ ] 미술작품 - 이미지 비율에 맞춰 그리기
  10. [ ] 이미지 파일 저장 기능
```

### 스스로 확인할 사항

- CANVAS API 종류들에 대해 학습하고 정리한다.

### 다같이 확인할 사항

- SVG 개념에 대해 학습하고 CANVAS 2D API와 비교해서 정리한다.
- 다양한 이미지 파일 포맷에 대해 학습하고 정리한다.
--&gt;</content><author><name>이창권</name></author><summary type="html">Canvas 웹 브라우저를 비롯한 클라이언트 화면은 2차원 좌표시스템을 따르고 있다. 2차원 좌표 시스템 상에 점, 선, 면, 텍스트, 이미지 등을 그리고 회전하고 이동하는 시스템에 대해 학습해 보자. 코드 동작 이해 너비 600, 높이 400으로 캔버스를 생성하고 녹색으로 색칠한다. 좌측 상단에 흰색 배경색으로 circle을 그려 얼굴을 만든다. 동일한 반지름 크기로 원호를 그려 입을 만든다. 작은 반지름으로 눈 모양을 만든다. 지름과 같은 크기로 정사각형을 그려 몸통을 만들고 Gradient로 표현한다. 아랫 부분은 검정색 굵은 직선으로 다리 부분을 만들고 오른쪽 다리는 점선으로 변경한다. ctx.beginPath() // -&amp;gt; 경로 그리기... ctx.stroke() //또는 ctx.fill() 간단한 문자열을 얼굴 옆에 그리고 -330도 회전한다. ctx.translate(450, 70); //중점으로 이동 ctx.rotate((Math.PI/180)*330); // 회전 ctx.translate(-450,-70); // 복귀 7개의 직선을 연결하여 화살표 모양을 만들고 화살표 좌측 아래를 기준으로 30도 회전한다. function drawArrow(x, y) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 70, y); ctx.lineTo(x + 70, y - 20); ctx.lineTo(x + 120, y + 10); ctx.lineTo(x + 70, y + 40); ctx.lineTo(x + 70, y + 20); ctx.lineTo(x, y + 20); ctx.lineTo(x, y); ctx.fillStyle = 'gray'; ctx.fill(); } 화살표 아래에는 유명한 미술작품 이미지를 몸통 정사각형 높이 혹은 너비와 같도록 이미지 비율을 맞춰서 그린다. function scaleImageSize(img, x, y, len) { let width, height; if (img.width &amp;gt; img.height) { width = len; height = img.hight * len / img.width; return [x, y + (len - height) / 2, width, height]; } else { width = img.width * len / img.height; height = len; return [x + (len - width) / 2, y, width, height]; } } 캔버스로 그린 것을 jpg 또는 png 이미지 파일로 저장한다. function saveToImageFile() { const out = fs.createWriteStream(__dirname + '/9.png'); const stream = canvas.createPNGStream(); stream.on('data', function (chunk) { out.write(chunk); }); } 2. 코드 동작 개선 canvas API의 다양한 사용법을 익힐 수 있었다. 파일을 저장하고 불러올 때, stream을 사용할 수 있다. 엄청 큰 데이터를 다룰 때나, 외부 소스로부터 데이터를 한번에 한 청크(chunk)씩 가져올때 stream을 사용해야 하며, 사용할 줄 알아야 한다. 3. Consideration 3-1. 스스로 확인할 사항 CANVAS API 종류들에 대해 학습하고 정리한다. Drawing Shapes 기본적으로 beginPath()함수와 closePath(), arc(), moveTo(), lineTo(), fill()함수로 모든 것을 그릴 수가 있다. 편하게 사각형을 그릴 때 쓸 수 있는 함수가 존재한다.(fillRect()함수) Drawing text fillText(), strokeText()함수로 텍스트를 생성할 수 있다. Using Images new Image()로 Image객체를 생성해 받아온 이미지를 조작할 수 있다. drawImage()함수의 인자 개수를 조절해 scaling, slicing을 할 수 있다. Transformaitons save(), restore()함수로 canvas의 현재상태를 저장하고 복원할 수 있다. translate()함수로 canvas의 시작이 되는 origin좌표를 조절할 수 있다. rotate(), transform(), scale()함수로 변형이 가능하다. Animations 기존의 setInterval(),setTimeout()을 사용해도 되지만, requestAnimationFrame을 사용해서 만들 수도 있다. Pixel manipulation ImageData객체를 이용해 픽셀의 정보를 받아올 수 있고, 해당 픽셀에 대해 다양한 조작이 가능하다 3-2. 다같이 확인할 사항 SVG 개념에 대해 학습하고 CANVAS 2D API와 비교해서 정리한다. canvas의 성능은 픽셀 수가 많을 경우(&amp;gt;10k)에 좋고, svg의 성능은 픽셀 수가 적을 경우(&amp;lt;10k)에 좋다. canvas는 고성능의 애니메이션 작업이나 동영상 조작 등의 작업에 유리하고, svg는 고품질의 문서작업이나 정적 이미지의 조작에 유리하다. canvas는 스크립트를 통해서만 작업이 가능하고, svg는 css를 통해서도 작업이 가능하다. canvas는 픽셀(pixel) 기반이지만 svg는 모양(shape) 기반이다. 같은 픽셀의 화면에 같은 수의 점을 그리는 실험 시, canvas가 HTML이나 SVG보다 훨씬 빠르고 성능이 좋다. 특히 픽셀이 많아질 수록 그 차이는 훨씬 커지며 canvas가 월등히 좋은 성능을 보인다. 2.다양한 이미지 파일 포맷에 대해 학습하고 정리한다. BMP 이미지 파일을 무손실 이미지로 저장이 가능하다. ‘반복 문자열 제거’ 압축 기법 때문에 호율이 좋지는 않다 따라서 용량은 크지만 호환성이 매우 좋다. GIF 웹 상에서 가장 널리 사용되는 이미지 포맷 Animation GIF로 움직이는 이미지로 주로 사용된다. 비손실 압축, 인덱스 컬러기반의 비트맵 이미지 파일 포멧 JPEG 무손실 압축이 아니지만 하지만 효율적인 압축률을 보여준다. 손실은 있지만 원본 이미지와 차이가 크지 않기 때문에 가장 대중적인 포맷 PNG GIF를 대체하기 위해 만들어진 오픈소스 파일 포맷이다.(특허 관련 문제) JPEG와 비교해서 무손실 압축이기 때문에 비슷한 색이 넓게 사용될 때 유리하다.</summary></entry><entry><title type="html">부스트 캠프 Day11</title><link href="https://changgunyee.github.io/boost-camp/2019/07/31/boostCamp-Day11.html" rel="alternate" type="text/html" title="부스트 캠프 Day11" /><published>2019-07-31T00:00:00+09:00</published><updated>2019-07-31T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/31/boostCamp-Day11</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/31/boostCamp-Day11.html">&lt;h1 id=&quot;day11-콜스택--이벤트-큐&quot;&gt;Day11 콜스택 &amp;amp; 이벤트 큐&lt;/h1&gt;

&lt;p&gt;자바스크립트는 동기적인 프로그램 실행과, 비동기적인 프로그램 실행으로, 프로그램의 효율적이고 빠른 동작을 가능하게 한다.
이를 위해 call stack과 event queue의 동작 관계를 이해한다.&lt;/p&gt;

&lt;h2 id=&quot;코드-동작-이해&quot;&gt;코드 동작 이해&lt;/h2&gt;
&lt;h4 id=&quot;전반적인-구조&quot;&gt;전반적인 구조&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;callStack 배열에 담긴 함수들은 스택 구조로 역순으로 실행되며 eventQueue의 경우 큐 구조로 순서대로 callStack 배열에 push한다.&lt;/li&gt;
  &lt;li&gt;executeEventQueue()와 executeCallStack()는 계속 실행되는 함수이고 callStack에 더 이상 실행해야할 함수가 없다면 executeCallStack()는 종료된다.&lt;/li&gt;
  &lt;li&gt;비동기적으로 계속 실행되는 함수를 만들기 위해 setTimeout()나 setInterval()를 이용한다.&lt;/li&gt;
  &lt;li&gt;callStack 배열이 비어있기 시작한 시간부터 5초가 지나도 callStack이 계속해서 비어있는 상태이면 종료되는 로직을 구현해본다.
    &lt;h4 id=&quot;구현한-함수들&quot;&gt;구현한 함수들&lt;/h4&gt;
    &lt;p&gt;runSync함수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Date객체를 사용해서 2초 후 실행하게 처리
executeEventQueue함수&lt;/li&gt;
  &lt;li&gt;callStack과 eventQueue를 매개변수로 받아 callStack이 비어있을 때 eventQueue에 있는 작업들을 하나씩 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;executeEventQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;eventQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;eventQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                      &lt;span class=&quot;nx&quot;&gt;eventQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]();&lt;/span&gt;
                      &lt;span class=&quot;nx&quot;&gt;eventQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;executeCallStack함수&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;callStack에 있는 함수를 역순으로 하나씩 pop해 실행하도록 구현&lt;/li&gt;
  &lt;li&gt;callStack에 더이상 실행해야할 함수가 없다면 5초 후 종료되도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;executeCallStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
              &lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;interval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                  &lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;nx&quot;&gt;clearTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;nx&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;nx&quot;&gt;clearInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                  &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-코드-동작-개선&quot;&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;p&gt;setInterval함수를 쓰지 않고 setTimeout만으로도 구현이 가능하다.
executeEventQueue함수와 executeCallStack함수가 서로의 함수를 호출하는 형식으로 재귀적으로도 구현이 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;3-consideration&quot;&gt;3. Consideration&lt;/h2&gt;
&lt;h4 id=&quot;3-1-스스로-확인할-사항&quot;&gt;3-1. 스스로 확인할 사항&lt;/h4&gt;
&lt;p&gt;실제 call stack과 event queue동작을 충분히 이해하고, 이를 코드로 구현한 것인지 확인한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;원래 Task Queue에 있는 task를 callStack으로 이동시킨다음 실행하지만, 현재 나의 코드는 TaskQueue에 있는 task를 TaskQueue에서 바로 실행한다.&lt;/li&gt;
  &lt;li&gt;하지만 Task Queue에 있는 task를 callStack으로 옮겨 실행시키면, 예시처럼 작동은 하지만 원래의 task queue나 call stack의 작업처럼 행동하지 않는다(setTimeout때문)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-2-다같이-확인할-사항&quot;&gt;3-2. 다같이 확인할 사항&lt;/h4&gt;
&lt;p&gt;자바스크립트 비동기에 대해서 이해하기 위해서, call stack과 event queue, event loop에 대해서 글로 정리한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CallStack은 프로그램 내의 함수들을 담고있는 자료구조이다.&lt;/li&gt;
  &lt;li&gt;함수를 호출할 때 마다 해당 함수를 CallStack에 넣는다.&lt;/li&gt;
  &lt;li&gt;실행이 종료가 되면 CallStack에서 제거된다.&lt;/li&gt;
  &lt;li&gt;Task queue는 자바스크립트 런타임 messaging queue이다.&lt;/li&gt;
  &lt;li&gt;다른 Web Apis에 할당된 Task를 관리하여 줍니다.&lt;/li&gt;
  &lt;li&gt;Web Apis의 콜백 함수들을 가지고 있으며 call stack이 비어있다면 전달이 진행된다.&lt;/li&gt;
  &lt;li&gt;Event loop은 call stack이 비었는지 확인한 다음, task queue가 진행할 기다리고있는 작업을 가지고 있는지 확인한다.&lt;/li&gt;
  &lt;li&gt;만약 그렇다면 해당 태스크를 queue에서 꺼내 call stack으로 넘깁니다. 이후에 call stack에서 해당 태스크를 진행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 
# Day11 콜스택 &amp; 이벤트 큐

## 왜 필요한가?
자바스크립트는 동기적인 프로그램 실행과, 비동기적인 프로그램 실행으로, 프로그램의 효율적이고 빠른 동작을 가능하게 한다.

비동기적인 동작의 흐름에 대한 충분한 이해를 통해 보다 좋은 자바스크립트 프로그래밍이 가능하다.




## 학습 목표
- call stack과 event queue의 동작 관계를 이해한다.



----

## 미션



### 프로그램 제약조건)

- 전역변수를 추가하면 안된다.
- async/await, promise를 사용할 수 없다.
- eventEmitter와 같은 비동기 모듈을 사용할 수 없다.
- **setTimeout은 사용할 수 있음**



### 1. 2초 동안 실행되는 함수 구현 

runSync는 수행시간이 2초이다. 다시말해 함수의 실행시작부터 반환까지 2초가 걸린다.

runSync함수 구현시, 위 프로그램 제약조건뿐 아니라 **setTimeout도 사용할 수 없다**.

```javascript
function runSync(id) {
   //여기에 구현
}

runSync(1) 
runSync(3)
```



**[실행결과]**

```shell
1 sync 함수 실행    //최초실행 이후 2초 뒤에 출력
3 sync 함수 실행    //윗줄 이후 2초 뒤에 출력
```





### 2.  Call Stack과 Event Queue의 구현

Call stack(JS Stack)과 Event-Queue 동작을 흉내내는 코드를 구현한다.

**executeCallStack과 executeEventQueue 함수를 완성**해서, 원하는 결과를 출력하도록 한다. 

```javascript
function runSync(id) {
 //위에서 구현한 코드
}

//runAsync 함수는 수정하지 않는다.
function runAsync(id) {
  console.log(id + &quot; async 함수 실행&quot;);
}


//executeEventQueue는 callstack이 비워지면, eventQueue에 있는 함수가 순서대로 실행되도록 구현한다.
//executeEventQueue는 종료되지 않고 계속 실행되는 프로그램이다.
function executeEventQueue() {
  //.......
}

//executeCallStack은 callstack에 있는 함수가 역순으로 실행되도록 구현한다.
//executeCallStack은 종료되지 않고 계속 실행되는 프로그램이다.
//하지만 callstack에 더이상 실행해야할 함수가 없다면 종료되야 한다.
function executeCallStack() {
  //.......
}

//이부분은 수정하지 않는다. 
//callStack과 eventQueue의 갯수는 1개 이상 n개일 수 있다.
let callStack = [runSync.bind(null, 1), runSync.bind(null, 2)];
let eventQueue = [runAsync.bind(null, 1),runAsync.bind(null, 2),runAsync.bind(null, 3)];

//프로그래밍 실행 예시
//구현방법에 따라서, executeEventQueue,executeCallStack 실행시 필요한 인자는 아래와 다를 수 있다.
executeEventQueue(callStack, eventQueue);
executeCallStack(callStack);
callStack.push(runSync.bind(null, 3));
```



**[실행결과]**

sync에 있는 내용이 먼저 모두 나온후에, async내용이 노출된다.

```shell
2 sync 함수 실행    //최초실행 이후 2초 뒤에 출력
1 sync 함수 실행    //윗줄 이후 2초 뒤에 출력
3 sync 함수 실행    //윗줄 이후 2초 뒤에 출력
1 async 함수 실행   //윗줄 이후 즉시 출력
2 async 함수 실행   //윗줄 이후 즉시 출력
3 async 함수 실행   //윗줄 이후 즉시 출력
```



### 3. 특정 시간 이후 프로그램 종료

callstack이 비워진 채로, **5초가 흐르면 프로그램은 자동 종료**된다.

```javascript
//프로그래밍 실행 예시
//구현방법에 따라서, executeEventQueue,executeCallStack 실행시 필요한 인자는 아래와 다를 수 있다.
executeEventQueue(callStack, eventQueue);
executeCallStack(callStack);
callStack.push(runSync.bind(null, 3));
setTimeout(()=&gt;callStack.push(runSync.bind(null, 4)), 6000);
setTimeout(()=&gt;callStack.push(runSync.bind(null, 5)), 20000);
```



**[실행결과]**

'4 sync함수 실행'은 프로그램 실행 부터 12초 뒤에 출력된다. (정확한 확인을 하려면 console.time 함수를 활용할 수 있다)

'4 sync함수 실행'이 출력된 후 5초 뒤에 프로그램은 자동 종료된다.  따라서 '5 sync함수 실행'은 출력될 수 없다.

```shell
2 sync함수 실행
1 sync함수 실행
3 sync함수 실행
1 async함수 실행
2 async함수 실행
3 async함수 실행
4 sync함수 실행  //프로그램 실행 후 12초 뒤에 출력되야 함
//5초뒤에 프로그램 자동종료
```



### 4. 글쓰기, 정리

자바스크립트 비동기에 대해서 이해하기 위해서, **call stack과 event queue, event loop**에 대해서 글로 정리한다.

Markdown 형식으로 정리한다.

**jsasync.md** 파일로 정리해서 commit 한다.

분량은 한페이지 또는 그 이상으로 작성한다.



------

## 배경 지식

### 동기(synchronous)

```javascript
const baseData = [1,2,3,4,5,6,100];

baseData.forEach((v,i) =&gt; {
    console.log(&quot;sync &quot;, i);
});

baseData.forEach((v,i) =&gt; {
    console.log(&quot;sync 2&quot;, i);
});

```

동기적인 흐름은 순서대로 실행될 뿐이다. 원활한 프로그램 흐름을 유지해야 함으로 순서가 바뀔 수 없다.



------

### call stack

개발자도구의 call stack으로 확인해보기.

```Javascript
const baseData = [1,2,3,4,5,6,100];

function foo() {
  baseData.forEach((v,i) =&gt; {
    console.log(&quot;sync &quot;, i);
    bar();
  });
}

function bar() {
  baseData.forEach((v,i) =&gt; {
    //debugger;
    console.log(&quot;sync 2&quot;, i);
  });
}
```

**call stack이 쌓이는 것을 시각적으로 표현해보라!**



------

### setTimeout과 비동기

만약 setTIme이 동기적으로 실행되면 어떻게 돼지? 

```javascript
setTimeout( ()=&gt;console.log(10), 10000);
```



setTimeout함수의 callback 함수는 함수의 인자로 들어가서, 즉시 또는 나중에 실행되는 녀석이다.

어떻게 동작하는 걸까?  설명해보자.



------

### callstack &amp; callback queue(event queue)

&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*FA9NGxNB6-v1oI2qGEtlRQ.png&quot; width=&quot;600px&quot;&gt;

- call stack 그리고, callback queue(또는 event queue)
- event loop를 통해서 callback queue에 있는 callback함수들이 stack으로 올라감.



------

### 동기-비동기 순서 이해하기

결과값을 예상해보자. 

```javascript
function plus() {
  let a = 1;
  setTimeout( ()=&gt;console.log(++a), 1000);
  return a;
}

const result = plus();
console.log('result :', result);  //?
```



------

### 비동기 상황 예

```javascript
const baseData = [1,2,3,4,5,6,100];

const asyncRun = (arr, fn) =&gt; {
 for(var i=0; i&lt;arr.length; i++) {
   setTimeout( () =&gt; fn(i), 1000);
 }
}

asyncRun(baseData, idx =&gt;console.log(idx));
```





------

### 비동기 상황 예 - forEach로 변경해보자.

```javascript
const baseData = [1,2,3,4,5,6,100];

const asyncRun = (arr, fn) =&gt; {
   arr.forEach((v,i) =&gt; {
     setTimeout( () =&gt; fn(i), 1000);
   });
}
asyncRun(baseData, idx =&gt;console.log(idx))
```





------

### 비동기 상황 예 - 동기 + 비동기  + 동기 

```javascript
const baseData = [1,2,3,4,5,6,100];

function sync() {
  baseData.forEach((v,i) =&gt; {
    console.log(&quot;sync &quot;, i);
  });
}

const asyncRun = (arr, fn) =&gt; {
   arr.forEach((v,i) =&gt; {
     setTimeout( () =&gt; fn(i), 1000);
   });
}
 

function sync2() {
  baseData.forEach((v,i) =&gt; {
    console.log(&quot;sync 2 &quot;, i);
  });
}

asyncRun(baseData, idx =&gt;console.log(idx))
sync();
sync2();
```





------

### 비동기 상황 예 - 비동기 + 비동기

순서를 예상해보기.

call stack과 callback queue를 상상하자.

```javascript
const baseData = [1,2,3,4,5,6,100];

const asyncRun = (arr, fn) =&gt; {
   arr.forEach((v,i) =&gt; {
     setTimeout(() =&gt; {
       setTimeout(() =&gt; {
         console.log(&quot;cb 2&quot;);
         fn(i)
        },1000);
       console.log(&quot;cb 1&quot;);
     }, 1000);
   });
}

asyncRun(baseData, idx =&gt;console.log(idx))

```



### EventQueue와 CallStack 과의 관계

아래 **매우 훌륭한 영상**을 제대로 보고 이해하자. 

https://youtu.be/8aGhZQkoFbQ



-----

## 학습정리



### 피어 컴파일링 체크포인트

```
1. [ ] executeEventQueue와 executeCallStack의 구현
2. [ ] 실행순서 확인 (sync -&gt; sync -&gt; sync -&gt; async -&gt; async -&gt; async -&gt; sync)
3. [ ] runSync는 2초씩 실행
4. [ ] '4 sync 함수 실행'은 프로그램 실행 후 12초 후에 출력
5. [ ] '4 sync 함수 실행' 5초 후 프로그램 종료
6. [ ] jsasync.md 글 내용확인과, 이 글에 대한 충분한 구두설명
```



### 스스로 확인할 사항

- 실제 call stack과 event queue동작을 충분히 이해하고, 이를 코드로 구현한 것인지 확인한다. 

  
### 다같이 확인할 사항

- 자바스크립트 비동기에 대해서 이해하기 위해서, **call stack과 event queue, event loop**에 대해서 글로 정리한다.

--&gt;</content><author><name>이창권</name></author><summary type="html">Day11 콜스택 &amp;amp; 이벤트 큐 자바스크립트는 동기적인 프로그램 실행과, 비동기적인 프로그램 실행으로, 프로그램의 효율적이고 빠른 동작을 가능하게 한다. 이를 위해 call stack과 event queue의 동작 관계를 이해한다. 코드 동작 이해 전반적인 구조 callStack 배열에 담긴 함수들은 스택 구조로 역순으로 실행되며 eventQueue의 경우 큐 구조로 순서대로 callStack 배열에 push한다. executeEventQueue()와 executeCallStack()는 계속 실행되는 함수이고 callStack에 더 이상 실행해야할 함수가 없다면 executeCallStack()는 종료된다. 비동기적으로 계속 실행되는 함수를 만들기 위해 setTimeout()나 setInterval()를 이용한다. callStack 배열이 비어있기 시작한 시간부터 5초가 지나도 callStack이 계속해서 비어있는 상태이면 종료되는 로직을 구현해본다. 구현한 함수들 runSync함수 Date객체를 사용해서 2초 후 실행하게 처리 executeEventQueue함수 callStack과 eventQueue를 매개변수로 받아 callStack이 비어있을 때 eventQueue에 있는 작업들을 하나씩 처리 function executeEventQueue(callStack, eventQueue) { setInterval(() =&amp;gt; { if (callStack.length === 0) { while (eventQueue.length !== 0) { eventQueue[0](); eventQueue.splice(0, 1); } } }, 0) } executeCallStack함수 callStack에 있는 함수를 역순으로 하나씩 pop해 실행하도록 구현 callStack에 더이상 실행해야할 함수가 없다면 5초 후 종료되도록 한다. function executeCallStack(callStack) { let timer = null; if (callStack.length !== 0) { while (callStack.length !== 0) { const func = callStack.pop(); func(); } } let interval = setInterval(() =&amp;gt; { if (callStack.length !== 0) { while (callStack.length !== 0) { const func = callStack.pop(); func(); } if (timer) { clearTimeout(timer); } timer = setTimeout(() =&amp;gt; { clearInterval(interval); process.exit(); }, 5000) } }, 0) } 2. 코드 동작 개선 setInterval함수를 쓰지 않고 setTimeout만으로도 구현이 가능하다. executeEventQueue함수와 executeCallStack함수가 서로의 함수를 호출하는 형식으로 재귀적으로도 구현이 가능하다. 3. Consideration 3-1. 스스로 확인할 사항 실제 call stack과 event queue동작을 충분히 이해하고, 이를 코드로 구현한 것인지 확인한다. 원래 Task Queue에 있는 task를 callStack으로 이동시킨다음 실행하지만, 현재 나의 코드는 TaskQueue에 있는 task를 TaskQueue에서 바로 실행한다. 하지만 Task Queue에 있는 task를 callStack으로 옮겨 실행시키면, 예시처럼 작동은 하지만 원래의 task queue나 call stack의 작업처럼 행동하지 않는다(setTimeout때문) 3-2. 다같이 확인할 사항 자바스크립트 비동기에 대해서 이해하기 위해서, call stack과 event queue, event loop에 대해서 글로 정리한다. CallStack은 프로그램 내의 함수들을 담고있는 자료구조이다. 함수를 호출할 때 마다 해당 함수를 CallStack에 넣는다. 실행이 종료가 되면 CallStack에서 제거된다. Task queue는 자바스크립트 런타임 messaging queue이다. 다른 Web Apis에 할당된 Task를 관리하여 줍니다. Web Apis의 콜백 함수들을 가지고 있으며 call stack이 비어있다면 전달이 진행된다. Event loop은 call stack이 비었는지 확인한 다음, task queue가 진행할 기다리고있는 작업을 가지고 있는지 확인한다. 만약 그렇다면 해당 태스크를 queue에서 꺼내 call stack으로 넘깁니다. 이후에 call stack에서 해당 태스크를 진행한다.</summary></entry><entry><title type="html">부스트 캠프 Day10</title><link href="https://changgunyee.github.io/boost-camp/2019/07/30/boostCamp-Day10.html" rel="alternate" type="text/html" title="부스트 캠프 Day10" /><published>2019-07-30T00:00:00+09:00</published><updated>2019-07-30T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/30/boostCamp-Day10</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/30/boostCamp-Day10.html">&lt;h1 id=&quot;vmgit&quot;&gt;VMGit&lt;/h1&gt;

&lt;p&gt;DVCS 분산 저장소 방식에 대해 학습하고, 기본 동작을 구현하여 보자&lt;/p&gt;

&lt;h2&gt;1. 코드 동작 이해&lt;/h2&gt;

&lt;p&gt;객체를 이용한 코드 관리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 Repository와 파일들을 객체로써 관리하였다.&lt;/li&gt;
  &lt;li&gt;init 명령어를 실행하면 new Repository를 통해 저장소를 생성하였다.&lt;/li&gt;
  &lt;li&gt;각 디렉토리 객체들은 local이라는 배열을 만들어 보관하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Untracked&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Repository&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;new 명령어를 실행하면 new File을 통해 파일을 생성시키고 이를 해당 Repository의 files에 push하여 관리하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newRepo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newRepo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;newRepo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;p&gt;함수형 프로그래밍에 따라 객체를 공유해야하는 상황이 아니라면 항상 객체를 deepCopy해 새로운 객체로 생성해 작업하는 것이 낫다. 성능이 떨어지지만 에러를 미연에 방지할 수 있다.&lt;/p&gt;

&lt;p&gt;deepCopy하는 여러가지 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 안에 class형의 객체가 없고, function이나 상속 받은 proto가 없이 단순한 dictionary object들을 가지고 있는 object일 경우
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;oldObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;객체가 포함하는 function이나 상속받은 내용들까지 모두 copy하는 함수(vanilla js)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deepCopy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deepCopy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;jQuery나 lodash와 같은 라이브러리 사용방법(제일 권장하는 방법)
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// jQuery&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;copyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mainObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// lodash&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;copyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cloneDeep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mainObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자신이-미션을-하면서-학습한-내용&quot;&gt;자신이 미션을 하면서 학습한 내용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;객체를 이동하거나 변경 후 새로 저장해야할 일이 있을 때, 객체를 공유해야하는 부분이 아니라면 되도록 deep copy를 통해 새로 객체를 생성하는 것이 후에 오류를 막을 수 있다.(함수형 프로그래밍)&lt;/li&gt;
  &lt;li&gt;설계 시, 구현해야하는 내용에 맞는 디자인 패턴을 하나 골라 그에 따라 설계를 하는 것도 괜찮은 방법이다.&lt;/li&gt;
  &lt;li&gt;class를 만들 때, 되도록이면 확장성이 좋게 구현하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스스로-학습할-내용&quot;&gt;스스로 학습할 내용&lt;/h3&gt;
&lt;p&gt;실제 git 명령어와 구현한 명령 동작 차이점에 대해 정리한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;구현한 checkout은 저장소를 이동하지만 원래 checkout은 브랜치를 이동하는 것이다.&lt;/li&gt;
  &lt;li&gt;add명령어 시, 실제 git에서는 변경된 파일을 추적해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;add *&lt;/code&gt; 과 같이 변경된 모든 파일을 add할 수 있는 명령어도 존재하지만, 구현한 add명령어는 명령어 뒤에 넣은 파일이 변경되었지 않더라도 무조건 add한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;3. Consideration&lt;/h2&gt;

&lt;h3 id=&quot;clone-명령을-구현하려면-어떻게-구현해야-할까&quot;&gt;clone 명령을 구현하려면 어떻게 구현해야 할까?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;각 저장소마다 각자의 remote저장소를 따로 생성한다.&lt;/li&gt;
  &lt;li&gt;remote 저장소를 생성자 외에 접근할 수 있도록 권핞을 수정한다.&lt;/li&gt;
  &lt;li&gt;clone 하고 싶은 저장소(객체들이 저장된 파일)를 전체를 복사한다.&lt;/li&gt;
  &lt;li&gt;객체가 아닌 string, json 등의 형태로 저장된 정보들을 객체로 변환하는 과정을 거친다.&lt;/li&gt;
  &lt;li&gt;변환한 객체가 필요한 정보를 누락 없이 잘 저장하고 있는지 확인한 후, 이후의 작업을 진행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;branch-개념을-추가하려면-어떤-구조로-어떻게-구현해야-할까&quot;&gt;branch 개념을 추가하려면 어떤 구조로 어떻게 구현해야 할까?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;master는 여러 branch객체를 리스트로 가지고 있다.&lt;/li&gt;
  &lt;li&gt;master를 상속하는 object로 각 branch를 구현한다.&lt;/li&gt;
  &lt;li&gt;각 branch object에는 branch 가 생성된 지점에 대한 정보를 가지고 있어야 한다.&lt;/li&gt;
  &lt;li&gt;branch 를 master에 merge를 할 경우 두 브랜치를 비교한 후, 코드의 충돌이 없으면 합친다. 이 때, 파일 내부적, 외부적인 충돌을 감지하는 코드가 필요할 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pull-명령을-구현하려며-어떤-구조로-어떻게-구현해야-할까&quot;&gt;pull 명령을 구현하려며 어떤 구조로 어떻게 구현해야 할까?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pull request를 queue형태로 저장한다.&lt;/li&gt;
  &lt;li&gt;FIFO방식으로 pull request의 파일을 담은 객체를 권한이 있는 사용자에게 전달한다.&lt;/li&gt;
  &lt;li&gt;사용자의 권한은 객체의 요소로 저장되어있다.&lt;/li&gt;
  &lt;li&gt;remote 저장소의 commit 내력과 local 저장소의 commit 내력을 비교한다. local 저장소의 가장 늦은 commit 다음의 이력부터 데이터를 가지고 온다.&lt;/li&gt;
  &lt;li&gt;pull하면 기존의 객체와 새로운 객체를 반복문으로 돌려가며 변경사항을 체크한다.&lt;/li&gt;
  &lt;li&gt;변경되어있으면 새로운 객체를 덮어쓴다.&lt;/li&gt;
  &lt;li&gt;immutable하게 만들기 위해 객체는 new로 생성한 후 기존의 객체는 버린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;reference&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;https://mygumi.tistory.com/322 [마이구미의 HelloWorld]&lt;/li&gt;
&lt;/ul&gt;

&lt;!--

# Day10 VMGit

## 왜 필요한가?
DVCS 분산 저장소 방식 중에서 git 방식은 가장 많이 사용하는 방식이다. 
git 명령의 동작 방식을 이해하고, 기본 명령의 동작을 그대로 구현해보는 것이 효과적인 학습 방법이다. 

## 학습 목표
- DVCS 분산 저장소 방식에 대해 학습하고, 기본 동작을 구현하는 것이 목표다.
- 첫 단계로 저장소를 init 하고 checkout으로 저장소를 이동하는 과정을 구현한다.
- 파일을 생성하고, 추가하고, 커밋하는 흐름을 작성한다. 이 때 실제 파일을 생성하지는 않고 가상으로 동작을 구현한다. 
- 로컬에 커밋한 내용을 remote에 반영하는 흐름을 구현한다.
- 여러번 커밋한 내용을 한꺼번에 push하면, remote 마지막 커밋과 비교해서 이후 커밋만 반영한다.


## 미션

* File, Commit, Repository, Local, Remote 주요 기능을 담당하도록 module을 나누거나 class로 구분해서 작업한다.

	* 입/출력을 위한 모듈 외에 모든 기능은 바닐라 자바스크립트로 구현한다.

* 가상으로 git 동작을 확인하는 프로그램을 작성한다.

* vmgit을 시작하면 셀 프롬프트와 비슷하게 명령을 입력받는다.

### 1) init 요구사항

* `init &lt;repository_name&gt;` 명령을 사용하면 local 영역에 `&lt;repository_name&gt;` 이름으로 저장소 공간을 생성한다. 

* `status local &lt;repository_name&gt;` 명령을 사용하면 local에 있는 `&lt;repository_name&gt;` 저장소 내부 파일 상태를 출력한다. 
  * 만약 입력한 저장소 이름이 없으면 전체 저장소 목록을 출력한다.

* `checkout &lt;repository_name&gt;` 명령을 사용하면 해당 저장소를 선택한 것을 표시하기 위해서 프롬프트 뒤에 `&lt;repository_name&gt;` 저장소 이름을 붙여서 출력한다. 
  * 만약 입력한 저장소 이름이 없으면 아무런 저장소를 선택하지 않은 상태로 초기 상태와 동일하게 표시한다. 

### 예상 출력 화면 

```
/&gt;init hello
created hello repository.

/&gt;status
hello/

/&gt;checkout hello
/hello/&gt;checkout

/&gt;quit
```

### 2) checkout 요구사항

* checkout으로 저장소 선택한 후에 `new &lt;file_name&gt;` 명령을 사용하면 해당 working directory에 파일을 생성한 것으로 기록한다. 처음 생성한 파일 상태는 Untracked 상태로 표시한다. 

* checkout 이후에 `status` 명령을 사용하면 Working directory / Staging Area / Git Repository 영역에 있는 파일 목록을 변경시간과 함께 출력한다. 
  * 만약 저장소를 선택한 상태가 아니면 `status local` 처럼 동작한다.

* `add &lt;file_name&gt;` 명령을 사용하면 생성한 파일을 staging area로 이동했다고 가정하고 Staged 상태로 표시한다.

* `commit &lt;commit_log&gt;` 명령을 사용하면 staging area에 있는 모든 파일을 git repository에 등록한다. 커밋된 파일들을 커밋 시간과 함께 Unmodified 상태로 표시한다.

### 예상 출력 화면 

```
/&gt;init hello
created hello repository.

/&gt;status
hello/

/&gt;checkout hello
/hello/&gt;new readme

hello/&gt;status
---Working Directory/
readme	2019-03-26 09:28:05
---Staging Area/
---Git Repository/

hello/&gt;add readme
---Staging Area/
readme	2019-03-26 09:29:25/

hello/&gt;commit make readme file
---commit files/
readme	2019-03-26 09:29:25

hello/&gt;
```

### 3) touch, log 요구사항

* checkout으로 선택한 저장소에서 이미 커밋한 파일에 대해 `touch &lt;file_name&gt;` 명령을 사용하면 파일 상태는 Modified 상태로 표시하고 Working Directory 목록에 표시한다.

* `log` 명령을 사용하면 커밋 로그를 함께 커밋한 파일들 목록을 표시한다.


### 예상 출력 화면 

```
/&gt;status
hello/

/&gt;checkout hello
/hello/&gt;touch readme

hello/&gt;add readme
---Staging Area/
readme	2019-03-27 12:11:01

hello/&gt;commit modified file
---commit files/
readme	2019-03-27 12:11:01

hello/&gt;log
commit &quot;make readme file&quot;
readme	2019-03-25 09:29:25
commit &quot;modified file&quot;
readme	2019-03-27 12:11:01

hello/&gt;
```

### 4) push 요구사항

* `push` 명령을 사용하면 마지막까지 local에서 commit 한 이력과 Git Repository 파일을 모두 remote로 복사한다.

* `status remote &lt;repository_name&gt;` 명령을 사용하면 remote에 있는 `&lt;repository_name&gt;` 저장소 내부 파일 목록을 출력한다. 
  * 만약 저장소 이름이 없으면 해당 저장소가 없다고 출력한다.

* vmgit 프로그램을 종료하고 다시 시작하면, remote 저장소에 있는 내용은 유지되도록 저장한다. 파일로 저장하기 위해서 적당한 npm 패키지를 찾아서 구현해도 된다.

### 예상 출력 화면 

```
hello/&gt;push
push some commits...
commit &quot;make readme file&quot; pushed
commit &quot;modified file&quot; pushed

hello/&gt;status remote hello
last commit &quot;modified file&quot;
readme	2019-03-27 12:11:01

hello/&gt;checkout

/&gt;status remote
hello/

/&gt;quit
```


----

## 배경 지식

### VCS 버전관리 시스템

소스코드를 관리하는 시스템은 크게 3종류로 나눌 수 있다.
버전관리 시스템 종류를 학습하고, 차이점을 비교해본다. 

	* VCS 로컬 방식 : RCS, SCCS
	
	* CVCS 중앙 서버 방식 : Subversion(SVN), CVS, Perforce, ClearCase, TFS
	
	* DVCS 분산 저장소 방식 : Git, Mercurial, Bitkeeper, SVK, Darcs

### git 

- git 에서 사용하는 기본적인 용어들을 학습하고 정리한다.
- git 명령을 이용해서 저장소 관리하는 방식을 학습하고 정리한다.
- 변경 사항을 추가,수정,삭제하는 방식에 대해 학습하고 정리한다.

&gt; 참고자료 
&gt; 
&gt; `http://rogerdudler.github.io/git-guide/index.ko.html`

### 용어

다음과 같은 git 관련 용어를 학습하고 의미가 무엇인지, 어떤 동작을 해야 하는지 정리한다.

&gt; 저장소 관련

| 용어 | 의미 |
|---|---|
| remote | _ |
| local | _ |
| init | _  |
| clone | _ |

&gt; 상태 관리

| 용어 | 의미 |
|---|---|
| git repository | _ |
| staging area | _ |
| working directory | _ |

&gt; 파일 관련

| 용어 | 의미 |
|---|---|
| Untracked | _ |
| Unmodified | _ |
| Modified | _ |
| Staged | _ |

### 파일 상태변화

Pro Git2 에 나오는 파일 상태 변화 그림

![](https://git-scm.com/book/en/v2/images/lifecycle.png)

* 동작에 따른 파일 상태 변화에 대해 학습한다.
[참고 링크](https://git-scm.com/book/ko/v2/Git의-기초-수정하고-저장소에-저장하기)

## 학습정리

### 피어 컴파일링 체크포인트

```
	1. [ ] init 명령으로 local 영역에 저장소 생성
	2. [ ] status 명령으로 저장소 목록 확인
	3. [ ] checkout 명령으로 저장소 선택
	4. [ ] new 명령으로 untracked 파일 생성
	5. [ ] 저장소 선택 이후 status 명령으로 파일 목록 확인
	6. [ ] add 명령으로 stage 영역으로 파일 옮기기
	7. [ ] commit 명령으로 저장 공간에 여러 파일 옮기기
	8. [ ] touch 명령으로 저장 공간에 있는 파일 수정
	9. [ ] log 명령으로 커밋 목록 확인
	10. [ ] push 명령으로 local 커밋 목록을 remote로 복사
	11. [ ] status remote 명령으로 remote 저장소 / 파일 목록 확인
	12. [ ] remote 저장소 데이터 파일 저장
	13. [ ] 명령/상태에 대한 안전한 예외 처리 (멈추지 않고 동작하기)
```

### 스스로 확인할 사항

- 실제 git 명령어와 구현한 명령 동작 차이점에 대해 정리한다.

### 다같이 확인할 사항

- clone 명령을 구현하려면 어떻게 구현해야 할까?
- branch 개념을 추가하려면 어떤 구조로 어떻게 구현해야 할까?
- pull 명령을 구현하려며 어떤 구조로 어떻게 구현해야 할까?
--&gt;</content><author><name>이창권</name></author><summary type="html">VMGit DVCS 분산 저장소 방식에 대해 학습하고, 기본 동작을 구현하여 보자 1. 코드 동작 이해 객체를 이용한 코드 관리 각 Repository와 파일들을 객체로써 관리하였다. init 명령어를 실행하면 new Repository를 통해 저장소를 생성하였다. 각 디렉토리 객체들은 local이라는 배열을 만들어 보관하였다. const local = []; class File { constructor(name) { this.name = name; this.status = 'Untracked'; this.time = currentTime(); } } class Repository { constructor(name) { this.name = name; this.files = []; } } new 명령어를 실행하면 new File을 통해 파일을 생성시키고 이를 해당 Repository의 files에 push하여 관리하였다. const newRepo = new Repository(); local.push(newRepo); const newFile = new File(); newRepo.files.push(newFile); 2. 코드 동작 개선 함수형 프로그래밍에 따라 객체를 공유해야하는 상황이 아니라면 항상 객체를 deepCopy해 새로운 객체로 생성해 작업하는 것이 낫다. 성능이 떨어지지만 에러를 미연에 방지할 수 있다. deepCopy하는 여러가지 방법 객체 안에 class형의 객체가 없고, function이나 상속 받은 proto가 없이 단순한 dictionary object들을 가지고 있는 object일 경우 let newObject = JSON.parse(JSON.stringify(oldObject)); 객체가 포함하는 function이나 상속받은 내용들까지 모두 copy하는 함수(vanilla js) function deepCopy(obj) { if (obj === null || typeof obj !== 'object') { return obj; } let copy = {}; for (let key in obj) { copy[key] = deepCopy(obj[key]); } return copy; } jQuery나 lodash와 같은 라이브러리 사용방법(제일 권장하는 방법) // jQuery let copyObject = $.extend(true, {}, mainObject); // lodash let copyObject = _.cloneDeep(mainObject); 자신이 미션을 하면서 학습한 내용 객체를 이동하거나 변경 후 새로 저장해야할 일이 있을 때, 객체를 공유해야하는 부분이 아니라면 되도록 deep copy를 통해 새로 객체를 생성하는 것이 후에 오류를 막을 수 있다.(함수형 프로그래밍) 설계 시, 구현해야하는 내용에 맞는 디자인 패턴을 하나 골라 그에 따라 설계를 하는 것도 괜찮은 방법이다. class를 만들 때, 되도록이면 확장성이 좋게 구현하는 것이 좋다. 스스로 학습할 내용 실제 git 명령어와 구현한 명령 동작 차이점에 대해 정리한다. 구현한 checkout은 저장소를 이동하지만 원래 checkout은 브랜치를 이동하는 것이다. add명령어 시, 실제 git에서는 변경된 파일을 추적해서 add * 과 같이 변경된 모든 파일을 add할 수 있는 명령어도 존재하지만, 구현한 add명령어는 명령어 뒤에 넣은 파일이 변경되었지 않더라도 무조건 add한다. 3. Consideration clone 명령을 구현하려면 어떻게 구현해야 할까? 각 저장소마다 각자의 remote저장소를 따로 생성한다. remote 저장소를 생성자 외에 접근할 수 있도록 권핞을 수정한다. clone 하고 싶은 저장소(객체들이 저장된 파일)를 전체를 복사한다. 객체가 아닌 string, json 등의 형태로 저장된 정보들을 객체로 변환하는 과정을 거친다. 변환한 객체가 필요한 정보를 누락 없이 잘 저장하고 있는지 확인한 후, 이후의 작업을 진행한다. branch 개념을 추가하려면 어떤 구조로 어떻게 구현해야 할까? master는 여러 branch객체를 리스트로 가지고 있다. master를 상속하는 object로 각 branch를 구현한다. 각 branch object에는 branch 가 생성된 지점에 대한 정보를 가지고 있어야 한다. branch 를 master에 merge를 할 경우 두 브랜치를 비교한 후, 코드의 충돌이 없으면 합친다. 이 때, 파일 내부적, 외부적인 충돌을 감지하는 코드가 필요할 것이다. pull 명령을 구현하려며 어떤 구조로 어떻게 구현해야 할까? pull request를 queue형태로 저장한다. FIFO방식으로 pull request의 파일을 담은 객체를 권한이 있는 사용자에게 전달한다. 사용자의 권한은 객체의 요소로 저장되어있다. remote 저장소의 commit 내력과 local 저장소의 commit 내력을 비교한다. local 저장소의 가장 늦은 commit 다음의 이력부터 데이터를 가지고 온다. pull하면 기존의 객체와 새로운 객체를 반복문으로 돌려가며 변경사항을 체크한다. 변경되어있으면 새로운 객체를 덮어쓴다. immutable하게 만들기 위해 객체는 new로 생성한 후 기존의 객체는 버린다. reference https://mygumi.tistory.com/322 [마이구미의 HelloWorld]</summary></entry></feed>