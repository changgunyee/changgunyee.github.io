<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://changgunyee.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://changgunyee.github.io/" rel="alternate" type="text/html" /><updated>2019-08-05T09:59:59+09:00</updated><id>https://changgunyee.github.io/feed.xml</id><title type="html">changgunyee</title><subtitle>개발,음악 등의 잡동사니를 모아두는 블로그</subtitle><author><name>이창권</name></author><entry><title type="html">부스트 캠프 Day8</title><link href="https://changgunyee.github.io/boost-camp/2019/07/25/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day8.html" rel="alternate" type="text/html" title="부스트 캠프 Day8" /><published>2019-07-25T00:00:00+09:00</published><updated>2019-07-25T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/25/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day8</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/25/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day8.html">&lt;h1 id=&quot;할일관리-프로그램&quot;&gt;할일관리 프로그램&lt;/h1&gt;

&lt;p&gt;자바스크립트에서 함수형프로그래밍과 객체지향 프로그래밍을 이용해보자&lt;/p&gt;

&lt;h2 id=&quot;1-코드-동작-이해&quot;&gt;1. 코드 동작 이해&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;OOP
    &lt;ul&gt;
      &lt;li&gt;객체지향 프로그래밍이란 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결시켜 프로그래밍 하는 기법.&lt;/li&gt;
      &lt;li&gt;객체는 속성(property)과 행위(method)를 가짐.&lt;/li&gt;
      &lt;li&gt;OOP의 특징
        &lt;ul&gt;
          &lt;li&gt;추상화 : 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념, 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법&lt;/li&gt;
          &lt;li&gt;캡슐화 : 불필요한 정보를 감출 수 있기 때문에, 정보은닉을 할 수 있다는 특징을 가짐.&lt;/li&gt;
          &lt;li&gt;상속 : 상속 관계에 있는 두 클래스에 대해, 부모 클래스가 자손 클래스에게 속성을 물려주는 것&lt;/li&gt;
          &lt;li&gt;다형성 : 같은 형태이지만 다른 기능을 하는 것.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;자바스크립트에서는?
        &lt;ul&gt;
          &lt;li&gt;모든 객체는 &lt;strong&gt;프로토타입&lt;/strong&gt;이라는 다른 객체를 가리키는 내부 링크를 가지고 있다. 프로토 타입을 통해 직접 객체를 연결할 수 있는 데 이를 프로토타입 체인이라 하고, 이를 통해 상속을 구현할 수 있음.&lt;/li&gt;
          &lt;li&gt;자바스크립트에서의 객체 생성 방법
            &lt;ol&gt;
              &lt;li&gt;object literal&lt;/li&gt;
              &lt;li&gt;(ES2015) class&lt;/li&gt;
              &lt;li&gt;Object() 생성자 함수&lt;/li&gt;
              &lt;li&gt;constructor pattern&lt;/li&gt;
            &lt;/ol&gt;

            &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// object literal&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Lee&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
        
  &lt;span class=&quot;c1&quot;&gt;// Object() 생성자 함수&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Lee&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
  &lt;span class=&quot;c1&quot;&gt;// 생성자 함수&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;obj3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Lee&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
  &lt;span class=&quot;c1&quot;&gt;// (ES2015) class&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;health&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;prototype chain과 method 정의
            &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;me&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Lee&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;you&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Kim&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;him&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;choi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Person { setName: [Function], getName: [Function] }&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Person { name: 'Lee' }&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;you&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Person { name: 'Kim' }&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;him&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Person { name: 'choi' }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MVC 모델
    &lt;ul&gt;
      &lt;li&gt;모델-뷰-컨트롤러(Model–View–Controller, MVC)는 소프트웨어 공학에서 사용되는 &lt;strong&gt;소프트웨어 디자인 패턴&lt;/strong&gt; 이다. 이 패턴을 성공적으로 사용하면, 사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있다.&lt;/li&gt;
      &lt;li&gt;모델 : 애플리케이션의 정보(데이터)를 나타낸다&lt;/li&gt;
      &lt;li&gt;뷰 : 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타낸다.&lt;/li&gt;
      &lt;li&gt;컨트롤러 : 데이터와 비즈니스 로직 사이의 상호동작을 관리한다.&lt;/li&gt;
      &lt;li&gt;참고 : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC&quot;&gt;https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;옵저버 패턴
    &lt;ul&gt;
      &lt;li&gt;observer pattern은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴&lt;/li&gt;
      &lt;li&gt;각각의 옵저버는 notify 함수를 구현함으로써 이벤트가 발생했을 때 처리할 각자의 동작을 정의해야 한다.&lt;/li&gt;
      &lt;li&gt;주체에는 일반적으로 등록(register), 제거(unregister) 메서드가 존재 임시로 작동을 멈추거나 재개하는 메서드를 이용해 이벤트가 계속해서 있을 때 홍수같이 발생하는 요청을 제어할 수도 있다.&lt;/li&gt;
      &lt;li&gt;옵저버 패턴이 많이 쓰인 시스템에서는 순환 실행을 막는 메카니즘이 필요&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/Observer.svg/854px-Observer.svg.png&quot; style=&quot;width:500px;height:300px&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Express 서버
    &lt;ul&gt;
      &lt;li&gt;Express는 웹 및 모바일 애플리케이션을 위한 일련의 강력한 기능을 제공하는 간결하고 유연한 Node.js 웹 애플리케이션 프레임워크&lt;/li&gt;
      &lt;li&gt;Node.js로 서버 개발 시, 미들웨어 구조를 이용해 손쉽게 개발하게 해준다.&lt;/li&gt;
      &lt;li&gt;
        &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;express&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;express&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;express&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello World!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;async/await
    &lt;ul&gt;
      &lt;li&gt;ES7부터 도입됐으며, Promise를 더 편하게 쓸 수 있는 문법이다.&lt;/li&gt;
      &lt;li&gt;활용 예시 :
        &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/no-user-here&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
       &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
      &lt;li&gt;참고 : &lt;a href=&quot;https://javascript.info/async-await&quot;&gt;https://javascript.info/async-await&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-코드-동작-개선&quot;&gt;2. 코드 동작 개선&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;주어진 요구사항을 꼼꼼하게 체크하고, OOP와 모듈단위로 나눈방식의 개발방법의 장점이 무엇인지 고민한다.
    &lt;ul&gt;
      &lt;li&gt;완전히 독립된 객체들을 만들고 그 객체를 넘겨받아 이용해주는 것이므로, 유지 보수에 장점이 있고, OOP의 주요 특징인 다형성 상속등으로 코드 재사용성이 높다.&lt;/li&gt;
      &lt;li&gt;예를들어 다른 상황에서 옵저버 패턴을 사용해주고 싶을 때 Observable.js를 사용해서 기능들을 상속받아 이용해줄 수 있을 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;더 개선할 부분은 없는지, 더 좋은 방식의 패턴이 없을지 고민해본다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;이전의 함수형 프로그래밍 같은 경우, 순수한 함수를 작성해서 공유된 사태와 변경가능한 데이터 및 부작용을 피하면서 코드 작성을 하였었다. 이러한 점에서는 이번 과제로 진행한 상태가 공유되는 객체지향과 대조된다 생각한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;디자인 패턴 중 대표적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;GoF 패턴&lt;/code&gt;들에 대해서 알아보았고 더 나을지는 모르겠지만 이 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;Command pattern&lt;/code&gt;을 활용해줄 수 있을 것 같다는 생각을 했다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;command pattern
        &lt;ul&gt;
          &lt;li&gt;요청을 객체로 갭슐화함으로써 서로 다른 요청으로 클라이언트를 파라미터화하고, 요청을 저장하거나 기록을 남겨서 오퍼레이션의 취소도 가능하게 한다.&lt;/li&gt;
          &lt;li&gt;또, 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴이다.&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Command_pattern.svg/2880px-Command_pattern.svg.png&quot; /&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;이를테면 새로운 기능을 구현하려고 할때, TodoModel을 변경하지 않고 TodoModel에 새로운 기능 자체를 전달하는 식으로 디자인 한다면 TodoModel의 재사용성을 증가시키고 전체적인 확장성도 증가시킬 수 있을 것 같다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;참고
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://gmlwjd9405.github.io/2018/07/06/design-pattern.html&quot;&gt;https://gmlwjd9405.github.io/2018/07/06/design-pattern.html&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://gmlwjd9405.github.io/2018/07/07/command-pattern.html&quot;&gt;https://gmlwjd9405.github.io/2018/07/07/command-pattern.html&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://gone-sw.tistory.com/4&quot;&gt;https://gone-sw.tistory.com/4&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;https://en.wikipedia.org/wiki/Command_pattern&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-consideration&quot;&gt;3. Consideration&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;undo/redo 기능을 제공하고 싶다. 특정 사람의 코드를 골라서, 이 기능을 추가하기 위한 전략을 세워보자.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;undo 같은 경우, 가장 최근의 진행 과정을 저장하는 배열을 따로 TodoModel 객체의 property로 두어, undo 명령어가 들어올시 이를 참고하는 식으로 구현할 수 있을 것 같다.&lt;/li&gt;
      &lt;li&gt;redo 같은 경우, undo와 마찬가지로 진행과정을 저장하는 배열에서 가장 최근에 저장된 요소를 다시 수행하는 식으로 하면 가능할 것으로 사료된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;html파일생성이 아닌 markdown포맷을 생성하는 view클래스를 만든다고 가정한다. Obsever패턴을 어떻게 적용할 수 있을까? Observer패턴의 장점은 무엇일까?&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;기존에 있던 observer패턴 그대로에, 기존에 있던 TodoHtmlView클래스와 같이 markdown포맷을 생성하는 view클래스를 생성해 update함수만 포함하게 하면 적용이 가능하다.&lt;/li&gt;
      &lt;li&gt;위와 같이 Observer패턴에서는 각각의 파생 Observer에서 각자 원하는 행동을 취할 수 있으며, 변화가 생겼을 때 자신이 가지고 있는 Observers에게 notify만 해주면, 그에 따른 필요한 행위를 한번에 처리가 가능하다.&lt;/li&gt;
      &lt;li&gt;위와 같이 Observer 패턴을 사용해주고자하면, 자체적으로 기능을 새로 추가하지 않고 Observable 모듈을 만들어두고, 이를 상속받아 활용해주면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day8 OOP 할일관리 프로그램

## 왜 필요한가?
소프트웨어의 크기가 커지면 이를 객체 단위로 만들어서 큰 그룹을 지어 프로그래밍을 할 수 있다.

Java나 C#과 같은 객체지향프로그래밍 언어에서는 이를 필수로 하지만, 자바스크립트는 객체지향언어라고 하기는 어렵다.(객체없이 프로그래밍이 가능함으로)

하지만 자바스크립에서도 객체지향프로그래밍이 가능하며, 이를 활용해서 현업에서는 많은 프로그래밍을 만들어서 운영하고 있다.

현대의 프로그래밍에서는 객체단위로 프로그래밍을 하는 것이 여러가지 선택지 중 하나이다.(참고로 자바스크립트에서도 함수형프로그래밍 방법이 많이 활용되고 있고, 객체지향과 함수형프로그래밍 패러다임을 섞는 경우도 많다)




## 학습 목표
- OOP 라는 것은 무엇이고, 어떻게 프로그램을 설계 해야 하는지 기초적인 지식을 안다.
- Object literal을 이해한다
- prototype 과 prototype chain을 이해한다.
- ES6 Classes로 객체 만드는 방법을 안다.
- API 서버의 기본 역할을 이해한다.
- 모듈단위의 개발을 할 수 있다.



----


## 미션

### 객체지향을 고민하면서 만드는 TODO 애플리케이션



#### 1. 기본기능  

- id는 unique하게 생성한다. **uuid 모듈을 사용**한다.
- add에서는 tag를  n개로 받을 수 있다.
- update 시에는 2초 delay후에 화면에 결과가 출력된다. **async/await 와 promise패턴을 사용**해서 구현한다.


- show/add/update/delete 가 동작되며, **add 기능은 immutable 한 방식**으로 상태가 변경된다.

- entry point 역할을 하는 파일은 **TodoApp.js** 이다.

  ```javascript
  $  node TodoApp.js
  
  명령하세요 : show$$current
  현재상태 :  todo: [1,124], doing:[123,444], done:[]
  
  명령하세요 : show$$todo
  todo리스트 :  총2건 : ' 자바스크립트 공부하기, 123번' , 'iOS공부하기, 124번'
  
  명령하세요 : add$$docker공부하기$$[&quot;favorite&quot;,&quot;programming&quot;]
  docker공부하기가 추가됐습니다.(id : 7788)
  현재상태 :  todo: [1,124,7788], doing:[123,444], done:[]
  
  명령하세요 : update$$7788$$doing
  (여기서 2초가 흐른뒤에 아래 내용이 나온다)
  docker공부하기 doing으로 상태가 변경됐습니다
  현재상태 :  todo: [1,124], doing:[123,444, 7788], done:[]
  
  명령하세요 : delete$$7788
  docker공부하기가 doing목록에서 삭제됐습니다
  현재상태 :  todo: [123,124], doing:[123,444], done:[]
  
  
  ```



#### 2. TodoApp.js 의 내용

- 아래 주어진 코드를 TodoApp.js의 **기본코드로 사용**하면서, 필요한 코드를 변경/추가 한다.

```javascript
const TodoModel = require(&quot;./TodoModel.js&quot;)
const TodoController = require(&quot;./TodoController.js&quot;)
const TodoHtmlView = require('./TodoHtmlView.js') //뒤에 설명

//todolist 값을 서버에서 얻어와야 한다.
//const todolist = 서버에서 데이터 가져오기 코드가 필요

const todoModel = new TodoModel(todolist);
const controller = new TodoController(todoModel);
controller.runTodo();
new TodoHtmlView(todoModel);

```

- **TodoController.js**
  - 사용자 입력내용(add/update/delete)을 분석해서 분기하는 역할
  - **ES Classes** 형태로 구현해야 한다.
  - TodoModel객체만 주입받는다.
- **TodoModel.js**
  - todolist 상태값을 add/update/delete등을 통해서 실제 변경하는 역할
  - ES6 Classes 패턴을 사용할 수 없으며, ES6이전의 **prototype패턴**을 활용해서 만들어야 한다. 
  - todolist 데이터만 주입받아서 동작된다.
  - 뒤에 나오는 Observer 기능을 하는 객체는 require로 가져와서 사용한다.
  - console.log로 출력하는 역할을 할 수 있으며, console.log부분을 별도의 클래스로 분리할 수도 있다(선택사항)
- **TodoHtmlView.js**
  - todoModel에서 현재상태를 출력 할 때마다, log.html파일을 새롭게 생성하는 파일이다. (뒤에 설명)
- **util.js**
  - util.js 를 객체리터럴 형태로 만들고, 아래 기능을 포함한다.
    - unique한 방식으로 id를 생성하는 방식
    - delay를 시키는 함수
    - 기타  일반적인 유틸리티 기능이라고 판단되는 기능들
- **그외에 필요한 객체는 ES Classes 나 prototype패턴을 활용해서 추가 할 수 있다.**



#### 3. 객체지향 원칙

- 클래스나 객체코드 (TodoModel, TodoController, TodoHtmlView 등)안에서 다른 객체를 직접 호출하는 코드가 없어야 한다. 즉 모든 클래스나 객체는 결합도가 낮은상태를 유지한다.

  ```javascript
  class A {
    go() {
      const b = new B();  //A클래스 안에서, 이렇게 직접호출하는 것은 좋지 않음
      b.run();
    }
  }
  ```

  

- 생성자에서 많은 일을 하지 않도록 한다. 메서드를 최대한 작게만들고, 여러개로 나눠서 만든다.



#### 4. API서버 구성

- 8090 port로 동작하는 API서버를 만든다. 
- nodejs의 **Express 모듈을 사용**해서 만든다.
- /server 디렉토리를 새롭게 만들고, **/server/app.js** 에 서버를 구동하는 코드를 구현한다.
- 데이터베이스는 존재하지 않는다. json형태의 데이터를 javascript파일로  만들고, 이를 응답하도록 한다.
- 데이터 요청/응답에 필요한 부분은 Express뿐만 아니라 모든 npm 라이브러리를 사용할 수 있다.
- Express 사이트의 **getting started** 부분을 참고해서 만드는 것을 권장한다.



#### 5. Observer pattern 을 통한 model에서의 알림과, 새로운 View 클래스 에서의 구독기능 

- **TodoHtmlView.js**는 html/log.html 파일과 내용을 생성하는 view생성 클래스이다.
- /html/log.html 파일내용은 아래와 같으며, 현재todlist 상태값이 출력될때마다 업데이트 된다.
- TodoHtmlView.js는  template literal을 활용해서 HTML문자열을 생성할 수 있고, 'fs' 와 같은 모듈을 사용할 수 있다.
- TodoHtmlView.js 는 ES Classes로 구현한다.
- /html/log.html  내용

```html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;TodoList Result&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;todolist&lt;/h1&gt;
    &lt;div class=&quot;log&quot;&gt;
        현재상태 : doing:[1,223,333,423], todo:[], done:[], 
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
```

- Observer pattern 사용.

  - **Observer 패턴을 공부하고, 이를 Observable.js 파일로 생성한다. ES Classes문법으로 구현한다.**
  - **TodoModel은 Observable.js를 상속**받는다. (prototype 체인을 연결하는 방식을 적용, extends 키워드를 쓸 수 없음)
  - **TodoHtmlView.js** 는 객체 생성단계에서 주입받은 **TodoModel객체를  '구독'** 한다. (주어진 TodoApp.js 내용참고)
  - **model의 변경이 view로 전달되는 과정은 Observer패턴**을 따른다.
    - **TodoModel에서 현재상태를 출력할때마다**, TodoModel의 '알림' 기능을 통해서, **/html/log.html** 내용도 자동으로 업데이트 된다. 
    - 즉, TodoModel에서 TodoHtmlView객체를 직접 호출하지 않고, **TodoHtmlView가 TodoModel을 구독**해서 실행되어야 한다.

  

#### 6. 기타

- node_modules/ 디렉토리를 **commit 에서 제외**시킨다.

- this binding을 위해서 **that = this;** 와 같은 this값을 변수에 저장하는 방식을 **사용할 수 없다.** 

- TodoController 는 기본적으로 try-catch를 통해서 에러처리를 포함한다.

  

------

## 배경 지식

### 객체

모든 것이 객체다!?

어떠한사물 === Object.

현실세계를 인지하면서 프로그래밍을 하자!에서 출발

 =&gt; 상상하고,볼수있고,만질수있는 것들은 모두 객체이다.



------

### 객체의 구성

모든객체는 속성(property)과 행위(method)를 가질 수 있음.

- 속성 : 사람의 키,나이,몸무게
- 행위  : 움직이다, 먹다, 자다, 공부하다



```javascript
Class {
  this.height = 180;  //property
  this.age = 22;  //property
  eat = function() {}  //method
}
```



업계에서 현실적으로 같이 쓰는 용어

- 속성,필드,property는 같은말.
- 함수,메서드도 같은말.



------

### 클래스와 객체

class는  어떠한 객체를 표현하기 위해, 일반화된 형태로 만든 것으로 볼 수 있다.
어떠한 **집합이나 분류**에 가깝다.(사람, 동물, 자동차 등)

객체는 인스턴스라고도 하며, class를 통해서 얻을 수 있는 것으로 볼 수 있다.
따라서 유일한 사물이라고 볼 수 있으며,  꼭 그런것은 아니지만 실체에 가깝다(crong, 사자, 벤츠)

우리가 자주 사용하는 console.log 에도 객체와 메서드가 있다.

- console =&gt; 객체(인스턴스)
- log =&gt; 메서드(함수)



------

### OOP 핵심 개념(참고)

객체지향 언어에서는 다음의 항목을 중요하게 다룬다. 이를 이해하고 프로그래밍을 하면 더 나은 객체지향프로그래밍을 할 수 있다.

- Class
- 캡슐화(Encapsulation)
- 상속(Inheritance)
- 다형성(polymorphism)
- 추상화(abstraction)



### 프론트엔드에서는 OOP를 어떻게 할 수 있지 ?

화면에 보이는 UI요소, 어떠한 제어를 하는 비UI요소등, 모든 것을 **모듈**로 만들어서 개발할 수 있음.

여기서 **모듈은 객체(class형태)**임.

JavaScript세계에서 **객체의 표현방식은 다양**함.



------

### 객체표현 - 1. object literal

class없이 바로 object로 표현가능(singleton)

```javascript
const healthObj = {
  name : &quot;달리기&quot;,
  lastTime : &quot;PM10:12&quot;,
  showHealth() {
    console.log(this.name + &quot;님, 오늘은 &quot; + this.lastTime + &quot;에 운동을 하셨네요&quot;);
  }
}

healthObj.showHealth();
```



------

### 객체표현 - 2. ES Classes pattern - ES2015

Class가 생기고, class에서 제공하는 constructor라는 생성자가 주어짐. 
class를 new키워드로 호출하면 constructor가 자동호출 됨. 

constructor는 instance를 만들어서 반환.  다시말해 객체(instance)를 생성해서 반환.

하지만 ES Classes역시 prototype을 내부적으로 사용하고 있다.

```javascript
const Health = class {
  constructor(name, healthTime) {
    this.name = name;
    this.healthTime = healthTime;
  }

  showHealth(){
     console.log(this.name + &quot;님, 오늘은 &quot; + this.healthTime + &quot;에 운동을 하셨네요&quot;);
  }

}

const ho = new Health(&quot;crong&quot;, &quot;12:12&quot;);
ho.showHealth();
```

class의 브라우저 지원범위는 어때요? 
https://caniuse.com/#feat=es6-class



------

### 객체표현 - 3. constructor pattern

function을 new 키워드로 호출하면, 그 함수는 constructor가 됨.

```javascript
const Health = function(name,healthTime) {
  this.name = name;
  this.healthTime = healthTime;
  this.showHealth = function() {
    console.log(this.name + &quot;님, 오늘은 &quot; + this.healthTime + &quot;에 운동을 하셨네요&quot;);
  }
}

const ho = new Health(&quot;crong&quot;, &quot;12:12&quot;);
ho.showHealth();
```





------

### 객체표현 - 4. prototype pattern 

(가장 중요한 부분으로 내용이 길다. 🚂)

constructor 패턴과 유사하나,

메서드를 prototype객체에 보관해서 constructor pattern보다는 메모리 효율 성에서 매우 유리함.



&lt;iframe src=&quot;https://player.vimeo.com/video/266039157&quot; width=&quot;800&quot; height=&quot;450&quot; frameborder=&quot;0&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&quot;https://vimeo.com/266039157&quot;&gt;Prototype pattern&lt;/a&gt; from &lt;a href=&quot;https://vimeo.com/codesquad&quot;&gt;Yoda codd&lt;/a&gt; on &lt;a href=&quot;https://vimeo.com&quot;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;



```javascript
const Health = function(name, healthTime) {
  this.name = name;
  this.healthTime = healthTime;
}

Health.prototype.showHealth = function() {
  console.log(this.name + &quot;님, 오늘은 &quot; + this.healthTime + &quot;에 운동을 하셨네요&quot;);
}

const ho = new Health(&quot;crong&quot;, &quot;12:12&quot;);
ho.showHealth();

```

ho 라는 객체를 열어서 prototype의 어떻게 실제 존재하는지도 들여다 보자. 

또한 ho2로 만들어진 prototype객체의 메서드와 ho의 prototype객체의 메서드가 서로 같은 메모리 주소를 참조하는지도 확인해보자. (=== 으로 비교)



##### 이렇게 만들어진 객체 들여다보기.

myHealth 개발자도구의 콘솔창에서 열어보면 다음과 같다.

```javascript
myHealth =&gt; 
    name : &quot;달리기&quot;, 
    lastTime : &quot;23:10&quot;, 
    &gt; __proto__ : Object
        showHealth: ()
        &gt; __proto__: Object  
```

__proto__ 는 prototype객체를 표현한 것이고, 
모든 객체는 prototype으로 연결되어 있어, prototype안에 있는 어떠한 메서드를 사용하면, prototype을 타고 올라가면서 찾는다. 이것을 prototype체인이라고 한다.



##### 왜 prototype?

prototype은 효과적으로 동작.
생성자를 통해 생성된 객체(인스턴스)들이 여러개 있어도, 
prototype에 연결된 객체들(movieObject)는 동일한 메모리 공간에서 효율적으로 재사용 됨.
즉, 두 객체의 prototype은 같음.

```javascript
myHealth.__proto__ === myHealth2.__proto__  //true
myHealth2.__proto__ === myHealth3.__proto__  //true
//__proto__ 객체는 자바스크립트 내부에서만 사용되는 속성이다.
```

prototype객체는 최상위 Object까지 연결되어 있음.
prototype연결고리를 만들어서 객체간의 상속관계를 만들 수 있음.



##### prototype을 사용한 예제

두 개의 모듈을 생성자 역할을 하는 함수를 만들고, 각각 생성자에 prototype속성에다가 메서드를 추가하는 예제이다.
이처럼 class없이도 구현할 수 있다. 

```javascript
//VM 모듈
var VM = function(elBase) {
   this.elBase = elBase;
	 this.init();
}

VM.prototype = {
  init : function() {
	  this.elBase.addEventListener(&quot;click&quot;, this.clickListener);
    this.xxx.addEventListener(&quot;click&quot;, this.xxxxListener);
  }
}

//Wallet 모듈
var Wallet = function(elBase) {
   this.elBase = elBase;
	 this.init();
}

Wallet.prototype = {
  init : function() {
	  this.elBase.addEventListener(&quot;click&quot;, this.clickListener);
    this.xxx.addEventListener(&quot;click&quot;, this.xxxxListener);
  },
	run : function() {
    //blah....
  }
}
```





------

### 객체표현 - 5. Object.create

Object.create는 직접적으로 prototype키워드를 사용하진 않지만, Prototype object를 만드는 것과 동일.

```javascript
const healthObj = {
  showHealth : function() {
    console.log(this.name + &quot;님, 오늘은 &quot; + this.healthTime + &quot;에 운동을 하셨네요&quot;);
  }
}

const ho = Object.create(healthObj, {
   name: { value: &quot;crong&quot; },
   healthTime: { value: &quot;12:22&quot; } 
})

ho.showHealth();
```

Object.create는 prototype기반 객체연결(상속형태)을 좀더 매끄럽게 사용하기 위해 탄생했다고 이해할 수 있음.

Object.create를 사용하면 객체연결구조가 잘 만들어짐. 

하지만 이 방법은 많이 쓰이지 않고 있는데 이유는, ES6 Classes의 extend를 사용해서 이제 보다 쉽게 클래스간 상속 구조를 만들 수 있게 됐기 때문.



------

### 언제 object literal을 사용하고, 언제 class 를 사용할까?

1. object literal 

여러개의 객체를 만들어서 생성할 필요가 없을때, 즉 일반화할 필요가 없는 경우에는 단순히 object literal로 객체를 표현.



2. class

하나 이상으로 개별적인 객체를 생성해야 할 때. 





-----


## 학습정리


### 피어 컴파일링 체크포인트

```
1. [ ] show$$current 실행
2. [ ] add 실행(태그는 2개이상)
3. [ ] add할때 immutable방식적용
4. [ ] update 실행(2초 지연 결과 노출)
5. [ ] 지연시 async/await와 promise를 활용
6. [ ] delete 실행 
7. [ ] 'q'로 프로그램 종료
8. [ ] unique한 id 생성 확인(uuid사용)
9. [ ] util에서 객체리터럴 사용
10. [ ] TodoController, TodoHtmlView, Observable에서 ES Classes를 사용
11. [ ] TodoModel에서 prototype을 통한 객체 표현
12. [ ] TodoModel에서 Obsevable 객체를 상속 (prototype방식으로 연결)
13. [ ] TodoHtmlView.js에서 TodoModel객체를 구독
14. [ ] '현재상태' 출력시 a.html내용도 계속 업데이트
15. [ ] 객체지향원칙 준수
16. [ ] Express를 통한 API서버 연결
17. [ ] '기타' 항목의 요구사항 확인
```



### 스스로 확인할 사항

- 주어진 요구사항을 꼼꼼하게 체크하고, OOP와 모듈단위로 나눈방식의 개발방법의 장점이 무엇인지 고민한다.
- 더 개선할 부분은 없는지, 더 좋은 방식의 패턴이 없을지 고민해본다.



### 다같이 확인할 사항
- undo/redo 기능을 제공하고 싶다. 특정 사람의 코드를 골라서, 이 기능을 추가하기 위한 전략을 세워보자.

- html파일생성이 아닌 markdown포맷을 생성하는 view클래스를 만든다고 가정한다. Obsever패턴을 어떻게 적용할 수 있을까? Observer패턴의 장점은 무엇일까? 

  
--&gt;</content><author><name>이창권</name></author><summary type="html">할일관리 프로그램 자바스크립트에서 함수형프로그래밍과 객체지향 프로그래밍을 이용해보자 1. 코드 동작 이해 OOP 객체지향 프로그래밍이란 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결시켜 프로그래밍 하는 기법. 객체는 속성(property)과 행위(method)를 가짐. OOP의 특징 추상화 : 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념, 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법 캡슐화 : 불필요한 정보를 감출 수 있기 때문에, 정보은닉을 할 수 있다는 특징을 가짐. 상속 : 상속 관계에 있는 두 클래스에 대해, 부모 클래스가 자손 클래스에게 속성을 물려주는 것 다형성 : 같은 형태이지만 다른 기능을 하는 것. 자바스크립트에서는? 모든 객체는 프로토타입이라는 다른 객체를 가리키는 내부 링크를 가지고 있다. 프로토 타입을 통해 직접 객체를 연결할 수 있는 데 이를 프로토타입 체인이라 하고, 이를 통해 상속을 구현할 수 있음. 자바스크립트에서의 객체 생성 방법 object literal (ES2015) class Object() 생성자 함수 constructor pattern // object literal var obj1 = {}; obj1.name = 'Lee'; // Object() 생성자 함수 var obj2 = new Object(); obj2.name = 'Lee'; // 생성자 함수 function F() {} var obj3 = new F(); obj3.name = 'Lee'; // (ES2015) class const health = class { constructor(...) ... } prototype chain과 method 정의 function person(name){ this.name = name; } person.prototype.setName = function(name){ this.name = name; } Person.prototype.getName = function () { return this.name; }; var me = new Person('Lee'); var you = new Person('Kim'); var him = new Person('choi'); console.log(Person.prototype); // Person { setName: [Function], getName: [Function] } console.log(me); // Person { name: 'Lee' } console.log(you); // Person { name: 'Kim' } console.log(him); // Person { name: 'choi' } MVC 모델 모델-뷰-컨트롤러(Model–View–Controller, MVC)는 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴 이다. 이 패턴을 성공적으로 사용하면, 사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있다. 모델 : 애플리케이션의 정보(데이터)를 나타낸다 뷰 : 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타낸다. 컨트롤러 : 데이터와 비즈니스 로직 사이의 상호동작을 관리한다. 참고 : https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC 옵저버 패턴 observer pattern은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴 각각의 옵저버는 notify 함수를 구현함으로써 이벤트가 발생했을 때 처리할 각자의 동작을 정의해야 한다. 주체에는 일반적으로 등록(register), 제거(unregister) 메서드가 존재 임시로 작동을 멈추거나 재개하는 메서드를 이용해 이벤트가 계속해서 있을 때 홍수같이 발생하는 요청을 제어할 수도 있다. 옵저버 패턴이 많이 쓰인 시스템에서는 순환 실행을 막는 메카니즘이 필요 Express 서버 Express는 웹 및 모바일 애플리케이션을 위한 일련의 강력한 기능을 제공하는 간결하고 유연한 Node.js 웹 애플리케이션 프레임워크 Node.js로 서버 개발 시, 미들웨어 구조를 이용해 손쉽게 개발하게 해준다. var express = require('express'); var app = express(); app.get('/', function (req, res) { res.send('Hello World!'); }); app.listen(3000); async/await ES7부터 도입됐으며, Promise를 더 편하게 쓸 수 있는 문법이다. 활용 예시 : async function f() { try { let response = await fetch('/no-user-here'); let user = await response.json(); } catch(err) { alert(err); } } f(); 참고 : https://javascript.info/async-await 2. 코드 동작 개선 주어진 요구사항을 꼼꼼하게 체크하고, OOP와 모듈단위로 나눈방식의 개발방법의 장점이 무엇인지 고민한다. 완전히 독립된 객체들을 만들고 그 객체를 넘겨받아 이용해주는 것이므로, 유지 보수에 장점이 있고, OOP의 주요 특징인 다형성 상속등으로 코드 재사용성이 높다. 예를들어 다른 상황에서 옵저버 패턴을 사용해주고 싶을 때 Observable.js를 사용해서 기능들을 상속받아 이용해줄 수 있을 것이다. 더 개선할 부분은 없는지, 더 좋은 방식의 패턴이 없을지 고민해본다. 이전의 함수형 프로그래밍 같은 경우, 순수한 함수를 작성해서 공유된 사태와 변경가능한 데이터 및 부작용을 피하면서 코드 작성을 하였었다. 이러한 점에서는 이번 과제로 진행한 상태가 공유되는 객체지향과 대조된다 생각한다. 디자인 패턴 중 대표적인 GoF 패턴들에 대해서 알아보았고 더 나을지는 모르겠지만 이 중 Command pattern을 활용해줄 수 있을 것 같다는 생각을 했다. command pattern 요청을 객체로 갭슐화함으로써 서로 다른 요청으로 클라이언트를 파라미터화하고, 요청을 저장하거나 기록을 남겨서 오퍼레이션의 취소도 가능하게 한다. 또, 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴이다. 이를테면 새로운 기능을 구현하려고 할때, TodoModel을 변경하지 않고 TodoModel에 새로운 기능 자체를 전달하는 식으로 디자인 한다면 TodoModel의 재사용성을 증가시키고 전체적인 확장성도 증가시킬 수 있을 것 같다. 참고 https://gmlwjd9405.github.io/2018/07/06/design-pattern.html https://gmlwjd9405.github.io/2018/07/07/command-pattern.html https://gone-sw.tistory.com/4 https://en.wikipedia.org/wiki/Command_pattern 3. Consideration undo/redo 기능을 제공하고 싶다. 특정 사람의 코드를 골라서, 이 기능을 추가하기 위한 전략을 세워보자. undo 같은 경우, 가장 최근의 진행 과정을 저장하는 배열을 따로 TodoModel 객체의 property로 두어, undo 명령어가 들어올시 이를 참고하는 식으로 구현할 수 있을 것 같다. redo 같은 경우, undo와 마찬가지로 진행과정을 저장하는 배열에서 가장 최근에 저장된 요소를 다시 수행하는 식으로 하면 가능할 것으로 사료된다. html파일생성이 아닌 markdown포맷을 생성하는 view클래스를 만든다고 가정한다. Obsever패턴을 어떻게 적용할 수 있을까? Observer패턴의 장점은 무엇일까? 기존에 있던 observer패턴 그대로에, 기존에 있던 TodoHtmlView클래스와 같이 markdown포맷을 생성하는 view클래스를 생성해 update함수만 포함하게 하면 적용이 가능하다. 위와 같이 Observer패턴에서는 각각의 파생 Observer에서 각자 원하는 행동을 취할 수 있으며, 변화가 생겼을 때 자신이 가지고 있는 Observers에게 notify만 해주면, 그에 따른 필요한 행위를 한번에 처리가 가능하다. 위와 같이 Observer 패턴을 사용해주고자하면, 자체적으로 기능을 새로 추가하지 않고 Observable 모듈을 만들어두고, 이를 상속받아 활용해주면 된다.</summary></entry><entry><title type="html">부스트 캠프 Day7</title><link href="https://changgunyee.github.io/boost-camp/2019/07/24/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day7.html" rel="alternate" type="text/html" title="부스트 캠프 Day7" /><published>2019-07-24T00:00:00+09:00</published><updated>2019-07-24T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/24/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day7</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/24/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day7.html">&lt;h1 id=&quot;linux-shell&quot;&gt;Linux Shell&lt;/h1&gt;

&lt;p&gt;셀 환경에 익숙해지고, 셀 스크립트를 작성해서 자동화 처리를 진행&lt;/p&gt;

&lt;h2 id=&quot;1-코드-동작-이해&quot;&gt;1. 코드 동작 이해&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가상머신
    &lt;ul&gt;
      &lt;li&gt;목적 : 다른 OS를 실행, 독립된 환경을 마련, 테스트를 위해서 환경 자체를 저장하고 다시 쓰거나 배포하는 등도 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ssh를 설치
    &lt;ul&gt;
      &lt;li&gt;ssh는 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 의미한다.&lt;/li&gt;
      &lt;li&gt;ssh로 접속 시 인증 방법에는 크게 2가지로, 공개키를 이용하거나 비밀번호를 이용하는 방식이 있다.&lt;/li&gt;
      &lt;li&gt;쉘 스크립트에서 패스워드로 ssh접속하여 파일 복사하는 코드&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-script&quot;&gt;  sshpass -p{Password} scp -o StrictHostKeyChecking=no {복사할 파일} {원격아이디}@{원격주소}:{복사될원격서버경로}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;리눅스(Linux)
    &lt;ul&gt;
      &lt;li&gt;하나의 컴퓨터를 여러 사람이 사용할 수 있는 멀티유저 운영체제이기 때문에 권한관리가 중요.&lt;/li&gt;
      &lt;li&gt;chmod 명령어를 통해 파일 권한을 변경할 수 있음
        &lt;pre&gt;&lt;code class=&quot;language-script&quot;&gt;  chmod 764 backup
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쉘 스크립트(shell script)
    &lt;ul&gt;
      &lt;li&gt;shell script이용 시, 서버에서 원하는 동작을 자동화할 수 있다.&lt;/li&gt;
      &lt;li&gt;새로운 pc이용 시, 개발환경을 손수 구축해야 하지만 쉘 스크립트를 이용해 한번에 처리할 수 있다.&lt;/li&gt;
      &lt;li&gt;예시 코드
        &lt;pre&gt;&lt;code class=&quot;language-script&quot;&gt;  mkdir ./temp
  for file in $directory/*
  do
      if [ ${file: -3} == &quot;.js&quot; ]
      then
          cp $file ./temp/
      fi
  done
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;쉘스크립트 cheatsheet : &lt;a href=&quot;https://devhints.io/bash&quot;&gt;https://devhints.io/bash&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타입 스크립트(type script)
    &lt;ul&gt;
      &lt;li&gt;자바스크립트의 태생적 문제를 극복하고자 AltJS(자바스크립트의 대체 언어)가 등장하였는데, 대체 언어들 중 가장 주목받고 있는 언어라고 할 수 있다.&lt;/li&gt;
      &lt;li&gt;컴파일 언어, 정적 타입 언어&lt;/li&gt;
      &lt;li&gt;타입 기반 언어
        &lt;ol&gt;
          &lt;li&gt;타입 스크립트 = 자바 스크립트 + 타입&lt;/li&gt;
          &lt;li&gt;컴파일 단계에서 타입 오류를 잡아낼 수 있고, 코드 어시스트 기능도 지원받을 수 있음&lt;/li&gt;
          &lt;li&gt;암묵적 형변환, 호이스팅, 복잡성 문제 해결
            &lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fruit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;apple&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// javascript에서는 호이스팅 문제로 이와 같은 중복선언이 불가능했으나 typescript에서는 가능&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;banana&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;banana&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;apple&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-코드-동작-개선&quot;&gt;2. 코드 동작 개선&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;리눅스 역사와 유닉스와 차이를 학습한다.
    &lt;ul&gt;
      &lt;li&gt;유닉스
        &lt;ul&gt;
          &lt;li&gt;유닉스(영어: Unix)는 교육 및 연구 기관에서 즐겨 사용되는 범용 다중 사용자 방식의 시분할 운영 체제이다. 1970년대 초반 벨 연구소 직원인 켄 톰슨, 데니스 리치 등이 처음 개발하였다.&lt;/li&gt;
          &lt;li&gt;유닉스는 처음부터 다양한 시스템 사이에서 서로 이식할 수 있고, 멀티 태스킹과 다중 사용자를 지원하도록 설계되었다.&lt;/li&gt;
          &lt;li&gt;서버에 ‘특화’된 운영체제로 보안성도 뛰어나며, 이식성, 유연성, 호환성, 가상메모리 등으로 세계적인 기업들이 유닉스 시스템으로 서버를 운영관리하게 됐다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;리눅스
        &lt;ul&gt;
          &lt;li&gt;이런 유닉스의 장점을 그대로 차용하고 가격을 무료화한 유닉스-유사 시스템을 만들려는 시도가 있어오는 중에, 1991년 리누스 토발즈가 취미 삼아 개발한 커널, 리눅스가 등장했다.&lt;/li&gt;
          &lt;li&gt;리눅스는 운영 체제이자 혹은 커널을 뜻하기도 한다. 리눅스는 자유 소프트웨어와 오픈 소스 개발의 가장 유명한 표본으로 들 수 있다. 리눅스는 다중 사용자, 다중 작업(멀티태스킹), 다중 스레드를 지원하는 네트워크 운영 체제(NOS)이다.&lt;/li&gt;
          &lt;li&gt;벤더 독립성과 적은 개발비, 보안성과 안전성등으로 꾸준히 사랑받고 있다. 리눅스 재단에 따르면 퍼블릭 클라우드 워크로드의 90%, 세계 스마트폰의 82%, 임베디드 기기의 62%, 슈퍼 컴퓨터 시장의 99%가 리눅스로 작동한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;차이점
        &lt;ul&gt;
          &lt;li&gt;리눅스
            &lt;ul&gt;
              &lt;li&gt;무료(유료버전도 있다)&lt;/li&gt;
              &lt;li&gt;커뮤니티에 의해 개발됐다.&lt;/li&gt;
              &lt;li&gt;모바일폰, 태블릿 컴퓨터, 비디오콘솔, 슈퍼컴퓨터 등 다양한 하드웨어에 설치가 가능하다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;유닉스
            &lt;ul&gt;
              &lt;li&gt;유료이며 판매 회사별로 가격이 다르다.&lt;/li&gt;
              &lt;li&gt;Solaris(Oracle), AIX(IBM), HP-UX가 큰 3개의 제조사이고, Apple의 OSX도 있다.&lt;/li&gt;
              &lt;li&gt;인터넷서버, 워크스테이션과 PC들에 사용되고, 금융 인프라, 24x365 고가용 솔루션의 인프라 등에 사용되고 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Unix_history-simple.svg/1920px-Unix_history-simple.svg.png&quot; alt=&quot;unix and unix-like operating systems&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참고
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4&quot;&gt;https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix&quot;&gt;https://en.wikipedia.org/wiki/Unix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://leeject.tistory.com/108&quot;&gt;https://leeject.tistory.com/108&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여러 가지 쉘 종류에 대해 학습한다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;쉘은 ‘줄’단위로 해석하여 명령을 수행한다. 프롬포트에서 명령을 읽을 때도, 스크립트 파일을 읽을 때도 한 줄씩 받아 읽는다.&lt;/strong&gt;&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;Bourne shell
        &lt;ul&gt;
          &lt;li&gt;구조적 프로그램을 만들 수 있는 프로그램 언어를 내장했고, 특히 입/출력 제어에 강력하는 기능을 제공. 다만, 대화식 사용자 환경에는 매우 빈약하다. 모든 쉘의 토대가 되는 기본 원칙을 견고하게 다져놓음.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;C shell
        &lt;ul&gt;
          &lt;li&gt;대화식 사용자 환경을 강화하고 새로운 개념(job control, history, alias 등)을 도입. 네이밍에서 볼 수 있듯이 언어 구조가 C언어랑 매우 유사하기 때문에 C언어를 사용하는 사람은 이해하기가 쉽다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TC shell
        &lt;ul&gt;
          &lt;li&gt;새로운 기능(command line editing, spelling correction, login/logout watching 등)을 추가. 그러나 C shell을 표준으로 하여, 비표준 shell로 남아있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;# Bourne shell vs. C shell&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$days&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-gt&lt;/span&gt; 365 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;then
     &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;This is over a year.
 &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
    
 &lt;span class=&quot;c&quot;&gt;#!/bin/csh&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$days&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 365 &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
     &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;This is over a year.
 endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;타입스크립트가 자바스크립트 다른 점에 대해 학습하고, ts 파일과 js 파일을 비교한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Typescript장점&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;TypeScript 의 특징 중 컴파일시점의 타입 체크, 인터페이스, 클래스 기반의 디자인 패턴 등은 다른 언어 기반에서도 많은 개발자들에게 이미 익숙&lt;/li&gt;
          &lt;li&gt;대부분의 JavaScript 로 변환되는 언어들이 커뮤니티의 노력으로 운영되는 반면, TypeScript 는 공식적으로 Microsoft 의 지원을 받는다&lt;/li&gt;
          &lt;li&gt;JavaScript 표준과 상호 호환이다. Typescript를 컴파일만 하면 Javascript파일로 만들 수 있으므로, 사용하고 싶은 기능만 사용도 가능하다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Javascript장점&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;함수형 프로그래밍을 하기에 Typescript보다 좋다&lt;/li&gt;
          &lt;li&gt;견해 차이는 존재하지만, 생산성에 Javascript가 더 좋다는 해석도 존재한다.&lt;/li&gt;
          &lt;li&gt;Typescript는 d.ts에 따라 새로운 의존성이 생겨 npm의 장점을 희석시키지만, Javascript만 사용시 이러한 새로운 의존성은 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-consideration&quot;&gt;3. Consideration&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;셀 스크립트에 활용한 다양한 사례에 대해서 조사해보자.
    &lt;ul&gt;
      &lt;li&gt;linux의 cron과 조합하여 다양한 자동화 작업에 활용할 수 있다.(예시 : database화된 지인들의 생일 알림 메일 보내기)&lt;/li&gt;
      &lt;li&gt;시스템을 감시하며 문제 발생시 자동 대처(예시 : 하드 디스크 사용량이 90%가 넘었을 때 자동으로 alert)&lt;/li&gt;
      &lt;li&gt;원격 디바이스 제어 (예시 : 라즈베리 파이에서 ip 변경 감시 및 알림)&lt;/li&gt;
      &lt;li&gt;외에도 시스템 환경 제어, 자동화, 어플리케이션 설치, 변경점 배포 등등 셀을 활용해서 할 수 있는 많은 작업들을 할 수 있다고 한다.&lt;/li&gt;
      &lt;li&gt;참고
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;http://emertxe.com/blog/2017/12/automation-using-shell-script.html&quot;&gt;http://emertxe.com/blog/2017/12/automation-using-shell-script.html&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타입스크립크를 왜 써야하는지 각자 나름의 이유를 찾아서 비교하고 정리한다.
    &lt;ul&gt;
      &lt;li&gt;자바스크립트와는 달리 Type이 있어, 정확함을 보장할 수 있어 버그를 찾기 쉽게 만들어준다.&lt;/li&gt;
      &lt;li&gt;컴파일 타임에 어느 부분이 잘못되었는지 알려주어 리팩토링 부분에서 정적 타이핑의 강점이 드러난다.&lt;/li&gt;
      &lt;li&gt;타입스크립트는 자바스크립트의 확장이므로 ‘타입스크립트 &amp;lt;-&amp;gt; 자바스크립트’의 변환이 자유롭다. 이를 이용해 각 언어의 장점이나 특색을 살려서 사용할 수 있다.&lt;/li&gt;
      &lt;li&gt;결론적으로 유지보수에 아주 뛰어난 장점을 가지고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;babel 도구의 트랜스파일링 동작방식과, 실무에서 babel도구가 어떤목적으로 사용되는지 조사하자.
    &lt;ul&gt;
      &lt;li&gt;Babel은 ES6/ES7 코드를 ECMAScript5 코드로 transpiling 하기 위한 도구이다.&lt;/li&gt;
      &lt;li&gt;Babel은 다양한 작은 모듈들로 구성되어 있으며, 다양한 모듈을 담는 일종의 상자 역할을 하며 코드를 컴파일 하기 위해 작은 모듈들(ex. presets)을 사용한다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;babel의 트랜스 파일링 동작방식&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;파싱(Parsing) : 소스코드를 가지고 추상적인 형태의 코드로 변환. 이 추상적인 형태의 코드를 추상구문트리(AST)라고 부른다.&lt;/li&gt;
          &lt;li&gt;변환(Transformation) : 파싱된 추상구문트리를 받아와 각 브라우저의 환경에 맞는 결과로 변환. 이과정에서 preset/plugin이 처리된다.&lt;/li&gt;
          &lt;li&gt;코드 생성(Generation) : 2단계에서 생성된 추상구문 트리를 바탕으로 실제 브라우저 환경에 맞는 소스코드로 변환하는 과정. 기술만하는 단계가 2단계라면 실제로 코드를 생성하는 단계가 3단계이다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://k.kakaocdn.net/dn/cnn1K8/btqu2UQqFvm/iI4WS91ahe3W8kcOau5sv0/img.jpg&quot; style=&quot;width:600px; height:400px&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;ES6/ES7을 사용하면 생산성이 높아지는데, 아직 이를 지원하지 않는 브라우저들이 많이 존재한다. babel을 사용하여 생산성 높게 작업을 하되, 작업물들을 트랜스파일링하여 배포함으로서 다양한 브라우저들을 지원할 수 있게 처리한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day7 Linux Shell


## 왜 필요한가?
리눅스/유닉스 개발 환경은 백엔드 개발자들에게 익숙한 개발 환경이다. 터미널로 서버 환경에 원격으로 접속해서 원하는 작업을 할 수 있도록 친숙해져야 한다. 리눅스/유닉스의 역사부터 쉘 환경에 익숙해지고 스크립트로 원하는 동작을 자동화할 수 있어야 한다.

## 학습 목표
- 리눅스/유닉스 환경에 대해 학습하고, 터미널로 리눅스 쉘 환경에 익숙해지는 것이 목표다.
- 셀 환경에 익숙해지고, 셀 스크립트를 작성해서 자동화 처리를 진행한다.
- 로컬 컴퓨터에서 타입 스크립트를 컴파일해서 리눅스 가상 환경에 배포 파일을 스크립트로 배포하는 것이 목표다.


## 미션

* 다음 각 단계를 진행하면서 작업한 명령어, 스크린 캡처, 진행 과정, 실행 결과를 설명하는 문서를 마크다운 형식으로 작성한다. 

* 스크립트 파일, 마크다운 문서와 이미지 등을 모두 포함해서 커밋하고 푸시한다. 

* 단, 컴파일한 바이너리 실행 파일은 포함하지 않는다. 

### 1)가상 환경 설치하기

* 각자 컴퓨터 환경에서 사용할 수 있는 가상 환경(Virtual Machine)에서 리눅스 운영체제를 설치한다. 

  * 권장 설치 운영체제 : ubuntu 18.04 또는 ubuntu 16.04

* 가상 환경에 원격으로 접속할 수 있도록 ssh 설정을 하고, root 계정 이외에 본인 접속할 계정을 추가한다. 

* 본인 계정에 대한 패스워드를 설정한다.

* 로컬 컴퓨터에서 가상 환경 리모트 컴퓨터에 ssh로 접속해서 본인 계정으로 로그인한다.

* 본인 계정에서 `/backup` 디렉토리를 생성하고 `764` 모드로 접근 권한을 바꿔서, 본인 계정으로 쓸 수 있도록 설정한다. 

#### 무료 가상 환경
&gt; 1) VirtualBox : https://www.virtualbox.org
&gt; 
&gt; 2) Docker : https://www.docker.com
&gt; 	- ubuntu images `https://hub.docker.com/_/ubuntu/`

#### 유료 가상 환경
&gt; 1) VMWare : https://www.vmware.com
&gt; 
&gt; 2) Parallels : http://parallels.com/
&gt; 

### 2)쉘 스크립트 요구사항

* 특정한 디렉토리 아래 `day1` 부터 `day16`까지 문제 해결 디렉토리가 있다고 가정한다. 

	* 각 디렉토리 아래에는 작업한 소스 파일들이 들어있다.

* bash 셀 스크립트로 현재 디렉토리 아래있는 `day1`에서 `day16` 디렉토리 중에서 있는 js 파일만 `zip`으로 압축해서 백업하는 스크립트를 자동화해서 구현한다.

* 스크립트 진행 도중에 js 파일이 없는 디렉토리가 있으면, 어느 디렉토리가 없는지 문구를 출력한다.

* 예를 들어 `day7/` 경로 아래 js 파일이 없으면 `day7 is empty` 같은 문구를 출력할 수 있다.

* 스크립트는 js 파일들을 압축해서 가상머신 리눅스 `/backup` 경로에 복사한다. 

* 로컬에 생성한 `.zip` 파일은 scp 명령을 사용해서 가상 머신으로 복사한다. (패스워드를 입력하는 단계를 생략할 필요는 없다.)

* 백업 파일 이름에는 오늘 날짜를 붙여서 복사한다. 예시) `backup_20190724.zip` 

### 3) 타입스크립트 컴파일 요구사항

* 가상 환경에 설치한 리눅스 환경을 서비스를 배포하는 서버라고 가정하고, nodejs 10.x 버전과 npm을 설치한다.

	* 단, 가상 환경에는 타입스트립트 환경을 설치하지 않는다.

	* 리모트 리눅스에 접속해서 `/day7` 디렉토리를 생성하고 쓰기 권한를 설정한다.

* 로컬 컴퓨터에 타입스크립트 컴파일러를 설치한다.

	* 컴파일 해야 하는 타입 스크립트 `baseball.ts`

* 로컬에 타입 스크립트 컴파일러로 `baseball.js` 파일을 만들고, html 파일과 함께 가상 환경으로 scp 명령을 사용해서 복사한다.

* 타입스크립트 컴파일한 js파일과 html 파일을 가상 머신으로 `/day7` 복사하는 쉘 스크립트로 작성한다.

* 리눅스 가상 환경에 접속해서 npm 에서 `local-web-server` 패키지를 설치한다.

* `local-web-server`를 실행하고 `baseball.html`에 접속해서 동작을 확인한다.

## 배경 지식

### Shell 

Shell(쉘, 셸)이란?

- OS와 대화하는 프로그램
- 여러 가지 종류가 있는데 지금은 bash 사용
- 맥 사용자는 zsh를 사용하는 것도 좋다! (oh-my-zsh)

[쉘 관련 읽을거리](https://beomi.github.io/2017/07/07/Beautify-ZSH/)

#### pwd

&gt; 현재 디렉토리를 확인

#### 리눅스 디렉토리들

```bash
/
/home
/boot
/home/ubuntu
/bin
/etc
```

#### ls

&gt; List Directory, 디렉토리의 내용을 보여줌

```bash
ls -l
ls -al
```

`.` 은 현재 디렉토리
`..` 은 현재 디렉토리의 부모 디렉토리를 나타낸다.

#### tree [디렉토리이름] [-L 깊이]

```bash
tree / -L 1
```

#### mkdir

&gt; 새로운 디렉토리 생성

```bash
mkdir project
ls
pwd
cd project
ls
pwd
```

#### cd

디렉토리 변경

```bash
cd
cd ../
cd /
cd /home/ubuntu/project
cd ~
cd ubuntu
cd ./././././././
cd ~/Documents #~은 홈의 약자
```

#### cat 파일이름

&gt; 파일 내용 표시

```bash
echo &quot;Hello, CodeSquad?&quot; &gt; hello.txt
cat hello.txt
```

#### less 파일명

&gt; 긴 파일의 내용을 끊어서 표시

- q: 종료
- g: 처음으로
- G: 끝으로
- /단어: 문서에서 '단어'를 검색
- space, enter, 화살표, hjkl: 페이지 이동

#### history

명령어 이력 표시

```bash
history
!명령어번호
```

#### cp, mv, rm

&gt; 파일 복사, 이동, 삭제

```bash
mkdir dir1
echo &quot;some&quot; &gt; dir1/file.txt
cp dir1/file.txt file2.txt
cp -a dir1 dir2
tree .
mv dir2 dir3
rm -rf dir1
```

#### find 디렉토리 -name &quot;파일이름&quot;

&gt; 지정한 디렉토리와 그 하위디렉토리에서 해당 파일을 검색한다.

#### touch 파일이름

&gt; 0바이트 파일 생성

```bash
touch foo.txt
ls
```

### 쉘 스크립트 

&gt; Environment Variables

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.002.png&quot; width=&quot;600px&quot;&gt;

&gt; export 설정하기

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.003.png&quot; width=&quot;600px&quot;&gt;

&gt; 실행하기

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.004.png&quot; width=&quot;600px&quot;&gt;

&gt; 스크립트 변수

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.005.png&quot; width=&quot;600px&quot;&gt;

&gt; 리다이렉션 redirection

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.006.png&quot; width=&quot;600px&quot;&gt;

&gt; 파이프 pipe

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.007.png&quot; width=&quot;600px&quot;&gt;

&gt; 키보드 입력

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.008.png&quot; width=&quot;600px&quot;&gt;

&gt; 반복 구문

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.009.png&quot; width=&quot;600px&quot;&gt;

&gt; 비교 구문

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.010.png&quot; width=&quot;600px&quot;&gt;

&gt; 문자열 비교, 패턴

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.011.png&quot; width=&quot;600px&quot;&gt;

&gt; 파일, 디렉토리, 문자열 테스트 test

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.012.png&quot; width=&quot;600px&quot;&gt;

&gt; 숫자 비교 테스트

&lt;img src=&quot;http://public.codesquad.kr/jk/cs23/shellscript/shellscript.013.png&quot; width=&quot;600px&quot;&gt;

### 타입 스크립트

* 공식 사이트 [링크](https://www.typescriptlang.org)

* 타입 스크립트 설계자 소개 [영상](https://www.youtube.com/watch?v=hDACN-BGvI8)

* 타입 스크립트에 대한 소개글 

	[튜토리얼](https://github.com/JaeYeopHan/typescript_tutorial)	
	
	[블로그](https://velog.io/@dongwon2/TypeScript를-시작하기-전에-이정도는-해줘야지)

## 학습정리

### 피어 컴파일링 체크포인트

```
1. [ ] 가상 환경에 리눅스 설치
2. [ ] ssh 접속 - 로그인 가능 여부
3. [ ] /backup 디렉토리 생성 여부
4. [ ] 백업 자동화 스크립트 - 압축 파일 생성
5. [ ] 백업 자동화 스크립트 - 가상 환경으로 복사
6. [ ] 로컬에 타입스크립 컴파일러 설치
7. [ ] js 컴파일링 및 실행 환경 복사 스크립트
8. [ ] 웹 서버로 html 실행 확인
```

### 스스로 확인할 사항

- 리눅스 역사와 유닉스와 차이를 학습한다.
- 여러 가지 쉘 종류에 대해 학습한다.
- 타입스크립트가 자바스크립트 다른 점에 대해 학습하고, ts 파일과 js 파일을 비교한다.

### 다같이 확인할 사항

- 셀 스크립트에 활용한 다양한 사례에 대해서 조사해보자.
- 타입스크립크를 왜 써야하는지 각자 나름의 이유를 찾아서 비교하고 정리한다.
- babel 도구의 트랜스파일링 동작방식과, 실무에서  babel도구가 어떤목적으로 사용되는지 조사하자.

--&gt;</content><author><name>이창권</name></author><summary type="html">Linux Shell 셀 환경에 익숙해지고, 셀 스크립트를 작성해서 자동화 처리를 진행 1. 코드 동작 이해 가상머신 목적 : 다른 OS를 실행, 독립된 환경을 마련, 테스트를 위해서 환경 자체를 저장하고 다시 쓰거나 배포하는 등도 가능하다. ssh를 설치 ssh는 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 의미한다. ssh로 접속 시 인증 방법에는 크게 2가지로, 공개키를 이용하거나 비밀번호를 이용하는 방식이 있다. 쉘 스크립트에서 패스워드로 ssh접속하여 파일 복사하는 코드 sshpass -p{Password} scp -o StrictHostKeyChecking=no {복사할 파일} {원격아이디}@{원격주소}:{복사될원격서버경로} 리눅스(Linux) 하나의 컴퓨터를 여러 사람이 사용할 수 있는 멀티유저 운영체제이기 때문에 권한관리가 중요. chmod 명령어를 통해 파일 권한을 변경할 수 있음 chmod 764 backup 쉘 스크립트(shell script) shell script이용 시, 서버에서 원하는 동작을 자동화할 수 있다. 새로운 pc이용 시, 개발환경을 손수 구축해야 하지만 쉘 스크립트를 이용해 한번에 처리할 수 있다. 예시 코드 mkdir ./temp for file in $directory/* do if [ ${file: -3} == &quot;.js&quot; ] then cp $file ./temp/ fi done 쉘스크립트 cheatsheet : https://devhints.io/bash 타입 스크립트(type script) 자바스크립트의 태생적 문제를 극복하고자 AltJS(자바스크립트의 대체 언어)가 등장하였는데, 대체 언어들 중 가장 주목받고 있는 언어라고 할 수 있다. 컴파일 언어, 정적 타입 언어 타입 기반 언어 타입 스크립트 = 자바 스크립트 + 타입 컴파일 단계에서 타입 오류를 잡아낼 수 있고, 코드 어시스트 기능도 지원받을 수 있음 암묵적 형변환, 호이스팅, 복잡성 문제 해결 var fruit = &quot;apple&quot;; { // javascript에서는 호이스팅 문제로 이와 같은 중복선언이 불가능했으나 typescript에서는 가능 let fruit:string = &quot;banana&quot;; console.log(fruit); } console.log(fruit); &amp;gt; banana &amp;gt; apple 2. 코드 동작 개선 리눅스 역사와 유닉스와 차이를 학습한다. 유닉스 유닉스(영어: Unix)는 교육 및 연구 기관에서 즐겨 사용되는 범용 다중 사용자 방식의 시분할 운영 체제이다. 1970년대 초반 벨 연구소 직원인 켄 톰슨, 데니스 리치 등이 처음 개발하였다. 유닉스는 처음부터 다양한 시스템 사이에서 서로 이식할 수 있고, 멀티 태스킹과 다중 사용자를 지원하도록 설계되었다. 서버에 ‘특화’된 운영체제로 보안성도 뛰어나며, 이식성, 유연성, 호환성, 가상메모리 등으로 세계적인 기업들이 유닉스 시스템으로 서버를 운영관리하게 됐다. 리눅스 이런 유닉스의 장점을 그대로 차용하고 가격을 무료화한 유닉스-유사 시스템을 만들려는 시도가 있어오는 중에, 1991년 리누스 토발즈가 취미 삼아 개발한 커널, 리눅스가 등장했다. 리눅스는 운영 체제이자 혹은 커널을 뜻하기도 한다. 리눅스는 자유 소프트웨어와 오픈 소스 개발의 가장 유명한 표본으로 들 수 있다. 리눅스는 다중 사용자, 다중 작업(멀티태스킹), 다중 스레드를 지원하는 네트워크 운영 체제(NOS)이다. 벤더 독립성과 적은 개발비, 보안성과 안전성등으로 꾸준히 사랑받고 있다. 리눅스 재단에 따르면 퍼블릭 클라우드 워크로드의 90%, 세계 스마트폰의 82%, 임베디드 기기의 62%, 슈퍼 컴퓨터 시장의 99%가 리눅스로 작동한다. 차이점 리눅스 무료(유료버전도 있다) 커뮤니티에 의해 개발됐다. 모바일폰, 태블릿 컴퓨터, 비디오콘솔, 슈퍼컴퓨터 등 다양한 하드웨어에 설치가 가능하다. 유닉스 유료이며 판매 회사별로 가격이 다르다. Solaris(Oracle), AIX(IBM), HP-UX가 큰 3개의 제조사이고, Apple의 OSX도 있다. 인터넷서버, 워크스테이션과 PC들에 사용되고, 금융 인프라, 24x365 고가용 솔루션의 인프라 등에 사용되고 있다. 참고 https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4 https://en.wikipedia.org/wiki/Unix https://leeject.tistory.com/108 여러 가지 쉘 종류에 대해 학습한다. 쉘은 ‘줄’단위로 해석하여 명령을 수행한다. 프롬포트에서 명령을 읽을 때도, 스크립트 파일을 읽을 때도 한 줄씩 받아 읽는다. Bourne shell 구조적 프로그램을 만들 수 있는 프로그램 언어를 내장했고, 특히 입/출력 제어에 강력하는 기능을 제공. 다만, 대화식 사용자 환경에는 매우 빈약하다. 모든 쉘의 토대가 되는 기본 원칙을 견고하게 다져놓음. C shell 대화식 사용자 환경을 강화하고 새로운 개념(job control, history, alias 등)을 도입. 네이밍에서 볼 수 있듯이 언어 구조가 C언어랑 매우 유사하기 때문에 C언어를 사용하는 사람은 이해하기가 쉽다. TC shell 새로운 기능(command line editing, spelling correction, login/logout watching 등)을 추가. 그러나 C shell을 표준으로 하여, 비표준 shell로 남아있다. # Bourne shell vs. C shell #!/bin/sh if [ $days -gt 365 ] then echo This is over a year. fi #!/bin/csh if ( $days &amp;gt; 365 ) then echo This is over a year. endif 타입스크립트가 자바스크립트 다른 점에 대해 학습하고, ts 파일과 js 파일을 비교한다. Typescript장점 TypeScript 의 특징 중 컴파일시점의 타입 체크, 인터페이스, 클래스 기반의 디자인 패턴 등은 다른 언어 기반에서도 많은 개발자들에게 이미 익숙 대부분의 JavaScript 로 변환되는 언어들이 커뮤니티의 노력으로 운영되는 반면, TypeScript 는 공식적으로 Microsoft 의 지원을 받는다 JavaScript 표준과 상호 호환이다. Typescript를 컴파일만 하면 Javascript파일로 만들 수 있으므로, 사용하고 싶은 기능만 사용도 가능하다. Javascript장점 함수형 프로그래밍을 하기에 Typescript보다 좋다 견해 차이는 존재하지만, 생산성에 Javascript가 더 좋다는 해석도 존재한다. Typescript는 d.ts에 따라 새로운 의존성이 생겨 npm의 장점을 희석시키지만, Javascript만 사용시 이러한 새로운 의존성은 없다. 3. Consideration 셀 스크립트에 활용한 다양한 사례에 대해서 조사해보자. linux의 cron과 조합하여 다양한 자동화 작업에 활용할 수 있다.(예시 : database화된 지인들의 생일 알림 메일 보내기) 시스템을 감시하며 문제 발생시 자동 대처(예시 : 하드 디스크 사용량이 90%가 넘었을 때 자동으로 alert) 원격 디바이스 제어 (예시 : 라즈베리 파이에서 ip 변경 감시 및 알림) 외에도 시스템 환경 제어, 자동화, 어플리케이션 설치, 변경점 배포 등등 셀을 활용해서 할 수 있는 많은 작업들을 할 수 있다고 한다. 참고 http://emertxe.com/blog/2017/12/automation-using-shell-script.html 타입스크립크를 왜 써야하는지 각자 나름의 이유를 찾아서 비교하고 정리한다. 자바스크립트와는 달리 Type이 있어, 정확함을 보장할 수 있어 버그를 찾기 쉽게 만들어준다. 컴파일 타임에 어느 부분이 잘못되었는지 알려주어 리팩토링 부분에서 정적 타이핑의 강점이 드러난다. 타입스크립트는 자바스크립트의 확장이므로 ‘타입스크립트 &amp;lt;-&amp;gt; 자바스크립트’의 변환이 자유롭다. 이를 이용해 각 언어의 장점이나 특색을 살려서 사용할 수 있다. 결론적으로 유지보수에 아주 뛰어난 장점을 가지고 있다. babel 도구의 트랜스파일링 동작방식과, 실무에서 babel도구가 어떤목적으로 사용되는지 조사하자. Babel은 ES6/ES7 코드를 ECMAScript5 코드로 transpiling 하기 위한 도구이다. Babel은 다양한 작은 모듈들로 구성되어 있으며, 다양한 모듈을 담는 일종의 상자 역할을 하며 코드를 컴파일 하기 위해 작은 모듈들(ex. presets)을 사용한다. babel의 트랜스 파일링 동작방식 파싱(Parsing) : 소스코드를 가지고 추상적인 형태의 코드로 변환. 이 추상적인 형태의 코드를 추상구문트리(AST)라고 부른다. 변환(Transformation) : 파싱된 추상구문트리를 받아와 각 브라우저의 환경에 맞는 결과로 변환. 이과정에서 preset/plugin이 처리된다. 코드 생성(Generation) : 2단계에서 생성된 추상구문 트리를 바탕으로 실제 브라우저 환경에 맞는 소스코드로 변환하는 과정. 기술만하는 단계가 2단계라면 실제로 코드를 생성하는 단계가 3단계이다. ES6/ES7을 사용하면 생산성이 높아지는데, 아직 이를 지원하지 않는 브라우저들이 많이 존재한다. babel을 사용하여 생산성 높게 작업을 하되, 작업물들을 트랜스파일링하여 배포함으로서 다양한 브라우저들을 지원할 수 있게 처리한다.</summary></entry><entry><title type="html">부스트 캠프 Day6</title><link href="https://changgunyee.github.io/boost-camp/2019/07/23/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day6.html" rel="alternate" type="text/html" title="부스트 캠프 Day6" /><published>2019-07-23T00:00:00+09:00</published><updated>2019-07-23T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/23/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day6</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/23/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day6.html">&lt;h1 id=&quot;대화형-할일-관리-프로그램&quot;&gt;대화형 할일 관리 프로그램&lt;/h1&gt;

&lt;p&gt;프로그래밍 디자인 학습, 문자열 및 데이터 조작&lt;/p&gt;

&lt;h2&gt;1. 코드 동작 이해&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스켈레톤 작성
    &lt;ul&gt;
      &lt;li&gt;뼈대가 되는 함수와 인자들을 작성&lt;/li&gt;
      &lt;li&gt;테스트 케이스에 대해서 실행시 함수 용도를 알 수 있을정도로 콘솔에 표시하도록 작성.&lt;/li&gt;
      &lt;li&gt;실행으로 알 수 없는 부분들에 대해서는 주석으로 설명하는 것도 좋다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 형식의 정의
    &lt;ul&gt;
      &lt;li&gt;데이터의 용도와 구현해야하는 함수에 따라 자료구조를 구성한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;2초 딜레이 출력
    &lt;ul&gt;
      &lt;li&gt;동기방식으로 출력돼야 함&lt;/li&gt;
      &lt;li&gt;커스텀 sleep 구현으로 2초딜레이 생성&lt;/li&gt;
      &lt;li&gt;setTimeout으로 2초딜레이 생성
        &lt;ul&gt;
          &lt;li&gt;promise로 딜레이 구현 가능&lt;/li&gt;
          &lt;li&gt;콜백 함수를 통해 동기화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;uniqueID생성
    &lt;ul&gt;
      &lt;li&gt;중복 없는 id&lt;/li&gt;
      &lt;li&gt;0부터 시작 1씩 증가하면서 ID생성&lt;/li&gt;
      &lt;li&gt;random으로 무작위 숫자 생성
        &lt;ul&gt;
          &lt;li&gt;더욱 완벽한 uniqueID를 위해서는 id의 중복, 삭제 작업을 관리하는 함수 제작 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prompt를 이용해 콘솔에 출력하여 개선 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;스스로 확인할 사항
    &lt;ul&gt;
      &lt;li&gt;충분히 디자인 과정을 했는가? 디자인이후 개발을 하면서 다시 잘못된 디자인을 수정했는가?
        &lt;ul&gt;
          &lt;li&gt;개발 과정에서 디자인에서 예상하지 못한 함수가 추가된 경우가 발생 했었다.&lt;/li&gt;
          &lt;li&gt;프로그램의 성능과 효율성에 따라 data의 자료구조 설계&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프로그램이 버그 없이 잘 동작하는가?
        &lt;ul&gt;
          &lt;li&gt;prompt가 아닌 write를 사용해 출력된문자가 백스페이스시 삭제 됨.&lt;/li&gt;
          &lt;li&gt;0부터 시작 1씩 증가하면서 ID생성시, 초기데이터의 ID값이 중복되는 문제를 해결해야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;3. Consideration&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;상태관리를 mutable 과 immutable 방식 중 어떤 것을 선택했는가? 이중 무엇이 왜 더 좋을까?
    &lt;ul&gt;
      &lt;li&gt;외부의 간섭에서 상태 변화를 막기위해 immutable방식으로 선택해야 한다.&lt;/li&gt;
      &lt;li&gt;immutable이어서 발생하는 버그를 수정하기위해&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.assign&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.freeze&lt;/code&gt; 등을 통해 패턴을 지키면서 구현&lt;/li&gt;
      &lt;li&gt;하지만 단점으로 삭제나 수정시 immutable일경우 메모리 낭비가 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;함수만으로 구현하는데 어떤 장점과 단점이 존재하는가 ?
    &lt;ul&gt;
      &lt;li&gt;여러곳에 중복으로 사용되었을때, 수정이 편함.&lt;/li&gt;
      &lt;li&gt;프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개념을 구현할 수가 없는 단점이 있다.&lt;/li&gt;
      &lt;li&gt;프로토타입이나 클래스 사용 시, 객체의 안정성을 보장할 수 있다. 하지만 함수만으로 구현 시 그렇지 않으므로, Immutable이나 순수함수와 같은 함수형 프로그래밍의 규칙에 따라 구현해야 객체의 안정성을 보장할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day6 대화형 할일관리 프로그램

## 왜 필요한가?
대부분의 프로그램은 사용자 입력에 즉각적으로 반응하면 동작한다. 

프로그램이 복잡해지면 모듈로 나누고,  각 모듈은 함수형태만을 유지하며 구성되게 할 수 있다.

복잡한 프로그래밍을 구현할때는 디자인을 먼저 하는 습관이 필요하다. 




## 학습 목표
- 프로그래밍 디자인을 할 수 있다.

- 사용자 입력을 받아서 코드를 구현할 수 있다.

- 자바스크립트 문자열 조작과 데이터상태의 변경을 할 수 있다.





------

## 미션

### 1. 스켈레톤 코드 구현

- 프로그램을 다 구현하기 전에 별도의 Skeleton code를 구현한 skeleton.js 파일을 생성하고, 이를 commit 하고 push한다.



### 2. todos.js 구현

- 다음과 같이 todo 데이터의 상태를 변경하는 개발을 한다.
- 초기 데이터를 JSON형태로 작성한다. 
- 클래스나 객체를 사용할수 없음.(todo데이터를 보관하기 위한 배열/객체 생성은 가능)
- todos.js 파일 하나에 모든 코드를 구현한다.
- Array의 reduce메서드를 1회 이상 적극 사용한다.
- 가급적 모든 코드가 함수안에 존재해야 한다.
- 3줄 이상의 중복코드는 함수를 사용해서 없앤다.
- id는 unique하게 생성돼야 한다.
- add 명령에서는 tag를 n개로 받을 수 있다.
- update 시에는 2초 delay후에 화면에 결과가 출력된다.


  ```javascript
  $  node todos.js
  
  명령하세요 : show$$current
  현재상태 :  todo:[123,124], doing:[123,444], done:[]
  
  명령하세요 : show$$todo
  todo리스트 :  총2건 : ' 자바스크립트 공부하기, 123번','iOS공부하기, 124번'
  
  명령하세요 : add$$docker공부하기$$[&quot;favorite&quot;,&quot;programming&quot;]
  docker공부하기가 추가됐습니다.(id : 7788)
  현재상태 :  todo:[123,124,7788], doing:[123,444], done:[]
  
  명령하세요 : update$$7788$$doing
  docker공부하기 doing으로 상태가 변경됐습니다
  현재상태 :  todo:[123,124], doing:[123,444, 7788], done:[]
  
  명령하세요 : delete$$7788
  docker공부하기가 doing목록에서 삭제됐습니다
  현재상태 :  todo:[123,124], doing:[123,444], done:[]

  명령하세요 : q
  (프로그램 종료)
  
  ```



-----

## 배경 지식



#### 배열과 객체

배열과 객체를 다루는 것이 익숙해야 이번 미션을 풀 수 있다. 

MDN사이트를 통해서 다양한 예제를 찾고, 이를 직접 코딩하면서 연습을 거친다. 



#### 프로그래밍 설계

프로그래밍 설계는 종이로 하는 것도 매우 훌륭하다. 특히나 페어프로그래밍 단계에서는 이렇게 매개체를 통해서 서로의 생각을 나누는 방법이 추천된다. code &amp; fix 하지 말고, **design &amp; code** !! 하기. 



설계는 다양한 방법이 있을 수 있다.

 OOP프로그래밍에서는 클래스 다이어그램을 그리기도하고, 함수형프로그래밍에서는 함수의 관계와 연결을 설계하기도 한다. 

이는 프로그래밍 설계에 대한 것이 인간의 창의적인 사고방식과 관련 있는 것이라, 그렇다. 

심지어. 대부분의 개발자는 코드에 대한 설계를 머리로 하거나, 종이에 끄적 거리는방법을 사용한다. 



아래방법들도 참고하고, 어떤 방법이든 프로그래밍의 알고리즘을 정리할 수 있는 방법을 시도해봐야 한다. 



[참고로 해볼만한 방법들]

- skeleton 코드란 무엇인지 살펴보고 따라해본다.
- pseudo 코드란 무엇인지 살펴보고 따라해본다.



### node.js 에서의 사용자 입력

대화형으로 동작하는 프로그램은, 계속 입력값을 받으면서 처리할 수 있어야 한다.

아래링크를 테스트 하면서 이방법을 알아본다.

참고.

```javascript
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.question('What do you think of Node.js? ', (answer) =&gt; {
  // TODO: Log the answer in a database
  console.log(`Thank you for your valuable feedback: ${answer}`);

  rl.close();
});
```

&lt;https://nodejs.org/api/readline.html&gt;


### data 구성

웹개발을 하다보면 클라이언트(브라우저)와 서버간의 데이터 통신이 필요하다. 
이때 주고받는 표준 포맷이 필요한데, 자주사용하는 것은 JSON형태이다. 
예시는 아래와 같다

```javascript
[
  {
    &quot;id&quot; : 123,
    values : ['lorem', 'xdof']
  },
  {
    &quot;id&quot; : 124,
    values : ['snffox', 'lorem']
  }
  ....
]
```

### 배열 조작
forEach메서드 이외에, filter, reduce 메서드의 사용법을 익혀보자.
특히 reduce는 매우 막강한 기능을 가지고 있는데, 사용법은 foreach, map, filter와 약간 다른점이 존재한다.
몇몇 예제를 익히면서 그 사용법을 잘 공부하도록 한다.


## 학습정리

### 피어 컴파일링 체크포인트

```
1. [ ] show$$current 실행
2. [ ] show$$todo 실행 
3. [ ] add 실행(태그는 2개이상)
4. [ ] update 실행(2초 지연 결과 노출)
5. [ ] delete 실행 
6. [ ] 'q'로 프로그램 종료
7. [ ] 3줄 이상의 중복코드가 없음
8. [ ] unique한 id 생성 확인
```

### 스스로 확인할 사항
- 충분히 디자인 과정을 했는가? 디자인이후 개발을 하면서 다시 잘못된 디자인을 수정했는가? 
- 프로그램이 버그 없이 잘 동작하는가? 



### 다같이 확인할 사항
- 아래 내용을 토론하고 정리해보자.
  - 상태관리를 mutable 과 immutable 방식 중 어떤 것을 선택했는가? 이중 무엇이 왜 더 좋을까? 
  - 함수만으로 구현하는데 어떤 장점과 단점이 존재하는가 ? 
--&gt;</content><author><name>이창권</name></author><summary type="html">대화형 할일 관리 프로그램 프로그래밍 디자인 학습, 문자열 및 데이터 조작 1. 코드 동작 이해 스켈레톤 작성 뼈대가 되는 함수와 인자들을 작성 테스트 케이스에 대해서 실행시 함수 용도를 알 수 있을정도로 콘솔에 표시하도록 작성. 실행으로 알 수 없는 부분들에 대해서는 주석으로 설명하는 것도 좋다 데이터 형식의 정의 데이터의 용도와 구현해야하는 함수에 따라 자료구조를 구성한다 2. 코드 동작 개선 2초 딜레이 출력 동기방식으로 출력돼야 함 커스텀 sleep 구현으로 2초딜레이 생성 setTimeout으로 2초딜레이 생성 promise로 딜레이 구현 가능 콜백 함수를 통해 동기화 uniqueID생성 중복 없는 id 0부터 시작 1씩 증가하면서 ID생성 random으로 무작위 숫자 생성 더욱 완벽한 uniqueID를 위해서는 id의 중복, 삭제 작업을 관리하는 함수 제작 필요 prompt를 이용해 콘솔에 출력하여 개선 가능 스스로 확인할 사항 충분히 디자인 과정을 했는가? 디자인이후 개발을 하면서 다시 잘못된 디자인을 수정했는가? 개발 과정에서 디자인에서 예상하지 못한 함수가 추가된 경우가 발생 했었다. 프로그램의 성능과 효율성에 따라 data의 자료구조 설계 프로그램이 버그 없이 잘 동작하는가? prompt가 아닌 write를 사용해 출력된문자가 백스페이스시 삭제 됨. 0부터 시작 1씩 증가하면서 ID생성시, 초기데이터의 ID값이 중복되는 문제를 해결해야함 3. Consideration 상태관리를 mutable 과 immutable 방식 중 어떤 것을 선택했는가? 이중 무엇이 왜 더 좋을까? 외부의 간섭에서 상태 변화를 막기위해 immutable방식으로 선택해야 한다. immutable이어서 발생하는 버그를 수정하기위해Object.assign,Object.freeze 등을 통해 패턴을 지키면서 구현 하지만 단점으로 삭제나 수정시 immutable일경우 메모리 낭비가 발생한다. 함수만으로 구현하는데 어떤 장점과 단점이 존재하는가 ? 여러곳에 중복으로 사용되었을때, 수정이 편함. 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개념을 구현할 수가 없는 단점이 있다. 프로토타입이나 클래스 사용 시, 객체의 안정성을 보장할 수 있다. 하지만 함수만으로 구현 시 그렇지 않으므로, Immutable이나 순수함수와 같은 함수형 프로그래밍의 규칙에 따라 구현해야 객체의 안정성을 보장할 수 있다.</summary></entry><entry><title type="html">부스트 캠프 Day5</title><link href="https://changgunyee.github.io/boost-camp/2019/07/22/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day5.html" rel="alternate" type="text/html" title="부스트 캠프 Day5" /><published>2019-07-22T00:00:00+09:00</published><updated>2019-07-22T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/22/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day5</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/22/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day5.html">&lt;h1 id=&quot;디버깅&quot;&gt;디버깅&lt;/h1&gt;

&lt;p&gt;개발자가 개발환경과 디버깅방법 이해하기&lt;/p&gt;

&lt;h2&gt;1. 코드 동작 이해&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;제네레이터함수
    &lt;ul&gt;
      &lt;li&gt;함수내에서 정지 시점을 정해서 조절이 가능한 함수.&lt;/li&gt;
      &lt;li&gt;yield를 통해 정지가 가능&lt;/li&gt;
      &lt;li&gt;이후 next()를 통해 정지를 한 yield로부터 시작.&lt;/li&gt;
      &lt;li&gt;메모리 효율에 기여 가능.&lt;/li&gt;
      &lt;li&gt;참고 블로그 URL: &lt;a href=&quot;https://velog.io/@rohkorea86/Generator-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90-%EC%9D%B4%EB%A1%A0%ED%8E%B8-%EC%99%9C-%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%8D%A8%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80&quot;&gt;https://velog.io/@rohkorea86/Generator-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90-%EC%9D%B4%EB%A1%A0%ED%8E%B8-%EC%99%9C-%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%8D%A8%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;promise
    &lt;ul&gt;
      &lt;li&gt;자바스크립트의 특성인 비동기를 해결하기위해 콜백함수를 사용하는데 가독성이 떨어지는것을 해결하기위해 사용&lt;/li&gt;
      &lt;li&gt;에러처리가 편함&lt;/li&gt;
      &lt;li&gt;프로미스의 상태 3가지
        &lt;ul&gt;
          &lt;li&gt;pending대기    - 비동기 처리 로직이 아직 완료 안됨&lt;/li&gt;
          &lt;li&gt;fulfilled이행     - 비동기 처리 로직이 완료 , 결과값 반환 상태&lt;/li&gt;
          &lt;li&gt;rejected실패    - 비동기 처리가 실패, 오류가 발생&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;참고 : &lt;a href=&quot;https://joshua1988.github.io/web-development/javascript/promise-for-beginners&quot;&gt;https://joshua1988.github.io/web-development/javascript/promise-for-beginners&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callbackFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;url 주소/products/1&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;callbackFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 서버에서 받은 데이터 response를 callbackFunc() 함수에 넘겨줌&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tableData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tableData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $.get()의 response 값이 tableData에 전달됨&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;


&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// new Promise() 추가&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;url 주소/products/1&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 데이터를 받으면 resolve() 호출&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// getData()의 실행이 끝나면 호출되는 then()&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tableData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// resolve()의 결과 값이 여기로 전달됨&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tableData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $.get()의 reponse 값이 tableData에 전달됨&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;this의 scope 해결
    &lt;ul&gt;
      &lt;li&gt;bind를 통해 연결&lt;/li&gt;
      &lt;li&gt;this를 저장하여 사용&lt;/li&gt;
      &lt;li&gt;this가 필요없도록 class외부로 꺼내서 사용&lt;/li&gt;
      &lt;li&gt;arrow function을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;git의 branch에 대해서 이해를 하고 있는가?
    &lt;ul&gt;
      &lt;li&gt;다양한 git workflow에 따라 branch전략이 달라진다.&lt;/li&gt;
      &lt;li&gt;각 용도에 맞는 branch에서 개발자가 따로 작업&lt;/li&gt;
      &lt;li&gt;pull request를 통해서 merge를 하여 branch를 합친다.&lt;/li&gt;
      &lt;li&gt;기본적인 git work flow : 항상 유지되는 메인 브랜치들(master, develop)과 일정 기간 동안만 유지되는 보조 브랜치들(feature, release, hotfix)을 포함하여 총 5가지의 브랜치를 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디버깅단계에서 breakpoint를 사용하면서 문제를 해결하려고 했는가?
    &lt;ul&gt;
      &lt;li&gt;실행 중간에 변수를 확인하거나, 실행 순서를 확인하기 위해 사용함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;3. Consideration&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;각자 어떤 디버깅 방법을 사용해보았는가? 이 부분을 모두 이야기하고 적어보자.
    &lt;ul&gt;
      &lt;li&gt;breakpoint를 통해 특정 지점이나 오류난 부분을 정지하여, 변수값을 확인하며 진행.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로젝트에서 npm 명령어를 활용해 추가로 외부 모듈을 설치했을때 package.json에 어떤 변화가 생기는지 설명하자.
    &lt;ul&gt;
      &lt;li&gt;dependency에 설치한 외부 모듈명과 모듈 버전이 추가된다.&lt;/li&gt;
      &lt;li&gt;이로 인해 require(“underscore”)로 호출이 가능해졌다.
        &lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;&quot;dependencies&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;underscore&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.9.1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;node_modules 디렉토리는 어떤 역할을 하는 디렉토리 인가 설명해보자.
    &lt;ul&gt;
      &lt;li&gt;npm으로 다운받은 외부 모듈이 저장되는 장소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;export, require 동작방식에 대해서 설명해보자.
    &lt;ul&gt;
      &lt;li&gt;commonJs에서 사용하는 모듈 사용 방식(vs ES6의 import,export)&lt;/li&gt;
      &lt;li&gt;모듈을 require할 때마다 새로운 인스턴스가 생성되는 것이 아니라 캐싱된 객체 인스턴스를 재사용함&lt;/li&gt;
      &lt;li&gt;key값으로 해당 모듈 파일의 경로를 갖게 되는데 key값이 삭제된다면 다음 require 요청시 다시 재로딩하게 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;추가
    &lt;ul&gt;
      &lt;li&gt;module.exports 와 exports는 같다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day5 디버깅

## 왜 필요한가?
- 개발자가 개발환경과 디버깅방법을 잘 이해하는 것은 필수이다. 효율적이고 생산적인 프로그램을 할 수 있다.
- 프로그래밍 소스는 다양하게 변경되고 발전되며, 그 과정에서 버전별로 잘 관리할 필요가 있다. 

## 학습 목표
- vscode도구에서 Node.js 프로그래밍을 실행하고 디버깅할 수 있다.
- NPM환경에 대한 기본이해를 한다.
- git 을 통한 프로그래밍 소스관리에 대한 기본 이해를 한다.



----
## 미션

### 1. 프로그래밍의 문제를 해결해서 올바른 출력을 한다
code : https://gist.github.com/nigayo/df0f0919d04900966154ab512b21cdfb

- 예상 결과
b.js 를 실행하면, run메서드가 두번 호출되며, 아래 결과가 화면에 출력돼야 한다.

```shell
step1$ node b.js
error없이 프로그래밍이 실행됐습니다
이크 에러가 발생했어요 'who are you?' == 'hello our members!'
```



### 2. 디버깅과정을 코드 상단에 주석으로 5줄 미만으로 작성한다.

이 문제를 해결하기 위해서 vscode를 어떻게 활용했는지 주석으로 그 과정을 자세하게 작성한다. 



### 프로그램조건 

- 현재 발생하는 버그(에러)를 모두 해결한다.
- 결과는 VSCode 콘솔에 출력된다.
- b.js 는 수정할 수 없으며 다른파일은 수정할 수 있음.



----

## 배경 지식

### VSCode-Node.js  debugging

debugging은 문제를 해결하는 과정이다. 보통 개발도구를 통해서 프로그램이 동작되는 과정에서 생기는 문제를 찾을 수 있다.

예를들어 소스코드의 특정 line에서 breakpoint를 지정하면 프로그램은 그 line에서 동작을 멈추고 더이상 실행되지 않는다. 멈춘 상태에서 변수값등을 확인하면서 문제를 찾아나갈 수 있다. 



vscode에서 nodejs디버깅 방법을 익혀보자. 공식홈페이지의 디버깅 방법을 공부한다.
https://code.visualstudio.com/docs/editor/debugging
https://code.visualstudio.com/docs/editor/debugging#nodejs-articles



디버깅 과정에서 중요하게 이해해야 할 방법들.

- breakpoints란
- watch사용법
- call stack 의 의미
- Step over / Step into/ Step out 




### NodeJS 의 module 방식의 프로그래밍에 대해서 공부해보자. 

먼저 Node.js 기반의 프로젝트를 만드는 방법과 외부모듈을 설치하는 방법을 익혀본다. 

- npm init : 프로젝트 디렉토리 초기화 명령어이다.
- package.json : npm init 한 이후에 생성되는 npm 프로젝트에 대한 환경정보이다.
- npm install 특정모듈 : 특정모듈을 설치하기 위한 방법이다. 



Modular programming 은 모듈방식으로 프로그램을 나누고, 이를 통해 복잡한 애플리케이션의 역할을 나눠서 문제를 해결한다. NodeJS에서도 이를 지원하다. 

- require, exports !!
- 참고 : https://nodejs.org/api/modules.html
- 공식사이트의 튜터리얼을 따라해서 export 와 require를 사용해보자.



------

## 학습정리

### 피어 컴파일링 체크포인트

```
1. [ ] b.js를 실행 후 두 개의 결과확인(성공과 에러발생)
2. [ ] b.js 코드가 수정되지 않았는지 확인
3. [ ] 주석내에 있는 디버깅과정이 실제 이 문제를 해결하는 내용이 맞는지 확인
```

### 스스로 확인할 사항
- git의 branch에 대해서 이해를 하고 있는가? 
- 디버깅단계에서 breakpoint를 사용하면서 문제를 해결하려고 했는가?


### 다같이 확인할 사항
- 각자 어떤 디버깅 방법을 사용해보았는가? 이 부분을 모두 이야기하고 적어보자.
- 프로젝트에서 npm 명령어를 활용해 추가로 외부 모듈을 설치했을때 package.json에 어떤 변화가 생기지 설명하자.
- node_modules 디렉토리는 어떤 역할을 하는 디렉토리 인가 설명해보자.
- export, require 동작방식에 대해서 설명해보자.
--&gt;</content><author><name>이창권</name></author><summary type="html">디버깅 개발자가 개발환경과 디버깅방법 이해하기 1. 코드 동작 이해 제네레이터함수 함수내에서 정지 시점을 정해서 조절이 가능한 함수. yield를 통해 정지가 가능 이후 next()를 통해 정지를 한 yield로부터 시작. 메모리 효율에 기여 가능. 참고 블로그 URL: https://velog.io/@rohkorea86/Generator-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90-%EC%9D%B4%EB%A1%A0%ED%8E%B8-%EC%99%9C-%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%8D%A8%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80 promise 자바스크립트의 특성인 비동기를 해결하기위해 콜백함수를 사용하는데 가독성이 떨어지는것을 해결하기위해 사용 에러처리가 편함 프로미스의 상태 3가지 pending대기 - 비동기 처리 로직이 아직 완료 안됨 fulfilled이행 - 비동기 처리 로직이 완료 , 결과값 반환 상태 rejected실패 - 비동기 처리가 실패, 오류가 발생 참고 : https://joshua1988.github.io/web-development/javascript/promise-for-beginners function getData(callbackFunc) { $.get('url 주소/products/1', function (response) { callbackFunc(response); // 서버에서 받은 데이터 response를 callbackFunc() 함수에 넘겨줌 }); } getData(function (tableData) { console.log(tableData); // $.get()의 response 값이 tableData에 전달됨 }); --&amp;gt; function getData(callback) { // new Promise() 추가 return new Promise(function (resolve, reject) { $.get('url 주소/products/1', function (response) { // 데이터를 받으면 resolve() 호출 resolve(response); }); }); } // getData()의 실행이 끝나면 호출되는 then() getData().then(function (tableData) { // resolve()의 결과 값이 여기로 전달됨 console.log(tableData); // $.get()의 reponse 값이 tableData에 전달됨 }); this의 scope 해결 bind를 통해 연결 this를 저장하여 사용 this가 필요없도록 class외부로 꺼내서 사용 arrow function을 사용 2. 코드 동작 개선 git의 branch에 대해서 이해를 하고 있는가? 다양한 git workflow에 따라 branch전략이 달라진다. 각 용도에 맞는 branch에서 개발자가 따로 작업 pull request를 통해서 merge를 하여 branch를 합친다. 기본적인 git work flow : 항상 유지되는 메인 브랜치들(master, develop)과 일정 기간 동안만 유지되는 보조 브랜치들(feature, release, hotfix)을 포함하여 총 5가지의 브랜치를 사용한다. 디버깅단계에서 breakpoint를 사용하면서 문제를 해결하려고 했는가? 실행 중간에 변수를 확인하거나, 실행 순서를 확인하기 위해 사용함. 3. Consideration 각자 어떤 디버깅 방법을 사용해보았는가? 이 부분을 모두 이야기하고 적어보자. breakpoint를 통해 특정 지점이나 오류난 부분을 정지하여, 변수값을 확인하며 진행. 프로젝트에서 npm 명령어를 활용해 추가로 외부 모듈을 설치했을때 package.json에 어떤 변화가 생기는지 설명하자. dependency에 설치한 외부 모듈명과 모듈 버전이 추가된다. 이로 인해 require(“underscore”)로 호출이 가능해졌다. &quot;dependencies&quot;: { &quot;underscore&quot;: &quot;^1.9.1&quot; } node_modules 디렉토리는 어떤 역할을 하는 디렉토리 인가 설명해보자. npm으로 다운받은 외부 모듈이 저장되는 장소 export, require 동작방식에 대해서 설명해보자. commonJs에서 사용하는 모듈 사용 방식(vs ES6의 import,export) 모듈을 require할 때마다 새로운 인스턴스가 생성되는 것이 아니라 캐싱된 객체 인스턴스를 재사용함 key값으로 해당 모듈 파일의 경로를 갖게 되는데 key값이 삭제된다면 다음 require 요청시 다시 재로딩하게 됨 추가 module.exports 와 exports는 같다.</summary></entry><entry><title type="html">react native로 iOS 앱 개발하고 등록하기</title><link href="https://changgunyee.github.io/develop/2019/07/20/iOS-%EC%95%B1-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0.html" rel="alternate" type="text/html" title="react native로 iOS 앱 개발하고 등록하기" /><published>2019-07-20T00:00:00+09:00</published><updated>2019-07-20T00:00:00+09:00</updated><id>https://changgunyee.github.io/develop/2019/07/20/iOS%20%EC%95%B1%20%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://changgunyee.github.io/develop/2019/07/20/iOS-%EC%95%B1-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0.html">&lt;p&gt;react-native로 앱을 만들고 등록하는 과정중의 에러나 힘들었던 사항들을 정리하였습니다.&lt;/p&gt;

&lt;h1 id=&quot;xcode로-ios개발-시-빌드-방법error처리-포함&quot;&gt;Xcode로 iOS개발 시 빌드 방법(Error처리 포함)&lt;/h1&gt;

&lt;h2 id=&quot;build전-수행해야할-사항&quot;&gt;Build전 수행해야할 사항&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save&lt;/code&gt; : node_modules directory생성
  (후에 pod에서 node_modules안의 파일을 건드리기 때문에 sudo는 쓰지말도록 합니다.)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;react-native link&lt;/code&gt; : node.js패키지를 react-native에서 쓰기 위해 native code상의 필요한 부분에 코드를 주입시켜줍니다. link 명령어를 지원하지 않거나 manual한 link방법을 추천하는 패키지도 존재하므로 패키지 별로 문서를 한번 씩 읽어보는 것도 좋습니다.(현재 사용하는 패키지에서는 다 link사용 가능)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ios&lt;/code&gt;&amp;amp;&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt; : node.js package를 바로 ios에서 쓰기 위해서는 패키지 관리자를 사용하여야 하는데 이것이 pod입니다. package.json=Podfile, package-lock.jso=Podfile.lock, node_modules=Pods입니다.
(Pod와 관련해서 에러가 난다면 Podfile.lock, Pods를 삭제 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;을 합니다.)&lt;/li&gt;
  &lt;li&gt;이제 Xcode에서 .xcworkspace파일을 엽니다(Pod를 쓰기 때문에 .xcodeproj대신 .xcworkspace를 엽니다)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build-시-발생하는-주요-에러&quot;&gt;Build 시 발생하는 주요 에러&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;third-party와 관련되어 에러가 날 수 있습니다.(파일이 없습니다. 어쩌구 저쩌구….)
    &lt;ul&gt;
      &lt;li&gt;third-party에서 패키지를 제대로 설치하지 못하는 모양입니다. 수동으로 해줍시다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd node_modules/react-native/third-party/glog-0.3.4&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./configure&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;&amp;amp;&lt;code class=&quot;highlighter-rouge&quot;&gt;make install&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;소스파일로 된 패키지를 설치하실 때 기본적으로 내리는 3가지 명령어가 있는데 그것이 바로
configure, make, make install 입니다.&lt;/p&gt;

&lt;p&gt;여기서 소스파일이란 것은 설치파일에 대한 소스 파일입니다.
그러므로 컴파일을 하고나면 설치파일이 생기는 것이죠. 그리고 위의 세가지 명령에 대해 알아보도록 하죠.&lt;/p&gt;

&lt;p&gt;configure 는 환경설정을 해주는 명령어입니다. 
컴파일을 할 때 어떤 옵션을 넣거나 할 때 configure 뒤에 옵션을 넣어줍니다. 
여기에 어떤 옵션이 정확히 들어간다고 말씀드릴 수 있는 것은 아니고 소스를 제작한 자가 readme 파일 등에
명시되어 있습니다.&lt;/p&gt;

&lt;p&gt;make 는 소스를 컴파일 하는 것입니다. 컴파일이란 것은 소스파일을 사용자가 실행 가능한 파일로 만들어 주는
과정을 말합니다. make 과정이 끝나고 나면 설치파일이 생성된 상태라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;make install 은 설치를 하는 과정입니다. 앞 과정에서 생성된 설치파일을 실행해서 설치를 끝내는 과정입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;No member named ‘__rip’ in ‘__darwin_arm_thread_state64’&lt;/strong&gt; 에러
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ucontext_t *context = reinterpret_cast&amp;lt;ucontext_t *&amp;gt;(ucontext_in_void);&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;return (void*)context-&amp;gt;PC_FROM_UCONTEXT; // &amp;lt;---- build error here&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;return NULL;&lt;/code&gt;로 code를 직접 수정해줍니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;앱-등록시-reject-사유&quot;&gt;앱 등록시 reject 사유&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;구글 로그인 시 보안을 다 풀어두어도 새로운 핸드폰에서 로그인시 인증을 한번 거쳐야 한다. 하지만 Reviewer들은 해주지 않는다. 우리가 제공하는 계정은 가장 높은 권한을 가진 바로 로그인할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;구글 콘솔 상에서 OAuth인증 파트에서 사용하는 API가 느낌표가 떠있으면 로그인 시에 &lt;strong&gt;this app is not verified&lt;/strong&gt; 라는 것이 뜨는데, 보통의 경우에는 advanced를 눌러 진행할 수 있지만 Reviewer는 이것을 reject사유로 잡는다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>이창권</name></author><summary type="html">react-native로 앱을 만들고 등록하는 과정중의 에러나 힘들었던 사항들을 정리하였습니다. Xcode로 iOS개발 시 빌드 방법(Error처리 포함) Build전 수행해야할 사항 npm install --save : node_modules directory생성 (후에 pod에서 node_modules안의 파일을 건드리기 때문에 sudo는 쓰지말도록 합니다.) react-native link : node.js패키지를 react-native에서 쓰기 위해 native code상의 필요한 부분에 코드를 주입시켜줍니다. link 명령어를 지원하지 않거나 manual한 link방법을 추천하는 패키지도 존재하므로 패키지 별로 문서를 한번 씩 읽어보는 것도 좋습니다.(현재 사용하는 패키지에서는 다 link사용 가능) cd ios&amp;amp;pod install : node.js package를 바로 ios에서 쓰기 위해서는 패키지 관리자를 사용하여야 하는데 이것이 pod입니다. package.json=Podfile, package-lock.jso=Podfile.lock, node_modules=Pods입니다. (Pod와 관련해서 에러가 난다면 Podfile.lock, Pods를 삭제 후, pod install을 합니다.) 이제 Xcode에서 .xcworkspace파일을 엽니다(Pod를 쓰기 때문에 .xcodeproj대신 .xcworkspace를 엽니다) Build 시 발생하는 주요 에러 third-party와 관련되어 에러가 날 수 있습니다.(파일이 없습니다. 어쩌구 저쩌구….) third-party에서 패키지를 제대로 설치하지 못하는 모양입니다. 수동으로 해줍시다. cd node_modules/react-native/third-party/glog-0.3.4 ./configure make&amp;amp;make install 소스파일로 된 패키지를 설치하실 때 기본적으로 내리는 3가지 명령어가 있는데 그것이 바로 configure, make, make install 입니다. 여기서 소스파일이란 것은 설치파일에 대한 소스 파일입니다. 그러므로 컴파일을 하고나면 설치파일이 생기는 것이죠. 그리고 위의 세가지 명령에 대해 알아보도록 하죠. configure 는 환경설정을 해주는 명령어입니다. 컴파일을 할 때 어떤 옵션을 넣거나 할 때 configure 뒤에 옵션을 넣어줍니다. 여기에 어떤 옵션이 정확히 들어간다고 말씀드릴 수 있는 것은 아니고 소스를 제작한 자가 readme 파일 등에 명시되어 있습니다. make 는 소스를 컴파일 하는 것입니다. 컴파일이란 것은 소스파일을 사용자가 실행 가능한 파일로 만들어 주는 과정을 말합니다. make 과정이 끝나고 나면 설치파일이 생성된 상태라고 볼 수 있습니다. make install 은 설치를 하는 과정입니다. 앞 과정에서 생성된 설치파일을 실행해서 설치를 끝내는 과정입니다. No member named ‘__rip’ in ‘__darwin_arm_thread_state64’ 에러 ucontext_t *context = reinterpret_cast&amp;lt;ucontext_t *&amp;gt;(ucontext_in_void); return (void*)context-&amp;gt;PC_FROM_UCONTEXT; // &amp;lt;---- build error here 를 return NULL;로 code를 직접 수정해줍니다. 앱 등록시 reject 사유 구글 로그인 시 보안을 다 풀어두어도 새로운 핸드폰에서 로그인시 인증을 한번 거쳐야 한다. 하지만 Reviewer들은 해주지 않는다. 우리가 제공하는 계정은 가장 높은 권한을 가진 바로 로그인할 수 있어야 한다. 구글 콘솔 상에서 OAuth인증 파트에서 사용하는 API가 느낌표가 떠있으면 로그인 시에 this app is not verified 라는 것이 뜨는데, 보통의 경우에는 advanced를 눌러 진행할 수 있지만 Reviewer는 이것을 reject사유로 잡는다.</summary></entry><entry><title type="html">부스트 캠프 Day4</title><link href="https://changgunyee.github.io/boost-camp/2019/07/18/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day4.html" rel="alternate" type="text/html" title="부스트 캠프 Day4" /><published>2019-07-18T00:00:00+09:00</published><updated>2019-07-18T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/18/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day4</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/18/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day4.html">&lt;h1 id=&quot;논리게이트&quot;&gt;논리게이트&lt;/h1&gt;

&lt;p&gt;기본 게이트와 반가산기, 전가산기, 바이트 가산기 구현&lt;/p&gt;

&lt;h2&gt;1. 코드 동작 이해&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;NAND
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;NOT + AND Gate BitA, BitB의 AND연산 결과값에 반전 결과값을 제공한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;입력값이 전부 같지 않은지를 판별하는 경우에 사용될 수 있다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NOR&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Not + OR GAte BitA, BitB의 OR연산의 반전 결과값을 제공한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;입력값이 False로만 이루어진 경우 True를 반환한다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XOR&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;입력값이 서로 다른 경우인지를 확인하는 Gate&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;BitA 와 BitB 가 서로 다른 경우일 경우만 True를 반환&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Half-Adder&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;반쪽자리 계산기로 두 개의 비트에 대해서 연산을 제공한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;BitA, BitB에 대해 Carry와 Sum 인자를 제공&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Carry : nand(bitA, bitB) / Sum : xor(bitA,bitB)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Full-Adder&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;2개의 Half-Adder로 구성된 회로&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;BitA, BitB, Carry 3개의 입력값을 가진다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Carry는 이전 연산의 오버플로우 값(1bit 기준)으로 현재 연산에 영향을 끼치는 요소이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;결과 값 Carry는 현재 입력값 중 2개 이상이 true값을 가지는 경우 True가 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;결과 값 Sum은 현재 입력값 중 True가 2개가 아닌경우 True가 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Carry : ab + bc + ca&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Sum : abc + ab&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; + a&lt;code class=&quot;highlighter-rouge&quot;&gt;bc&lt;/code&gt; + a&lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;c&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Byte(8bits) Adder&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;초기 입력 Carry값은 false로 설정된 Full-Adder를 이용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;입력값 중 8bit가 안되는 경우 Zero-Padding을 이용한다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Binary to Decimal  &lt;br /&gt;
  ##### Case1 -  MSB가 0번 Index에 위치하는 경우
    &lt;ul&gt;
      &lt;li&gt;현재 값을 더할 pow(2,i)를 기억할 공간이 줄어든다.&lt;/li&gt;
      &lt;li&gt;이전 결과값에 2를 곱한후 현재 비트 값을 더하는 방식으로 구현&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;##### case 2 - MSB가 Last Index에 위치하는 경우&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;현재 index의 가중치를 계산해줄 pow변수가 필요&lt;/li&gt;
      &lt;li&gt;loop당 곱셈연산이 1번 추가된다.&lt;/li&gt;
      &lt;li&gt;사용자기준에서는 읽기 편하다는 장점이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Decimal to Binary&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;이전 값에 2로 나눈 나머지 값을 저장하는 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mod 연산 이후 현재 값을 2로 나눈 정수값을 다음 입력값으로 사용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;입력값이 0이 될 경우까지 반복된다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;두 개의 bitArray 중 길이가 긴 bitArray의 길이에 맞추어 연산을 하면 길이가 다른 2개의 bitArray가 들어와도 유연하게 처리가 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Boolean으로 타입을 변환하는 방법 뿐만 아니라 “!!”를 통해서도 Boolean 타입으로 변경이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;3. Consideration&lt;/h2&gt;

&lt;h3 id=&quot;바이트-순서를-큰-비트most-significant-bit를-좌측으로-배치하는-것과-우측으로-배치하는-방식이-구현할-때-어떤-장점이-있나&quot;&gt;바이트 순서를 큰 비트(Most Significant Bit)를 좌측으로 배치하는 것과 우측으로 배치하는 방식이 구현할 때 어떤 장점이 있나?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;큰 비트를 좌측으로 배치하는 것을 빅 엔디언, 우측으로 배치하는 방식을 리틀 엔디언이라고 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;빅엔디언은 사람이 숫자를 읽고 쓰는 방법과 같기 때문에 개발자의 소프트웨어 디버깅을 편하게 해주는 장점이 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리틀 엔디언은 하위 바이트들만 사용할 때는 별도의 계산이 필요가 없고,가산기와 같은 모듈 설계시 LSB부터 시작하여 자리 올림 계산을 하기 때문에 설계가 더 쉽다는 장점이 있다.(ex. 순회시 정방향)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;같은-방식으로-2진수를-16진법으로-변환하는-함수를-만든다면-어떤-구조가-될까&quot;&gt;같은 방식으로 2진수를 16진법으로 변환하는 함수를 만든다면 어떤 구조가 될까&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;binary를 4bit씩 묶어 10진수로 계산해 변경&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2진수 -&amp;gt; 10진수 -&amp;gt; 16진수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;16진수를 표기하기 위한 방법을 추가(10-15 -&amp;gt; A-F)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;같은-방식으로-16진수를-2진법으로-변환하는-함수를-만든다면-어떤-구조가-될까&quot;&gt;같은 방식으로 16진수를 2진법으로 변환하는 함수를 만든다면 어떤 구조가 될까&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;16진수 -&amp;gt; 10진수 -&amp;gt; 2진수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;16진수를 읽어내기 위한 방법을 추가(A-F -&amp;gt; 10-15)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day4 논리게이트

## 왜 필요한가?
디지털 논리회로는 컴퓨터 구조에서 가장 기초가 되는 지식을 포함한다.
디지털 논리회로를 연결해서 CPU나 메모리 같은 컴퓨터를 구성하는 부품을 만들게 된다.
디지털 논리회로는 논리적인 사고를 위한 가장 기본이 되는 동작이며, 자연스럽게 프로그래밍 논리 구조와 연결된다. 
디지털 논리회로로 사칙연산을 구현할 수 있고, 현대 CPU에는 ALU 부품으로 구현되어 있다.

## 학습 목표
- 디지털 논리회로 기본 부품(AND, OR, NOT)을 응용해서 만들 수 있는 부가적인 회로에 대해 학습한다.
- 학습한 디지털 논리회로 기본 부품만 활용해서 만들 수 있는 부가적인 회로를 연결해서, 이진 덧셈기를 만든다.
- 우선 1비트를 더하는 반쪽덧셈기(half-adder)를 만들고, 8비트를 처리하는 전체덧셈기(full-adder)를 만든다.
- BOOL 타입으로 만든 8비트 덧셈기에 값을 전달하고, 전달받은 값을 표시하기 위해서 값을 변환하는 함수를 구현한다.


## 미션

### NAND 게이트 함수

- NAND 게이트 동작을 함수로 구현합니다.
- 함수의 매개변수는 BOOL 타입을 갖는 두 개를 갖고, 결과값은 BOOL 타입으로 리턴합니다.
- paramA 와 paramB 가 모두 true 일 때만 결과가 false 가 되고, 나머지 다른 경우는 모두 true가 됩니다.

&gt; 함수 시그니처 예시

```cpp
bool nand(bool paramA, bool paramB) {
    bool answer = true;
    // 여기에 원하는 동작을 구현하세요
    return answer;
}
```

### NOR 게이트 함수

- NOR게이트 동작을 구현합니다.
- 함수의 매개변수는 BOOL 타입을 갖는 두 개를 갖고, 결과값은 BOOL 타입으로 리턴합니다.
- paramA 와 paramB 가 모두 false 일 때만 결과가 true 가 되고, 나머지 다른 경우는 모두 false가 됩니다.

&gt; 함수 시그니처 예시

```cpp
bool nor(bool paramA, bool paramB) {
    bool answer = true;
    // 여기에 원하는 동작을 구현하세요
    return answer;
}
```

### XOR 게이트 함수

- XOR게이트 동작을 구현합니다.
- 함수의 매개변수는 BOOL 타입을 갖는 두 개를 갖고, 결과값은 BOOL 타입으로 리턴합니다.
- paramA 와 paramB 가 서로 다른 값일 때만 결과가 true 가 되고, 같은 값인 경우는 모두 false가 됩니다.

&gt; 함수 시그니처 예시

```cpp
bool xor(bool paramA, bool paramB) {
    bool answer = true;
    // 여기에 원하는 동작을 구현하세요
    return answer;
}
```


### 반쪽덧셈 함수와 전체덧셈 함수

덧셈은 숫자 연산에서 가장 기본이 되는 동작입니다. 

- BOOL 타입으로 동작하는 이진 덧셈기를 논리 게이트 동작만으로 구현해봅니다.
- 합(sum) : 합을 구하는 내부 함수를 구현합니다.
- 자리올림(carry) : 자리올림 비트를 구하는 내부 함수를 구현합니다.
- 반쪽덧셈(halfadder) : 입력을 두 개 받아서, 합(sum)과 자리올림(carry)를 배열로 리턴하는 함수를 구현합니다.

- 반쪽덧셈 예상 결과

```
byteA  = true
byteB  = true
결과 = [true, false]
```

```
byteA  = true
byteB  = false
결과 = [false, true]
```

- 전체덧셈(fulladder) : 입력을 두 개와 자리올림 비트를 입력으로 받아서, 합(sum)과 자리올림(carry)를 배열로 리턴하는 함수를 구현합니다.

- 전체덧셈 예상 결과

```
byteA  = true
byteB  = true
carry  = true
결과 = [true, true]
```

```
byteA  = true
byteB  = false
carry  = true
결과 = [true, false]
```

#### 함수 시그니처 예시

&gt; 자바

```java
class Adder {
    public boolean[] halfadder(boolean bitA, boolean bitB) {
        boolean[] answer = {};
        return answer;
    }
    public boolean[] fulladder(boolean bitA, boolean bitB, boolean carry) {
        boolean[] answer = {};
        return answer;
    }
}
```

&gt; 자바스크립트

```javascript
function halfadder(bitA, bitB) {
    var answer = [];
    return answer;
}

function fulladder(bitA, bitB, carry) {
    var answer = [];
    return answer;
}
```

### 8비트 덧셈기

앞에서 만든 이진 덧셈기를 이용해서 BOOL 타입으로 동작하는 8비트 덧셈기를 구현한다.

- 바이트 덧셈(byteadder) : 8비트를 BOOL타입 배열로 2개를 입력 받는다.
- 자리올림(carry) + 전체 합(sum)을 순서대로 배열로 담아서 리턴하는 함수를 구현한다.
- 입력으로 들어오는 byteA, byteB 배열의 길이는 같다고 가정한다.
- 입력으로 들어오는 byteA 비트 순서는 낮은 자리가 배열의 앞쪽에 오도록 표현한다. 배열의 순서대로 보면 이진수가 뒤집혀 있는 것처럼 보인다고 가정한다.
- 아래 예시에서는 true 대신 1로 표시, false 대신 0으로 표시한다. 

`이진수 1100 = [ 0, 0, 1, 1 ]`  `이진수 0101 = [ 1, 0, 1, 0 ]`

- 덧셈 예상 결과

```
byteA  = [ 1, 1, 0, 1, 1, 0, 1, 0 ]
byteB  = [ 1, 0, 1, 1, 0, 0, 1, 1 ]
   결과 = [ 0, 0, 0, 1, 0, 1, 0, 0, 1 ]
```

```
byteA  = [ 1, 1, 0, 0, 1, 0, 1, 0 ]
byteB  = [ 1, 1, 0, 1, 1, 0, 0, 1 ]
   결과 = [ 0, 1, 1, 1, 0, 1, 1, 1, 0 ]
```

#### 함수 시그니처 예시

&gt; Java

```java
class Adder {
    public boolean[] byteadder(boolean[] byteA, boolean[] byteB) {
        boolean[] answer = {};
        return answer;
    }
}
```


&gt; 자바스크립트

```javascript
function byteadder(byteA, byteB) {
    var answer = [];
    return answer;
}
```


### 10진수 -&gt; 2진수 변환 함수

0부터 256 미만의 `Int` 정수형 10진수를 `[Bool]` 2진수 배열로 변환하는 dex2bin 함수를 구현한다.
- 사칙연산만으로 변환하는 방식을 구현한다.
- 만들어지는 비트 순서는 낮은 자리가 배열의 앞쪽에 오도록 표현한다. 배열의 순서대로 보면 이진수가 뒤집혀 있는 것처럼 보인다고 가정한다.
- 아래 예시에서는 true 대신 1로 표시, false 대신 0으로 표시한다. 

`이진수 1100 = [ 0, 0, 1, 1 ]`  `이진수 0101 = [ 1, 0, 1, 0 ]`

- 예상 결과

```
입력  = 10
결과 = [0, 1, 0, 1]

입력  = 173
결과 = [1,0,1,1,0,1,0,1]
```

&gt; 함수 시그니처 예시

&gt; 자바
```java
class Convertor {
    public boolean[] dec2bin(int decimal) {
        boolean[] answer = {};
        return answer;
    }
}
```

&gt; 자바스크립트
```javascript
function dec2bin(decimal) {
    var answer = [];
    return answer;
}
```


### 2진수 -&gt; 10진수 변환 함수

`[Bool]` 2진수 배열을  `Int` 정수형 10진수로 변환하는 bin2dec 함수를 구현한다.

- 사칙연산만으로 변환하는 방식을 구현한다.
- 입력하는 비트 순서는 낮은 자리가 배열의 앞쪽에 오도록 표현한다. 배열의 순서대로 보면 이진수가 뒤집혀 있는 것처럼 보인다고 가정한다.
- 아래 예시에서는 true 대신 1로 표시, false 대신 0으로 표시한다. 

`이진수 1100 = [ 0, 0, 1, 1 ]`  `이진수 0101 = [ 1, 0, 1, 0 ]`

- 예상 결과

```
입력 = [0, 1, 1, 1]
결과  = 14

입력  = [1,1,1,1,0,1,0,1]
결과 = 175
```

&gt; 함수 시그니처 예시

&gt; 자바
```java
class Convertor {
    public int bin2dec(boolean[] bin) {
        int answer = 0;
        return answer;
    }
}
```

&gt; 자바스크립트
```javascript
function bin2dec(bin) {
    var answer = 0;
    return answer;
}
```

## 배경 지식

### NAND 게이트
이 게이트는 릴레이가 동작하지 않을 때 전압이 출력되고 전구에 불이 들어오는 특징이 있다.

아래 그림을 살펴보자.
회로에서 나오는 출력이 연결되어 있어서 OR 게이트처럼 비슷하게 보인다. 이 회로는 두 스위치가 모두 닫혀있을 때만 전구에 불이 꺼집니다. 그 외에 나머지 경우에는 불이 켜진다.

![nand](http://public.codesquad.kr/jk/cs23/step1-nand.png)

이 논리 게이트는 AND 게이트의 동작과 완전히 반대로 동작한다. 그래서 이 논리 게이트의 이름을 NOT AND (줄여서 NAND) 게이트라고 한다.

NAND 는 AND 게이트 동작에 NOT(인버터)를 붙인 것과 동일하다.
NAND 게이트의 출력은 다음 표와 같습니다.

| NAND | false  | true   |
|---|---|---|
| false  | true  | true  |
| true | true  | false  |


### NOR 게이트

이 게이트는 릴레이가 동작하지 않을 때 전압이 출력되고 전구에 불이 들어오는 특징이 있다.

아래 그림을 살펴보자.
첫 번째 릴레이의 출력은 두 번째 릴레이에 전력을 공급하는 형태가 된다. 결국 두 입력 모두가 꺼져 있어서 전구에는 불이 들어오게 된다.

![nor](http://public.codesquad.kr/jk/cs23/step1-nor.png)

이 논리 게이트는 OR 게이트의 동작과 완전히 반대로 동작한다. 그래서 이 논리 게이트의 이름을 NOT OR (줄여서 NOR) 게이트라고 한다.

NOR 는 OR 게이트 동작에 NOT(인버터)를 붙인 것과 동일하다.
NOR 게이트의 출력은 다음 표와 같다.

| NOR | false  | true   |
|---|---|---|
| false  | true  | false  |
| true | false  | false  |

### XOR 게이트

이 게이트는 OR 게이트와 비슷하지만 다르다. 서로 다른 값일 때만 불이 들어오는 특징이 있다.

XOR 게이트의 출력은 다음 표와 같다.

| XOR | false  | true   |
|---|---|---|
| false  | false  | true  |
| true | true  | false  |

### 반가산기 half-adder

A,B 두 개 비트를 이진 덧셈기로 더하는 과정을 생각해보자. 
다음과 같이 2비트 값으로 표현해볼 수 있다.

| + | 0  | 1 |
|---|---|---|
| 0 | 00  | 01 |
| 1 | 01 | 10 |

![half-adder](http://public.codesquad.kr/jk/cs23/step1-halfadder.png)

이처럼 한 비트의 두 이진수를 더하면 두 비트가 되며, 각각 합(sum)과 자리올림(carry) 비트라고 한다. 
두 개의 표로 구분해본다.

| 합 | 0  | 1 |
|---|---|---|
| 0 | 0  | 1 |
| 1 | 1 | 0 |

| 자리올림 | 0  | 1 |
|---|---|---|
| 0 | 0  | 0 |
| 1 | 0 | 1 |

### 전가산기 full-adder

위에서 살펴본 반가산기는 이진수 덧셈에서 가장 아래 자릿수만 계산할 수 있다.
두번째 자리부터는 자리올림이 발생하면 그것을 함께 더할 수 있어야 한다.

세 개의 이진수를 더하기 위해서는 두 개의 반가산기와 OR 게이트를 아래 그림처럼 연결하면 된다. 

![full-adder](http://public.codesquad.kr/jk/cs23/step1-fulladder.png)

위와 같은 복잡한 그림 대신에 사각형과 직선으로, 아래처럼 표현하고 전가산기(full-adder)라고 부른다. 

![symbol](http://public.codesquad.kr/jk/cs23/step1-fulladder-symbol.png)

### 진법 변환

- 정수형 10진수 값을 2진수로 표현하는 방법을 학습한다.
- 2진수를 16진수로 변경하는 방법을 학습한다.
- 16진수를 10진수로 변경하는 방법을 학습한다.
- 미리 만들어진 수학 함수가 아니라 4칙연산(+, -, *, /) 연산만으로 계산하는 방식으로 학습한다.

## 학습정리

### 피어 컴파일링 체크포인트

```
  1. [ ] NAND 게이트 구현
  2. [ ] NOR 게이트 구현
  3. [ ] XOR 게이트 구현
  4. [ ] 반쪽덧셈 구현
  5. [ ] 전체덧셈 구현
  6. [ ] 8비트 구현
  7. [ ] 10진수 -&gt; 2진수 변환 구현
  8. [ ] 2진수 -&gt; 10진수 변환 구현
```

### 스스로 확인할 사항
- 4비트나 16비트도 같은 함수로 한꺼번에 처리 가능한가?
- byteA와 byteB 배열의 크기가 다르면 어떻게 처리 가능할까?

### 다같이 확인할 사항
- 바이트 순서를 큰 비트(Most Significant Bit)를 좌측으로 배치하는 것과 우측으로 배치하는 방식이 구현할 때 어떤 장점이 있나?
- 같은 방식으로 2진수를 16진법으로 변환하는 함수를 만든다면 어떤 구조가 될까
- 같은 방식으로 16진수를 2진법으로 변환하는 함수를 만든다면 어떤 구조가 될까
--&gt;</content><author><name>이창권</name></author><summary type="html">논리게이트 기본 게이트와 반가산기, 전가산기, 바이트 가산기 구현 1. 코드 동작 이해 NAND NOT + AND Gate BitA, BitB의 AND연산 결과값에 반전 결과값을 제공한다. 입력값이 전부 같지 않은지를 판별하는 경우에 사용될 수 있다. NOR Not + OR GAte BitA, BitB의 OR연산의 반전 결과값을 제공한다. 입력값이 False로만 이루어진 경우 True를 반환한다. XOR 입력값이 서로 다른 경우인지를 확인하는 Gate BitA 와 BitB 가 서로 다른 경우일 경우만 True를 반환 Half-Adder 반쪽자리 계산기로 두 개의 비트에 대해서 연산을 제공한다. BitA, BitB에 대해 Carry와 Sum 인자를 제공 Carry : nand(bitA, bitB) / Sum : xor(bitA,bitB) Full-Adder 2개의 Half-Adder로 구성된 회로 BitA, BitB, Carry 3개의 입력값을 가진다. Carry는 이전 연산의 오버플로우 값(1bit 기준)으로 현재 연산에 영향을 끼치는 요소이다. 결과 값 Carry는 현재 입력값 중 2개 이상이 true값을 가지는 경우 True가 된다. 결과 값 Sum은 현재 입력값 중 True가 2개가 아닌경우 True가 된다. Carry : ab + bc + ca Sum : abc + abc + abc + abc Byte(8bits) Adder 초기 입력 Carry값은 false로 설정된 Full-Adder를 이용 입력값 중 8bit가 안되는 경우 Zero-Padding을 이용한다. Binary to Decimal ##### Case1 - MSB가 0번 Index에 위치하는 경우 현재 값을 더할 pow(2,i)를 기억할 공간이 줄어든다. 이전 결과값에 2를 곱한후 현재 비트 값을 더하는 방식으로 구현 ##### case 2 - MSB가 Last Index에 위치하는 경우 현재 index의 가중치를 계산해줄 pow변수가 필요 loop당 곱셈연산이 1번 추가된다. 사용자기준에서는 읽기 편하다는 장점이 있다. Decimal to Binary 이전 값에 2로 나눈 나머지 값을 저장하는 방식 Mod 연산 이후 현재 값을 2로 나눈 정수값을 다음 입력값으로 사용 입력값이 0이 될 경우까지 반복된다. 2. 코드 동작 개선 두 개의 bitArray 중 길이가 긴 bitArray의 길이에 맞추어 연산을 하면 길이가 다른 2개의 bitArray가 들어와도 유연하게 처리가 가능하다. Boolean으로 타입을 변환하는 방법 뿐만 아니라 “!!”를 통해서도 Boolean 타입으로 변경이 가능하다. 3. Consideration 바이트 순서를 큰 비트(Most Significant Bit)를 좌측으로 배치하는 것과 우측으로 배치하는 방식이 구현할 때 어떤 장점이 있나? 큰 비트를 좌측으로 배치하는 것을 빅 엔디언, 우측으로 배치하는 방식을 리틀 엔디언이라고 한다. 빅엔디언은 사람이 숫자를 읽고 쓰는 방법과 같기 때문에 개발자의 소프트웨어 디버깅을 편하게 해주는 장점이 있다. 리틀 엔디언은 하위 바이트들만 사용할 때는 별도의 계산이 필요가 없고,가산기와 같은 모듈 설계시 LSB부터 시작하여 자리 올림 계산을 하기 때문에 설계가 더 쉽다는 장점이 있다.(ex. 순회시 정방향) 같은 방식으로 2진수를 16진법으로 변환하는 함수를 만든다면 어떤 구조가 될까 binary를 4bit씩 묶어 10진수로 계산해 변경 2진수 -&amp;gt; 10진수 -&amp;gt; 16진수 16진수를 표기하기 위한 방법을 추가(10-15 -&amp;gt; A-F) 같은 방식으로 16진수를 2진법으로 변환하는 함수를 만든다면 어떤 구조가 될까 16진수 -&amp;gt; 10진수 -&amp;gt; 2진수 16진수를 읽어내기 위한 방법을 추가(A-F -&amp;gt; 10-15)</summary></entry><entry><title type="html">부스트 캠프 Day3</title><link href="https://changgunyee.github.io/boost-camp/2019/07/17/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day3.html" rel="alternate" type="text/html" title="부스트 캠프 Day3" /><published>2019-07-17T00:00:00+09:00</published><updated>2019-07-17T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/17/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day3</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/17/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day3.html">&lt;h1 id=&quot;데이터-다루기&quot;&gt;데이터 다루기&lt;/h1&gt;

&lt;p&gt;customReduce, customFilter, customForEach, customMap 함수와 getMatchedType함수 구현&lt;/p&gt;

&lt;h2&gt;1. 코드 동작 이해&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ForEach함수는 배열의 인자를 parameter로 callback함수 호출&lt;/li&gt;
  &lt;li&gt;Map함수는 리턴 값을 새로운 배열을 만들어 반환
Filter는 callback으로 넘어온 값에 대하여 일치하는 값을 배열로 출력
Reduce는 callback함수의 리턴값을 accumulator로 사용해 축적해 하나의 값을 반환&lt;/li&gt;
  &lt;li&gt;getMatchedType함수는 배열을 순회하며 childNode가 있을 시, 다시 자기자신을 호출하는 재귀의 형식을 통해 구현.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2. 코드 동작 개선&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Reduce는 축적하는 형식의 logic일 때만 사용. 기본적인 배열 순회시에는 forEach를 쓰는 것이 낫다.&lt;/li&gt;
  &lt;li&gt;Decorator를 사용해, return자료형이나 params의 자료형을 명시해 주면 가독성이 높아진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;3. Consideration&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;For-each&lt;/strong&gt;
 Array내용을 순차적으로 순회, callback을 각 item에 대하여 callback을 적용시킨다. 반환값은 없는것이 특징&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt; : For-each와 비슷한 Logic으로 구성, 반환값이 존재한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Filter&lt;/strong&gt; :compare조건에 맞는 내용만 담겨진 Array를 반환해준다. 사용자가 compare함수를 익명함수로 작성해 넘겨 줄 수 있다. boolean Type으로 checking.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Reduce&lt;/strong&gt; :Array를 순회하며 각 내용을 누적시켜 차원이 한단계 줄어드는 효과를 가져오는 함수. String의 경우 문자열이 이어지며, Number의 경우 합이 반환된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Some&lt;/strong&gt; : Array중 비교 조건에 일치하는 값이 있는지만 확인 하는 함수, callback으로 넘어온 함수를 통해 비교하며 값이 일치하는게 한개라도 있는 경우 그 즉시 true를 반환한다. 빈 배열인 경우 false를 반환&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Every&lt;/strong&gt; : Array에 모든 값이 Callback 함수의 조건을 만족하는지 판별하는 함수, 빈 배열인 경우 true를 반환한다. 단 한개라도 불만족 하면 false를 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reduce-활용-예시&quot;&gt;Reduce 활용 예시&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열, 객체 배열에서의 값 합산&lt;/li&gt;
  &lt;li&gt;중첩 배열의 펼침(flatten) ex) 2차원 -&amp;gt; 1차원&lt;/li&gt;
  &lt;li&gt;배열, 객체 내의 값 세기(count 기능)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;함수형-프로그래밍에서의-filter-foreach-map&quot;&gt;함수형 프로그래밍에서의 Filter, forEach, Map&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Filter : callback 에 해당하는 요소들을 새로운 배열로 만들어 리턴해주어서 기존 배열의 불변상태를 유지할 수 있다.&lt;/li&gt;
  &lt;li&gt;forEach : 기존배열의 불변상태를 유지하면서 각 요소를 callback 함수 안에서 실행 할 수 있다.&lt;/li&gt;
  &lt;li&gt;Map : 각 요소를 callback 함수를 실행하여 리턴받은 값을 저장한 새로운 배열을 리턴해 불변성을 유지하면서, callback 함수가 적용된 배열을 만들어 낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day3 데이터 다루기

## 왜 필요한가?
프로그래밍은 결국 많은 데이터를 잘 다루는 것이기도 하다.  알고보면 view계층의 작업역시 데이터에. 의해서 변경되고 렌더링 되는 것이다. 자바스크립트의 대표적인 자료형태는 객체와 배열을 통해 자료를 다양하게 처리하는 연습을 할 줄 알아야 한다. 




## 학습 목표
- 함수그리고 배열과 객체까지를 엮은 프로그래밍을 할 수 있다.

  

----


## 미션

### 1. getMatchedType함수 만들기

- 아래 링크를 눌러서 데이터를 확인한다. 
  - https://git.io/vQukL

    

- 아래처럼 type을 판단해서. 원하는 결과를 문자열을 출력하는 getMatchedType함수를 만든다.

  ```javascript
  //json_tree.js의 데이터
  const jsondata = {....};
  
  //입력
  getMathchedType(jsondata, 'sk')
  
  //출력
  'sk 타입 데이터는 총 5개이며, &quot;Yong&quot;, &quot;hary&quot;, &quot;solvin&quot;, &quot;hani&quot;, &quot;chulsu&quot; 입니다.
  ```

- 재귀호출을 통해서 구현해야 한다. 
- for/while문을 사용하지 않고 구현해본다.
- template literal 문법을 사용한다.

### 2. customReduce 함수구현해서 사용하기

- array에 있는 reduce와 동일하게 동작하는 **customReduce 함수를 직접 구현**하고, 이를 활용해서 이 문제를 푼다
    - 인터넷의 코드를 참고하지 않는다.
- customReduce함수 앞부분에 customReduce동작방식에 대해서 주석으로 설명한다.

### 3.  filter, forEach, map 구현
- 배열의 filter, forEach, map 함수를 직접구현한다. 
- customFilter, customForEach, customMap 으로 이름짓는다.
- 위 문제를 푸는데 구현한 함수를 활용한다. 

----

## 배경 지식



### 1. 객체 &amp; 배열탐색 

#### 객체(object)

- JavaScript로 데이터를 표현하기 위해서는 Array, Object를 사용해야 한다.
- object는 key, value 구조의 자료구조. (es2015에서는 Map이라는 자료구조도 추가됨)
- object는 {} 로 자료를 표현하며, 서버와 클라이언트 간에 데이터를 교환할때 Object형태와 비슷한 방법으로 JSON이라는 데이터 포맷으로 데이터를 교환한다



#### 객체선언

key값에는 따옴표가 필요하지 않다.

```
const obj = { name : &quot;crong&quot;, age : 20} 
```

참고 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Working_with_Objects#객체_생성하기



#### 객체에 데이터 추가/삭제

```javascript
const myFriend = {key : &quot;value&quot;};

//value 출력 
console.log(myFriend[&quot;key&quot;]);
console.log(myFriend.key);

//추가
myFriend.age = 34;

//추가한 정보 출력
console.log(myFriend.age);
```

점 표기법(dot notation)이 [] 를 사용한 방법보다 편의상 좀더 사용된다.





#### 객체 탐색

객체를 탐색하는 방법은 여러가지가 있다. 

아래 다음 방법을 자세히 찾아서 공부해보자. 

for - in 을 사용한 방법, 

Object.keys(), Object.values(), entries() 와 같은 메서드

Object.keys()와 배열메서드(forEach)로 순회 하는 방법 등





#### 배열의 탐색

객체를 다루다보면, 배열과 함께 다루는 경우가 많다. 
따라서 배열의 탐색 방법과 배열의 다양한 메서드를 다시한번 학습해두자.
아래 추가 영상이 도움이 된다. 



#### 참고영상

&lt;iframe src=&quot;https://player.vimeo.com/video/258395204&quot; width=&quot;800&quot; height=&quot;450&quot; frameborder=&quot;0&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&quot;https://vimeo.com/258395204&quot;&gt;7. 자바스크립트 객체&lt;/a&gt; from &lt;a href=&quot;https://vimeo.com/codesquad&quot;&gt;Yoda codd&lt;/a&gt; on &lt;a href=&quot;https://vimeo.com&quot;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;



&lt;iframe src=&quot;https://player.vimeo.com/video/258394161&quot; width=&quot;800&quot; height=&quot;450&quot; frameborder=&quot;0&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&quot;https://vimeo.com/258394161&quot;&gt;9. 배열의 메서드(foreach,map,filter)&lt;/a&gt; from &lt;a href=&quot;https://vimeo.com/codesquad&quot;&gt;Yoda codd&lt;/a&gt; on &lt;a href=&quot;https://vimeo.com&quot;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;



**foreach/map/filter/some/every** 는 매우 유용한 메서드이다. 

다른 함수를 받아서 처리하는 higher order function이다.

reduce 메서드의 동작방식은 약간 차이가 있다. 
하지만 이 메서드는 서버에서도 클라이언트에서도 매우 유용하게 많이쓰는 메서드 임으로 잘 익히는게 좋다. 많은 예제를 돌리면서 reduce를 정복하고 넘어가길 바란다. 



**참고**(이런 사이트는 검색하면 많다)

: https://blog.bitsrc.io/understanding-higher-order-functions-in-javascript-75461803bad



----

## 학습정리

### 피어 컴파일링 체크포인트

```
1. [ ] getMatchedType함수 호출 (sk입력)
2. [ ] getMatchedType함수 호출 (kt입력)
3. [ ] 재귀호출한 부분 존재
4. [ ] customReduce 함수 직접 구현
5. [ ] customReduce 함수를 활용해서 문제 풀이
6. [ ] customFilter, customForEach, customMap 구현확인
```

### 스스로 확인 할 사항
- forEach, map, filter, reduce, some, every 메서드의 용도를 정확히 구분할 수 있는가? 
- sk이외 다른 type에서도 잘 동작하는가 ? 



### 다같이 확인할 사항
- 각자 만든 reduce를  리뷰하고, 버그없고 가장 효율적으로 동작하는 customReduce 함수를 구현해보자.
- reduce의 몇몇 활용 예시를 찾아보고 정리한다.
- 함수형 프로그래밍에서는 forEach, map, filter를 어떤 식으로 사용하는가? 알아보고 정리한다
--&gt;</content><author><name>이창권</name></author><summary type="html">데이터 다루기 customReduce, customFilter, customForEach, customMap 함수와 getMatchedType함수 구현 1. 코드 동작 이해 ForEach함수는 배열의 인자를 parameter로 callback함수 호출 Map함수는 리턴 값을 새로운 배열을 만들어 반환 Filter는 callback으로 넘어온 값에 대하여 일치하는 값을 배열로 출력 Reduce는 callback함수의 리턴값을 accumulator로 사용해 축적해 하나의 값을 반환 getMatchedType함수는 배열을 순회하며 childNode가 있을 시, 다시 자기자신을 호출하는 재귀의 형식을 통해 구현. 2. 코드 동작 개선 Reduce는 축적하는 형식의 logic일 때만 사용. 기본적인 배열 순회시에는 forEach를 쓰는 것이 낫다. Decorator를 사용해, return자료형이나 params의 자료형을 명시해 주면 가독성이 높아진다. 3. Consideration For-each Array내용을 순차적으로 순회, callback을 각 item에 대하여 callback을 적용시킨다. 반환값은 없는것이 특징 Map : For-each와 비슷한 Logic으로 구성, 반환값이 존재한다. Filter :compare조건에 맞는 내용만 담겨진 Array를 반환해준다. 사용자가 compare함수를 익명함수로 작성해 넘겨 줄 수 있다. boolean Type으로 checking. Reduce :Array를 순회하며 각 내용을 누적시켜 차원이 한단계 줄어드는 효과를 가져오는 함수. String의 경우 문자열이 이어지며, Number의 경우 합이 반환된다. Some : Array중 비교 조건에 일치하는 값이 있는지만 확인 하는 함수, callback으로 넘어온 함수를 통해 비교하며 값이 일치하는게 한개라도 있는 경우 그 즉시 true를 반환한다. 빈 배열인 경우 false를 반환 Every : Array에 모든 값이 Callback 함수의 조건을 만족하는지 판별하는 함수, 빈 배열인 경우 true를 반환한다. 단 한개라도 불만족 하면 false를 반환 Reduce 활용 예시 배열, 객체 배열에서의 값 합산 중첩 배열의 펼침(flatten) ex) 2차원 -&amp;gt; 1차원 배열, 객체 내의 값 세기(count 기능) 함수형 프로그래밍에서의 Filter, forEach, Map Filter : callback 에 해당하는 요소들을 새로운 배열로 만들어 리턴해주어서 기존 배열의 불변상태를 유지할 수 있다. forEach : 기존배열의 불변상태를 유지하면서 각 요소를 callback 함수 안에서 실행 할 수 있다. Map : 각 요소를 callback 함수를 실행하여 리턴받은 값을 저장한 새로운 배열을 리턴해 불변성을 유지하면서, callback 함수가 적용된 배열을 만들어 낸다. reference https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</summary></entry><entry><title type="html">부스트 캠프 Day2</title><link href="https://changgunyee.github.io/boost-camp/2019/07/16/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day2.html" rel="alternate" type="text/html" title="부스트 캠프 Day2" /><published>2019-07-16T00:00:00+09:00</published><updated>2019-07-16T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/16/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day2</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/16/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day2.html">&lt;h1 id=&quot;다각형의-넓이&quot;&gt;다각형의 넓이&lt;/h1&gt;

&lt;p&gt;다양한 다각형의 넓이를 구하는 함수를 만들어 봅시다.&lt;/p&gt;

&lt;h2 id=&quot;1-코드-동작-이해&quot;&gt;1. 코드 동작 이해&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;‘getArea()’ 함수 구현&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;type를 check하는 함수를 별도로 구현, const 지시어를 활용해서 error 메시지와 도형의 타입을 정해주고 코드 가독성을 향상, rest parameter를 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;‘getAreaAvg()’ 함수 구현&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;반복문을 순회하면서 원의 넓이를 더하고 평균을 구하는 방식으로 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;`printExecutionSequence()’ 함수 구현&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;reduce를 활용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-스스로-확인할-사항&quot;&gt;2. 스스로 확인할 사항&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;내 코드가 하위함수(sub-routine)로 잘 나눠졌을까? 더 나뉠수는 없을까?&lt;/p&gt;

    &lt;p&gt;아래와 같은 방법으로 함수를 나누어서 구현을 하였음.&lt;/p&gt;
    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getAreaCircle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getAreaParallelogram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getAreaTrapezoid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;checkType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getArea&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-다같이-확인할-사항&quot;&gt;3. 다같이 확인할 사항&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Hoist란?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수를 끌어올리는 것.&lt;/li&gt;
  &lt;li&gt;모든 변수 선언은 hoist된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;변수가 함수 내에 정의되었을 경우, 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우, 전역 context의 최상위로 변경이 된다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 100&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 언어 같은 경우, 변수 x를 선언하지 않고 출력하려고 한다면 오류를 발생하지만, 변수 x가 hoist되기 때문에 자바스크립트는 undefined라고 넘어간다. 이를 작동 순서에 맞게 코드를 재구성하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;선언문&lt;/strong&gt;은 항시 자바스크립트 엔진 구동시 &lt;strong&gt;가장 최우선&lt;/strong&gt;으로 해석하고, &lt;strong&gt;할당 구문&lt;/strong&gt;은 &lt;strong&gt;런타임 과정&lt;/strong&gt;에서 이루어지기 때문에 Hosting 되지 않는다!&lt;/p&gt;

&lt;p&gt;함수가 자신이 위치한 코드에 상관없이, &lt;strong&gt;함수 선언문 형태&lt;/strong&gt;로 정의한 함수의 유효범위는 전체 코드의 제일 처음부터 시작한다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// foo함수에 대한 선언을 hosting하여 global 객체에 등록시키기 때문에&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 선언이 함수 실행 부분보다 뒤에 있더라도 자바스크립트 엔진이 함수 선언을 hoist 한다.&lt;/p&gt;

&lt;p&gt;여기서 주의할 점은 함수 hoisting은 함수를 hoist하지만, &lt;em&gt;변수의 값을 hoist하지 않는다.&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 이와 같은 표현은 함수 리터럴을 할당하는 구조이기 때문에 hoisting 되지 않는다!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;다양한 함수표현방법에 대해서 알아보고, 그 차이점을 정리해본다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수선언식
    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;함수명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;일반적인 프로그래밍 언어에서의 함수선언과 비슷한 형식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;함수 선언식은 호이스팅에 영향을 받음&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;함수표현식
    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;함수명&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;functoin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;유연한 자바스크립트 언어의 특징을 활용한 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;함수 표현식은 호이스팅에 영향을 받지 않음.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순수함수란 무엇인지 알아보고, 어떤 점에서 좋은지 정리해본다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;순수함수의 특성
    &lt;ol&gt;
      &lt;li&gt;순수함수의 리턴값은 오로지 parameter에 의존한다.&lt;/li&gt;
      &lt;li&gt;같은 parameter로 순수함수를 호출한 경우 항상 동일한 결과 값을 얻을 수 있다.&lt;/li&gt;
      &lt;li&gt;순수함수를 통한 parameter는 수정되지 않는다.&lt;/li&gt;
    &lt;/ol&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 순수 함수&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
  &lt;span class=&quot;c1&quot;&gt;// 부수효과가 없고 항상 동일한 인자를 주면 동일한 값을 return하기 때문에 순수함수이다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;순수함수의 장점
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;순수함수는 오류를 줄이고 안정성을 높인다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;모듈화 수준의 향상되기 때문에 생산성을 높일 수 있다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day2 다각형의 넓이

## 왜 필요한가?
- 커다란 문제를 잘게 나누는 것은 프로그래밍을 좀더 작은 단위로 나눠서 해결하는 관점에서 유용하다.  
- 가장 기본적인 단위가 함수라고 볼 수 있다.  함수를 중심으로 잘 나누는 것이 중요하다.

## 학습 목표
- 자바스크립트의 다양한 문법을 익히고, 함수단위로 프로그래밍 할 수 있다.

-----
## 미션

### 1.다각형의 넓이
- 모든 넓이 값을 얻을 수 있는  getArea함수와 getAreaAvg함수를 만든다.
- 하나의 함수로 커다란 코드를 만들지 않고, 각 도형의 넓이를 계산하는 함수를 분리해서 별도로 만든다.
  - 한 함수가 20line을 넘지 않도로 구현.
- 모든 코드에는 가로스크롤이 생길정도로 한줄이 길게 작성하지 않는다.
- 인자값의 타입과 갯수가 올바르지 않다면 적절한 에러를 처리하도록 한다. 
- ES2015이상의 문법을 사용한다. 

```javascript
getArea('circle', 10, 3.14);
&gt;  314

getArea('parallelogram', 10,15);
&gt;  150

getArea('trapezoid', 10,15,12); //윗변,아랫변,높이
&gt;  150

getArea('trapezoid', 10);
&gt;  &quot;에러에요! 인자가 부족합니다.&quot;

getAreaAvg('circle', 5, 11); //0이상의 정수 대해서 처리 가능해야 함 
&gt; 213.52 //PI 가 3.14인 경우
```



### 2. 프로그래밍 계산 순서

  - 프로그래밍에서 로깅(logging)은 프로그램의 수행과정이나 결과를 기록하는 것을 말한다.
  - 여러가지 함수가 호출된 이후에 호출순서가 무엇인지 알려주는 printExecutionSequence함수를 추가로 개발한다.

  ```shell
  getArea('circle', 10, 3.14);
  getArea('parallelogram', 10,15);
  getArea('trapezoid', 10);
  
  printExecutionSequence();
  &gt; 계산수행순서 : circle &gt; parallelogram &gt; trapezoid
  ```





-------
## 배경 지식

### 변수
변수는 var, let, const 로 변수를 선언할 수 있다. 어떤 것을 사용하는 가에 의해서 scope라는 변수의 유효범위가 달라진다.
우선 var를 사용해서 변수를 선언한다. 
여러가지 type의 변수 선언방법을 확인해보자. 

```javascript
var a = 2;
var a = &quot;aaa&quot;;
var a = 'aaa';
var a = true;
var a = [];
var a = {};
var a = undefined;
```

### 연산자
연산자 우선순위를 표현하기 위해서는 ()를 사용하면 된다. 
수학연산자는 +,-,*,/,%(나머지) 등이 있다.

논리 연산자, 관계연산자, 삼항연산자도 있음. 

```javascript
//or 연산자 활용
const name = &quot;crong&quot;;
const result = name || &quot;codesquad&quot;;
console.log(result);
const name = &quot;&quot;;
const result = name || &quot;codesquad&quot;;
console.log(result);
```

---
### 연산자 - 비교연산자
비교는 == 보다는 ===를 사용한다. ==로 인한 다양한 오류 상황이 있는데 아래 결과를 참고하자. 
​```javascript
0 == false;
“” == false;
null == false;
0 == “0”;
null==undefined;
  ```

이런 현상에 대해서는 자바스크립트를 이해하는데 어려움을 느낄 수 있다. 
이런 부분도 자바스크립트의 특징중 하나이며, 이유에 대해서 궁금해 할 필요가 있다. 
이 부분을 좀더 알기 위해서 암묵적인 형변환에 대해서 알아보자.

### 자바스크립트의 Type
자바스크립트 타입에는 다양한 것이 존재.

​```javascript
&gt; undefined, null, boolean, number, string, object, function, array, Date, RegExp,Symbol
  ```

타입은 선언할때가 아니고, 실행타임에 결정된다. 함수안에서의 파라미터나 변수는 실행될때 그 타입이 결정된다. 
타입을 체크하는 또렷한 방법은 없다. 정확하게는 toString.call 을 이용해서 그 결과를 매칭하곤하는데, 문자,숫자와 같은 기본타입은 typeof 키워드를 사용해서 체크할 수 있다. 
배열의 경우 타입을 체크하는 isArray함수가 표준으로 있다.(브라우저 지원범위를 살펴보고 사용해야 함)


### 비교문, 분기문, 반복문
if/switch/for/for-of 문은 MDN사이트를 찾아서 공부하도록 한다.
배열의 경우 forEach와 같은 메서드를 통해서 좀더 쉽게 탐색할 수 있다. 
for-of를 통한 탐색도 자주 사용된다. 
(for-of를 따르는 타입은 배열이외에도 문자열등 더 많다. iterable object인 경우에 for-of를 사용할 수 있는데 이부분은 나중에 더 공부한다)

for-in은 객체를 탐색할때 사용한다. 


### 함수 - 함수의 선언
함수는 여러개의 인자를 받아서, 그 결과를 출력한다. 
파라미터의 갯수와 인자의 갯수가 일치하지 않아도 오류가 나지 않는다. 
파라미터가 1개일때, 인자의 갯수가 0개라면, 파라미터(매개변수)는 undefined이라는 값을 갖게 된다. 값이 할당되지 않았기 때문이다. 

```javascript
function test() { 
	console.log(printName()); 
	 function printName() {
		return 'anonymouse';
	}
}
test() //anonymouse
```
위 함수 선언코드는 함수선언문이라고 한다. 

### 함수 - 함수표현식
함수는 아래 printName과 같이 표현할 수도 있다. (함수가 표현식으로 표현한다는 것은 '값'으로 함수가 표현된다고 생각할 수 있다)
이렇게 표현하면 함수선언문과 달리 선언과 호출순서에 따라서 정상적으로 함수가 실행되지 않는다.
```javascript
function test() { 
	console.log(printName()); 
	var printName = function() {
		return 'anonymouse';
	}
}

test();
//TypeError: printName is not a function
```

오류내용을 보면 function이 아니라고 나왔다.   이유는 printName이 실행되는 순간 'undefined'으로 지정됐기 때문이다. 
자바스크립트 함수는 실행되기 전에 함수안에 필요한 변수값들을 미리 다 모아서 선언한다. 함수 안에 있는 변수들을 모두 끌어올려서 선언한다고해서, hoisting이라고 한다.
따라서 아래 코드역시 함수를 값으로 가지지만 어쨋든 printName도 변수임으로 끌어올려지게 되고, 값이 할당되기 전에 실행됐음으로 undefined이 할당된 상태이다. 


```javascript
printName(); //아직, printName이 undefined으로 할당된 상태이다. 
var printName = function(){}
```
printName이라는 변수가 존재하고 아직 값이 할당되기 전임으로 printName에는 'undefined'이라는 기본 값이 할당된 셈이다.

const와 let을 사용하면 또 달라진다.   이번에는 ReferenceError 가 발생한다. 
const, let을 가급적 사용해서 이와 같이 명확하게 오류를 발생시키는 것이 더 좋다. 

```javascript
function test() { 
	console.log(printName()); 
	const printName = function() {
		return 'anonymouse';
	}
}

test();
//ReferenceError: printName is not defined
```

### 함수 - 반환값과 undefined
아래 함수의 반환값은 무엇일까? 
```javascript
function printName(firstname) {
   const myname = &quot;jisu&quot;;
   const result = myname + &quot; &quot; +  firstname;
}
```
정답은 undefined이다. 자바스크립트 함수는 반드시 return값이 존재하며, 없을때는 기본 반환값인 'undefined'이 반환된다.

### 함수 - arguments 속성
함수가 실행되면 그 안에서 arguments라는 특별한 지역변수가 존재한다.
자바스크립트 함수는 선언한 파라미터보다 더 많은 인자를 보낼 수도 있다. 이때 넘어온 인자를 arguments로 배열의 형태로 하나씩 접근할 수가 있다. arguments는 배열타입은 아니다. 따라서 배열의 메서드를 사용할 수가 없다.
```javascript
function a() {
 console.log(arguments);
}
a(1,2,3);
```
자바스크립트의 가변인자를 받아서 처리하는 함수를 만들때 등에서 arguments속성을 유용하게 사용할 수가 있다.

\# 해볼만한 것(1~무한대까지 인자를 받아 합을 구하는 함수를 만들어보자)


### arrow function  

ES2015에는 [arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)이 추가됐다. 간단하게 함수를 선언할 수 있는 문법으로 처음에는 꽤 낯설다.

```javascript
function getName(name) {
   return &quot;Kim &quot; + name ;
}

//위 함수는 아래 arrow함수와 같다.
const getName = (name) =&gt; &quot;Kim &quot; + name;
```

arrow 함수는 어디서쓸까? 
자바스크립트는 함수의 인자로 함수를 넣을 수 있고, 반환값으로 함수를 사용할 수 있다.
arrow 함수를 이때 사용하면 코드가 보기가 좀더 낫다. 
이런 경우에 arrow 함수를 활용해보도록 하자. 


### 함수호출방식

자바스크립트 함수 호출은 이렇게 불려진다.

run이 호출되고 그다음에 printName이 호출된다

```javascript
// 함수의 호출.
function printName(firstname) {
	var myname = &quot;jisu&quot;;
	return myname + &quot; ,&quot; +  firstname;
}

function run(firstname) {
   var firstname = firstname || &quot;Youn&quot;;
   var result = printName(firstname);
   console.log(result);
}

run();
```

### 재귀(rescursion) 란?

함수가 함수 안에서 자신을 다시 호출하는 것

```
var foo = function() {
    foo();
}
```


### 카운트다운 - 재귀로 구현

음 반복문을 없애고 함수를 다시 호출.

```javascript
var countdown2 = function(n) {
    console.log(n);
    countdown2(n - 1);
};
```



### var로 선언된 변수의 scope

var 를 쓰지 않으면 전역변수가 된다.
var 를 전역공간에 쓰면 전역변수다.
var 를 함수안에서 사용하면 함수안에서만 유효하다 (함수단위의 변수 유효범위를 갖는 것)

```javascript
	var name = 'play ground';
	function home() {
  	  var homeName = 'my house';
	  console.log(name); //play ground
	  console.log(homeName); //my house
	}
	home();	
```


### 블럭단위의 scope

ES2016에서는 const나 let 키워드를 사용해서 변수를 선언하면 Block({})단위의 scope를 만들 수 있다.
키워드를 사용하면 됨.

```javascript
var name = 'play ground';
function home() {
  var homeName = 'my house';
  for (let i = 0; i&lt;1000; i++){}
  console.log(i); //i is not defined
}

```

따라서,Block단위로 사용할때는 const나 let을 사용하는 것을 권장.



### const
const로 선언된 변수는 재선언과 재할당을 할 수 없다.
let 은 재선언은 안되지만 재할당은 가능하다.

```javascript
function home() {
  const homeName = 'my house';
  homeName = 'your house';
}

home() //TypeError: Assignment to constant variable.

```



주의할점은, const를 사용한다고 수정할수 없음을 의미하는 것은 아니다.
const를 사용하더라도 배열과 오브젝트의 값을 변경하는 것은 가능.

```javascript
function home() {
  const list = ['john', 'adele', 'hary'];
  list.push('tiger');
  return list;
}
home() //[&quot;john&quot;, &quot;adele&quot;, &quot;hary&quot;, &quot;tiger&quot;]
```


### const,var, let 추천하는 사용전략

const를 먼저 사용하자. 
재할당해야 하는 경우가 생기면 let을 사용한다.
var는 block scope를 지원하지 않음으로 사용하지 않는다. 

------

#### scope chain

변수를 찾기 위해서,  지역스코프(안쪽함수)에서 전역스코프까지 단계적으로 올라가면서 찾는다.
이를 scope chain이라고 한다. 

```javascript
const name = 'play ground';
function home() {
  const homeName = 'my house';
  function printName() {
     const nickName = 'crong house';
     console.log(nickName); 	//crong house
     console.log(homeName); 	//my house
     console.log(name); 	//play ground
  }
  printName();

}
home();
```

----
## #참고지식들

### 자바스크립트의 버전
- 자바스크립트 버전은 ECMAScript(줄여서ES)의 버전에 따라서 결정되고, 이를 자바스크립트실행 엔진이 반영한다.
- ES5, ES6(ES2015).. 이런식으로 버전을 일컫는다.
- ES6는 ES5문법을 포함하고 있어 하위호환성 문제가 없다.  2019년 현재 ES2015를 기준으로 개발하는 상황이다.
- Front-end의 경우, ES6와 같은 문법을 을 사용하고 싶지만, 브라우저 호환성문제가 있다면 코드를 transpiling 해서 배포하는 경우도 많다. 

### 문자열 처리

자바스크립트의 문자와 문자열은 같은 타입으로 취급. 
```javascript
typeof &quot;abc&quot;;  //string
typeof &quot;a&quot;;    //string
typeof 'a';    //string. single quote도 사용가능.
```

### 문자열에 다양한 메서드가 있음.

```javascript
&quot;ab:cd&quot;.split(&quot;:&quot;); 		//[&quot;ab&quot;,&quot;cd&quot;]
&quot;ab:cd&quot;.replace(&quot;:&quot;, &quot;$&quot;); 	//&quot;ab$cd&quot;
&quot; abcde  &quot;.trim();  		//&quot;abcde&quot;
&quot;뺉&quot;.charCodeAt(); 			//뭘까? 
```


### express &amp; statements
expression(식) 과 statements(문) 의 차이는 용어이긴 하지만 그 차이를 알아둘 필요가 있다. 
expression은 값(value)를 생산해내고, 
statements는 프로그램 로직을 만들어낸다(조건문, 반복문 등)

아래 내용을 참고하면 좋다. 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements
http://2ality.com/2012/09/expressions-vs-statements.html



### 함수호출과 stack

함수 호출 관계는 다음과 같습니다 

bar()  -&gt; foo()

메모리에서는 우측의 Call Stack에서와 같이 순서대로 쌓이게 된다.

bar함수에서 foo를 호출한 후 foo함수의 결과를 받아올 때 까지 bar함수는 메모리 공간에서 사라지지 못하고 기다리고 있는 것이다.  foo의 경우에는 실행이 끝나고 return문이 실행되면 메모리 공간에서 사라진다. 다시말해서 Call Stack에서 없어지는 것이다.

![call stack](https://cdn-images-1.medium.com/max/1760/1*E3zTWtEOiDWw7d0n7Vp-mA.gif)

[출처](https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec)

call stack은 이렇게 동작하지만 함수를 연속적으로 계속 호출하면 call stack이 꽉 차버리면서 더이상 실행되지 못하고 오류가 발생할 것이다. 
브라우저에서는 대부분 지정된 횟수만큼만 call stack을 쌓게 미리 설정해둔 경우가 많다고 한다.

따라서 혹시 개발중에 **Maximum call stack size exceeded** 오류를 발견해도 너무 놀라지 말고, 대처하도록 해야한다.



-----
## 학습정리

### 피어 컴파일링 체크포인트

```
1. [ ] getArea함수에서 circle 계산
2. [ ] getArea함수에서 parallelogram 계산
3. [ ] getArea함수에서 trapezoid 계산
4. [ ] getArea함수에서 trapezoid 인자를 하나면 넣어서 호출해서 에러메시지 출력
5. [ ] getAreaAvg함수에 circle 범위 지정후 계산
6. [ ] 가로스크롤이 생기지 않게 코드 한줄이 긴 부분이 없음
7. [ ] ES2015문법을 충분히 사용했는지(const,let, rest parameter 등)
8. [ ] 각 도형의 넓이를 계산하는 함수가 각각 구현되어 있는지
9. [ ] 구현한 모든 함수의 각각의 길이가 20 line을 넘지 않는지
10. [ ] 잘못된 타입이 입력됐을 때 에러메시지 출력
11. [ ] printExecutionSequence 실행
```

### 스스로 확인할 사항
- 내 코드가 하위함수(sub-routine)로 잘 나눠졌을까? 더 나뉠수는 없을까? 


### 다같이 확인할 사항
- 다양한 함수표현방법에 대해서 알아보고, 그 차이점을 정리해본다.
- 순수함수란 무엇인지 알아보고, 어떤 점에서 좋은지 정리해본다.
- ES2015에서 유용한 문법을 찾아보고 이야기해본다.
  ------

  
--&gt;</content><author><name>이창권</name></author><summary type="html">다각형의 넓이 다양한 다각형의 넓이를 구하는 함수를 만들어 봅시다. 1. 코드 동작 이해 ‘getArea()’ 함수 구현 type를 check하는 함수를 별도로 구현, const 지시어를 활용해서 error 메시지와 도형의 타입을 정해주고 코드 가독성을 향상, rest parameter를 사용 ‘getAreaAvg()’ 함수 구현 반복문을 순회하면서 원의 넓이를 더하고 평균을 구하는 방식으로 구현 `printExecutionSequence()’ 함수 구현 reduce를 활용 2. 스스로 확인할 사항 내 코드가 하위함수(sub-routine)로 잘 나눠졌을까? 더 나뉠수는 없을까? 아래와 같은 방법으로 함수를 나누어서 구현을 하였음. function getAreaCircle() { ... } function getAreaParallelogram() { ... } function getAreaTrapezoid() { ... } function checkType() { ... } function getArea() { ... } 3. 다같이 확인할 사항 Hoist란? 변수를 끌어올리는 것. 모든 변수 선언은 hoist된다. 변수가 함수 내에 정의되었을 경우, 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우, 전역 context의 최상위로 변경이 된다. function getX(){ console.log(x); // undefined var x = 100; console.log(x); // 100 } getX(); 다른 언어 같은 경우, 변수 x를 선언하지 않고 출력하려고 한다면 오류를 발생하지만, 변수 x가 hoist되기 때문에 자바스크립트는 undefined라고 넘어간다. 이를 작동 순서에 맞게 코드를 재구성하면 다음과 같다. function getX(){ var x; console.log(x); x = 100; console.log(x); } getX(); 선언문은 항시 자바스크립트 엔진 구동시 가장 최우선으로 해석하고, 할당 구문은 런타임 과정에서 이루어지기 때문에 Hosting 되지 않는다! 함수가 자신이 위치한 코드에 상관없이, 함수 선언문 형태로 정의한 함수의 유효범위는 전체 코드의 제일 처음부터 시작한다. foo(); // foo함수에 대한 선언을 hosting하여 global 객체에 등록시키기 때문에 function foo() { console.log('hello'); }; &amp;gt; hello 함수 선언이 함수 실행 부분보다 뒤에 있더라도 자바스크립트 엔진이 함수 선언을 hoist 한다. 여기서 주의할 점은 함수 hoisting은 함수를 hoist하지만, 변수의 값을 hoist하지 않는다. foo(); // 이와 같은 표현은 함수 리터럴을 할당하는 구조이기 때문에 hoisting 되지 않는다! var foo = function(){ console.log('hello'); }; &amp;gt; syntax error! 다양한 함수표현방법에 대해서 알아보고, 그 차이점을 정리해본다. 함수선언식 function 함수명() { ... } 일반적인 프로그래밍 언어에서의 함수선언과 비슷한 형식 함수 선언식은 호이스팅에 영향을 받음 함수표현식 var 함수명 = functoin() { ... }; 유연한 자바스크립트 언어의 특징을 활용한 방식 함수 표현식은 호이스팅에 영향을 받지 않음. 순수함수란 무엇인지 알아보고, 어떤 점에서 좋은지 정리해본다. 순수함수의 특성 순수함수의 리턴값은 오로지 parameter에 의존한다. 같은 parameter로 순수함수를 호출한 경우 항상 동일한 결과 값을 얻을 수 있다. 순수함수를 통한 parameter는 수정되지 않는다. // 순수 함수 function add(a, b){ return a + b; } // 부수효과가 없고 항상 동일한 인자를 주면 동일한 값을 return하기 때문에 순수함수이다. 순수함수의 장점 순수함수는 오류를 줄이고 안정성을 높인다. 모듈화 수준의 향상되기 때문에 생산성을 높일 수 있다.</summary></entry><entry><title type="html">부스트 캠프 Day1</title><link href="https://changgunyee.github.io/boost-camp/2019/07/15/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day1.html" rel="alternate" type="text/html" title="부스트 캠프 Day1" /><published>2019-07-15T00:00:00+09:00</published><updated>2019-07-15T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-camp/2019/07/15/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day1</id><content type="html" xml:base="https://changgunyee.github.io/boost-camp/2019/07/15/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Day1.html">&lt;h1 id=&quot;개발환경이해&quot;&gt;개발환경이해&lt;/h1&gt;

&lt;p&gt;최대공약수를 구하는 프로그램&lt;/p&gt;

&lt;h2 id=&quot;1-코드-동작-이해&quot;&gt;1. 코드 동작 이해&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gcd()&lt;/code&gt; 는 모두 유클리드 호제법을 이용&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multipleGcd()&lt;/code&gt; 는 최대공약수를 구하는 식에 결합법칙이 성립함을 이용
    &lt;ul&gt;
      &lt;li&gt;입력으로 주어진 배열을 순회하며 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcd()&lt;/code&gt; 를 호출하는 방식으로 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;입력값을 받는 방법
    &lt;ul&gt;
      &lt;li&gt;함수를 호출하면서 입력값을 주는 방식&lt;/li&gt;
      &lt;li&gt;표준입력방식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-스스로-확인할-사항&quot;&gt;2. 스스로 확인할 사항&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;브랜치는 안전하게 격리된 상태에서 작업해야 할 때 사용한다. 저장소를 새로 만들면 기본으로 마스터 가지가 생성되며, 다른 브랜치를 생성해 작업을 이어갈 수 있다. 작업이 완료되면 다시 마스터로 돌아와 병합하면 된다.&lt;/li&gt;
  &lt;li&gt;(추가적으로 알아본 내용) &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout&lt;/code&gt; 할 때, 브랜치명 또는 commit의 해시값을 넣을 수 있다. 브랜치명을 넣으면 해당 브랜치로 이동하고, 해시값을 넣으면 특정 버전의 commit 시점으로 HEAD를 이동할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-다같이-확인할-사항&quot;&gt;3. 다같이 확인할 사항&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;fork에서 PR까지의 흐름
    &lt;ul&gt;
      &lt;li&gt;원격 저장소에서 fork한 프로젝트를 복제(clone)한다.&lt;/li&gt;
      &lt;li&gt;작업 디렉토리에서 stage에 올릴 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt; 한다.&lt;/li&gt;
      &lt;li&gt;stage에 올라온 파일의 변경 내용을 버전으로 확정하기 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt; 한다.&lt;/li&gt;
      &lt;li&gt;HEAD가 지시하고 있는 버전을 저장소로 &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt; 한다.&lt;/li&gt;
      &lt;li&gt;github 웹 서비스에서 원래 저장소 브랜치와 같은 브랜치인지 확인 후 PR을 보낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;git add와 commit을 할 때 git 내부에서는 어떤 일이 일어나는가
    &lt;ul&gt;
      &lt;li&gt;git의 작업 영역은 &lt;strong&gt;Working directory, Staging area, (Local or Remote) Repository&lt;/strong&gt;로 구성되어 있다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;를 하면 Working directory의 특정 파일을 Staging area로 올려 git이 추적할 수 있게 된다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;은 Staging area의 내용을 버전으로 확정하고 Repository에 반영한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;git workflow란?
    &lt;ul&gt;
      &lt;li&gt;저장소를 관리하기 위한 브랜칭 기법을 말한다.
        &lt;ul&gt;
          &lt;li&gt;프로젝트 규모가 커지고, 많은 인원이 코드에 동시에 접근하면서 발생할 수 있는 문제를 예방하기 위함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Gitflow 모델의 경우, &lt;strong&gt;Master - Develop - Feature - Release - Hotfix&lt;/strong&gt; 브랜치로 나누어 관리한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--
# Day1 개발환경이해

## 왜 필요한가?
- 챌린지과정을 잘 진행할 수 있도록 필요한 개발환경과 학습방법을 이해해야 한다.


## 학습 목표
- 챌린지 과정의 학습순서를 이해한다.
- nodejs로 javascript코드를 실행할 수 있고, VSCode에서 JavaScript프로그램 구현을 할 수 있다.
- 기본 개발 환경을 구성하고 git과  github을 활용해서 소스코드를 관리할 수 있다.



----


## 미션

최대공약수를 구하는 프로그램
### 1. 저장소 fork 
- step1번 문제의 github에 접속해서 fork 를 한다.
- fork한 저장소를 로컬컴퓨터로 clone한다.



### 2. 두 수의 최대공약수를 계산하는 함수를 구현한다. 
```javascript
gcd([18,45])
9
```
step1.js 파일로 결과를 저장한다.



### 3. 2개 이상, n개의 수를 입력받아 최대공약수를 계산하는 multipleGcd함수를 추가로 만든다. 
```javascript
multipleGcd([120,60,40,20,160])
20
```
step1.js 파일에 코드를 추가한다.



### 4. github PR(Pull Request)
  fork한 원래의 원격저장소에 PR을 보낸다. 보낼때 본인의 아이디로 되어 있는 branch로 PR을 보내야 한다.
  master브랜치로 PR을 보내지 않도록 조심한다.

  

### 프로그램조건 
- 함수를 사용해서 구현한다.
- 입력값을 받기 위해서 표준입력방식을 사용해도 되고, 소스코드 파일 안에서 함수를 호출하면서 입력값을 넣어도 된다.
- 최대공약수를 구하는 방법은 이미 알려진 알고리즘을 활용해도 상관없다.
- 결과는 VSCODE콘솔에 출력되야 한다.
- 함수  구현이 끝나면 git commit 으로 완성된 결과를 커밋하고, 커밋로그를 작성한다.
- 다 완성이 되면 fork한 github저장소에 코드를 push 한다.



-----
## 배경 지식

### 개발환경
- 개발도구는 자유롭게 본인이 선택할 수 있다. 
- 과정 전체에서는 VSCode(Visual Studio Code)사용을 권장하며 사용을 원하는 개발자는 VSCODE를 찾아서 설치하도록 한다.
- 참고로 IDE라는 것이 무엇인지 공부하면 좋다.


### NodeJS
- NodeJS를 통해서 JavaScript를 브라우저 이외의 공간에서 실행할 수 있음.
- NodeJS를 통해서 JavaScript코드를 CLI(Command Line Interface)를 통해서 실행할 수 있음.
- NodeJS 프로그램을 설치한다. (여러버전을 설치할 수 있지만, 가급적 10.16 버전을 설치하는 것을 권장한다)
- NodeJS 실행은 터미널환경에서 실행할 수 있음
- 윈도우에서는 파워쉘이나 윈도우bash 또는 VSCode에서 제공하는 터미널을 사용할 수 있음
- MAC OS에서는 기본 제공되는 터미널 프로그램을, 활용하거나 VSCode의 터미널을 활용

```shell
//run.js 파일을 실행하는 방법
&gt; node run.js
```



### 터미널 명령어

터미널을 사용하다보면 디렉토리를 만들고, 제거하거나 파일을 복사하는 등의 작업을 해야 한다. 기본적인 명령어를 공부하자.
(UNIX 명령어로 검색하는 것도 방법)
- cd
- mv
- mkdir
- rm
- cp



### git
##### git이란? 
- 소스코드를 완성하면서 의미있는 지점마다 기억할 필요가 있다. git을 활용하면 원하는 시점에서의 변경사항을 기록하게 할 수 있다.
- git이 무엇인지 좀더 공부하도록 한다
- git에 대한 학습자료는 '생활코딩' 등 국내의 자료도 무수히 많다.
- git이 설치되어 있지 않다면 git을 설치하도록 한다. 

##### 필수 명령어
git실행을 위해서 필수 명령어를 공부하도록 한다.
- add
- commit
- branch
- checkout
- merge

##### git clone 과 로컬 branch개발
원격지(github 의 저장소)에서 git clone 명령어를 통해서 로컬컴퓨터에 소스코드를 내려받을 수 있다.
그 이후에는 checkout명령어를 활용해서 새로운 로컬 브랜치를 생성할 수 있다.
fork한 이후에 로컬에서 어떻게 브랜치를 만들어서 개발할 수 있는지 공부하자.

##### push
git commit 을 통해서 소스코드의 변경을 저장한 후에는, git push를 통해서 원격저장소(github)에 코드를 올려서 다른사람과 코드를 공유할 수 있다.
push, pull 명령어를 공부한다.

##### PR
Pull Request를 통해서 fork를 했던 원래의 저장소에  소스코드를 보낼 수가 있다.
이과정은 fork한 후에  어떤 변경을 한후, 원래의 소스코드 저장소에 이를 반영하는 과정이라고 이해할 수 있다.
github사이트에서 PR을 보내는 방법을 찾아서 공부하고 실습해보는 것을 권장한다.



----

### 부캠 과정에서 fork부터 PR보내기까지 과정

##### 1. fork한 프로젝트를 자신의 컴퓨터로 clone한다.

주의사항은 clone할때 single-branch 옵션을 주어야 한다는 것이다.

```shell
git clone https://github.com/{본인깃헙아이디}/{저장소이름} -b {본인아이디} --single-branch

ex) 깃헙아이디가 crong, 본인아이디 ss66이고, 저장소가 day1-challenge 인경우,
git clone https://github.com/crong/day1-challenge -b ss66 --single-branch
```



##### 2. commit

```shell
git status //확인

git rm 파일명 //삭제된 파일

git add 파일명(or * 모두) // 추가/변경 파일

git commit -m &quot;메세지&quot; // 커밋

```





##### 3. 본인 원격 저장소에 올리기

```shell
git push origin 본인_브랜치

ex) git push origin ss66

```



##### 4. Pull Request보내기

\- pull request는 github 웹 서비스에서 진행할 수 있다. 

\- pull request는 반드시 connect-foundation의 original 저장소 브랜치와 fork한 **자신의 저장소 브랜치 이름**(ex. ss66)이 같아야 한다. 아래 그림을 참고한다.



&lt;img src=&quot;http://public.codesquad.kr/crong/pr.jpg&quot; width=&quot;600px&quot;  style=&quot;border:2px solid gray;&quot;&gt;


----
## 학습정리
### 피어 컴파일링 체크포인트

```
1. [ ] 두 수의 최대공약수를 계산하는 함수를 구현
2. [ ] n개의 수를 입력받아 최대공약수를 계산하는 multipleGcd함수 구현
3. [ ] 본인의 브랜치로 PR을 보냄
4. [ ] 함수의 실행결과가 VSCODE콘솔에 출력
5. [ ] 커밋로그가 함수단위로 되어 있음
```

### 스스로 확인할 사항
- 최대공약수 문제는 잘 동작하는가? 
- 필요한 함수를 여러가 만들었는가?
- git의 branch에 대해서 이해를 하고 있는가? 
- vscode에서 개발한 후에 commit을 하고, fork한 저장소로 잘 push했는가?


### 다같이 확인할 사항
- fork에서 시작해서 PR을 보낼때까지의 흐름에 대해서 제대로 이해하고 있는지 서로 설명해본다.
- git add와 commit을 할때 git 내부에서는 어떤 일이 일어나는 것인지 찾아서 학습하고 이를 정리한다.
- 여러명이 협업을 하며 프로젝트를 개발할때는 다양한 branch전략을 세워서 한다. 실무에서 사용하는 git workflow에 대해서 찾아보고, 왜 그런 전략이 필요한지 고민한 후 정리한다.

--&gt;</content><author><name>이창권</name></author><summary type="html">개발환경이해 최대공약수를 구하는 프로그램 1. 코드 동작 이해 gcd() 는 모두 유클리드 호제법을 이용 multipleGcd() 는 최대공약수를 구하는 식에 결합법칙이 성립함을 이용 입력으로 주어진 배열을 순회하며 gcd() 를 호출하는 방식으로 구현 입력값을 받는 방법 함수를 호출하면서 입력값을 주는 방식 표준입력방식 2. 스스로 확인할 사항 브랜치는 안전하게 격리된 상태에서 작업해야 할 때 사용한다. 저장소를 새로 만들면 기본으로 마스터 가지가 생성되며, 다른 브랜치를 생성해 작업을 이어갈 수 있다. 작업이 완료되면 다시 마스터로 돌아와 병합하면 된다. (추가적으로 알아본 내용) git checkout 할 때, 브랜치명 또는 commit의 해시값을 넣을 수 있다. 브랜치명을 넣으면 해당 브랜치로 이동하고, 해시값을 넣으면 특정 버전의 commit 시점으로 HEAD를 이동할 수 있다. 3. 다같이 확인할 사항 fork에서 PR까지의 흐름 원격 저장소에서 fork한 프로젝트를 복제(clone)한다. 작업 디렉토리에서 stage에 올릴 파일을 add 한다. stage에 올라온 파일의 변경 내용을 버전으로 확정하기 위해서 commit 한다. HEAD가 지시하고 있는 버전을 저장소로 push 한다. github 웹 서비스에서 원래 저장소 브랜치와 같은 브랜치인지 확인 후 PR을 보낸다. git add와 commit을 할 때 git 내부에서는 어떤 일이 일어나는가 git의 작업 영역은 Working directory, Staging area, (Local or Remote) Repository로 구성되어 있다. git add를 하면 Working directory의 특정 파일을 Staging area로 올려 git이 추적할 수 있게 된다. git commit은 Staging area의 내용을 버전으로 확정하고 Repository에 반영한다. git workflow란? 저장소를 관리하기 위한 브랜칭 기법을 말한다. 프로젝트 규모가 커지고, 많은 인원이 코드에 동시에 접근하면서 발생할 수 있는 문제를 예방하기 위함 Gitflow 모델의 경우, Master - Develop - Feature - Release - Hotfix 브랜치로 나누어 관리한다.</summary></entry><entry><title type="html">부스트 코스(웹) PROJ3-1</title><link href="https://changgunyee.github.io/boost-course/2019/07/10/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BD%94%EC%8A%A4(%EC%9B%B9)-proj3.html" rel="alternate" type="text/html" title="부스트 코스(웹) PROJ3-1" /><published>2019-07-10T00:00:00+09:00</published><updated>2019-07-10T00:00:00+09:00</updated><id>https://changgunyee.github.io/boost-course/2019/07/10/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BD%94%EC%8A%A4(%EC%9B%B9)-proj3</id><content type="html" xml:base="https://changgunyee.github.io/boost-course/2019/07/10/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BD%94%EC%8A%A4(%EC%9B%B9)-proj3.html">&lt;p&gt;이번에 부스트 코스(웹) 과정을 시작하게 되었습니다.&lt;/p&gt;

&lt;p&gt;그럼 부스트 코스가 무엇인지 부터 알려드려야겠죠?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;부스트코스(웹)이란?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;부스트코스에서는 단순히 이론이나 지식만을 배우는 것이 아니라 프로젝트를 통해 다양한 웹 애플리케이션을 직접 만들어보게 됩니다. 단계별 프로젝트를 통해 웹 개발 실무를 경험해보세요. 전문가의 코드리뷰와 반복적인 코드 작성으로 실무형 웹서비스를 직접 만드는 수준까지 발전할 수 있습니다!&lt;/p&gt;

&lt;p&gt;이 과정을 통해&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 현업에서 활용되는 HTML/CSS, JavaScript, JAVA, Spring, Spring MVC, Spring JDBC, SQL에 대해 이해할 수 있습니다.
- 실제 운영되고 있는 서비스인 &amp;lt;네이버 예약&amp;gt;을 처음부터 끝까지 직접 만들어보는 경험을 하게 됩니다.
- 프론트엔드, 백엔드를 막론하고 실무에 필요한 기초적인 웹 애플리케이션을 혼자 만들어 볼 수 있는 수준으로 성장합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코스를 통해서는 전문가에게 프로젝트 리뷰를 받아볼수도 있습니다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 유료 결제하여 프로젝트를 제출할 수 있습니다.
- 현업 선배 개발자가 프로젝트를 검토한 후 명확하고 친절한 코드리뷰를 제공합니다.
- 코드리뷰와 피드백을 참고하여 모든 프로젝트를 성공적으로 통과해보세요!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;웹-프로젝트-3-시작&quot;&gt;웹 프로젝트 3 시작!&lt;/h3&gt;

&lt;p&gt;프로젝트3부터 프로젝트 6까지는 기존에 네이버에 존재하는 예약 관리 시스템을 만들어 보는 것입니다.
프로젝트3 수업에서 학습하는 내용은 간단히 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Web Animation
- Web UI &amp;gt; DOMContentLoaded이벤트, Event delegation, HTML templating
- Tab UI 실습
- Spring Core &amp;gt; Spring에 대한 기초 학습, Java Config&amp;amp;Xml을 이용한 설정
- Spring JDBC의 이해와 실습
- Spring MVC에 대한 이해와 실습
- 레이어드 아키텍처 실습
- Rest Controller의 기초와 실습
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로젝트 3-1은 백엔드와 관련된 내용으로 다음과 같은 기술을 구현해야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 웹백엔드 기술요구사항

    - 제공된 SQL을 이용해서 테이블을 생성하고, 샘플데이터를 입력합니다.
    - maven을 이용해서 웹 어플리케이션 프로젝트를 작성합니다.
    - 학습했던 것처럼 controller,service,dao로 레이어드 아키텍쳐를 구성합니다.
    - spring JDBC를 이용하여 주어진 테이블로부터 입력, 수정, 삭제, 조회하는 DAO와 DTO를 
      작성합니다.
    - 서비스 인터페이스를 작성하고 해당 서비스 인터페이스에 비지니스 메소드를 작성합니다.
    - 서비스 인터페이스를 구현하는 클래스를 작성합니다.
    - 해당 구현 클래스의 메소드에 적절한 트랜잭션에 관련된 애노테이션을 사용합니다.
    - 클라이언트에게 Web API를 제공하기 위해 RestController 를 작성합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로젝트 통과한 모습입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2019-07-10/부스트코스3-1_pass모습.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부스트 코스 에이스 또한 신청하였습니다!!!!&lt;/p&gt;

&lt;p&gt;앞으로 진행하면서, 프로젝트 3-2 부터는 학습한 내용을 따로 포스팅하고 프로젝트 진행시 에러나 어려웠던 점 또한 기록하려고 합니다.&lt;/p&gt;

&lt;p&gt;감사합니다~~&lt;/p&gt;</content><author><name>이창권</name></author><summary type="html">이번에 부스트 코스(웹) 과정을 시작하게 되었습니다. 그럼 부스트 코스가 무엇인지 부터 알려드려야겠죠? 부스트코스(웹)이란? 부스트코스에서는 단순히 이론이나 지식만을 배우는 것이 아니라 프로젝트를 통해 다양한 웹 애플리케이션을 직접 만들어보게 됩니다. 단계별 프로젝트를 통해 웹 개발 실무를 경험해보세요. 전문가의 코드리뷰와 반복적인 코드 작성으로 실무형 웹서비스를 직접 만드는 수준까지 발전할 수 있습니다! 이 과정을 통해 - 현업에서 활용되는 HTML/CSS, JavaScript, JAVA, Spring, Spring MVC, Spring JDBC, SQL에 대해 이해할 수 있습니다. - 실제 운영되고 있는 서비스인 &amp;lt;네이버 예약&amp;gt;을 처음부터 끝까지 직접 만들어보는 경험을 하게 됩니다. - 프론트엔드, 백엔드를 막론하고 실무에 필요한 기초적인 웹 애플리케이션을 혼자 만들어 볼 수 있는 수준으로 성장합니다. 이 코스를 통해서는 전문가에게 프로젝트 리뷰를 받아볼수도 있습니다! - 유료 결제하여 프로젝트를 제출할 수 있습니다. - 현업 선배 개발자가 프로젝트를 검토한 후 명확하고 친절한 코드리뷰를 제공합니다. - 코드리뷰와 피드백을 참고하여 모든 프로젝트를 성공적으로 통과해보세요! 웹 프로젝트 3 시작! 프로젝트3부터 프로젝트 6까지는 기존에 네이버에 존재하는 예약 관리 시스템을 만들어 보는 것입니다. 프로젝트3 수업에서 학습하는 내용은 간단히 다음과 같습니다. - Web Animation - Web UI &amp;gt; DOMContentLoaded이벤트, Event delegation, HTML templating - Tab UI 실습 - Spring Core &amp;gt; Spring에 대한 기초 학습, Java Config&amp;amp;Xml을 이용한 설정 - Spring JDBC의 이해와 실습 - Spring MVC에 대한 이해와 실습 - 레이어드 아키텍처 실습 - Rest Controller의 기초와 실습 프로젝트 3-1은 백엔드와 관련된 내용으로 다음과 같은 기술을 구현해야 합니다. - 웹백엔드 기술요구사항 - 제공된 SQL을 이용해서 테이블을 생성하고, 샘플데이터를 입력합니다. - maven을 이용해서 웹 어플리케이션 프로젝트를 작성합니다. - 학습했던 것처럼 controller,service,dao로 레이어드 아키텍쳐를 구성합니다. - spring JDBC를 이용하여 주어진 테이블로부터 입력, 수정, 삭제, 조회하는 DAO와 DTO를 작성합니다. - 서비스 인터페이스를 작성하고 해당 서비스 인터페이스에 비지니스 메소드를 작성합니다. - 서비스 인터페이스를 구현하는 클래스를 작성합니다. - 해당 구현 클래스의 메소드에 적절한 트랜잭션에 관련된 애노테이션을 사용합니다. - 클라이언트에게 Web API를 제공하기 위해 RestController 를 작성합니다. 프로젝트 통과한 모습입니다. 부스트 코스 에이스 또한 신청하였습니다!!!! 앞으로 진행하면서, 프로젝트 3-2 부터는 학습한 내용을 따로 포스팅하고 프로젝트 진행시 에러나 어려웠던 점 또한 기록하려고 합니다. 감사합니다~~</summary></entry></feed>